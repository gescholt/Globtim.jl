"""
    discrete_l2_norm_riemann(f, grid::Array{SVector{N,Float64},N}) where N -> Float64

Compute a discrete L² norm approximation using a Riemann sum over an N-dimensional grid of points.
This implementation is particularly suited for non-uniform grids such as Chebyshev points, where
it constructs appropriate cell volumes based on the spacing between points.

# Arguments
- `f`: Function to integrate. Should accept an `SVector{N,Float64}` and return a real number
- `grid::Array{SVector{N,Float64},N}`: N-dimensional array of grid points, where each point is 
   represented as an SVector{N,Float64}. Typically generated by `generate_grid` or 
   `generate_grid_small_n`

# Returns
- `Float64`: The approximate L² norm computed as sqrt(∫|f|² dx) using a Riemann sum approximation

# Method
The function constructs a Riemann sum approximation by:
1. Identifying unique coordinates in each dimension
2. Computing cell boundaries as midpoints between adjacent points
3. Using [-1,1] as domain boundaries
4. Computing cell volumes as products of distances between adjacent boundaries
5. Summing |f|² weighted by these cell volumes

# Example
```julia
# Create 2D Chebyshev grid
grid = generate_grid(2, 10, basis=:chebyshev)

# Define test function
f(x) = sum(x.^2)

# Compute norm
norm = discrete_l2_norm_riemann(f, grid)
Notes

For a uniform grid (e.g., Legendre points), this will approximate the standard L² norm
For Chebyshev points, this accounts for the non-uniform point distribution
The cell volumes are constructed to cover the entire [-1,1]ⁿ domain
No normalization of volumes is performed, so the sum of volumes might slightly deviate from 2ⁿ
(the volume of [-1,1]ⁿ)

For large sample grids, the function may be slow due to the nested product loop over grid points. 
"""

function discrete_l2_norm_riemann(f, grid::Array{SVector{N,Float64},N}) where {N}
    GN = size(grid, 1) - 1  # Number of intervals

    # Create vectors of the unique coordinates in each dimension
    coords = [sort(unique([p[i] for p in vec(grid)])) for i = 1:N]

    # Compute cell boundaries as midpoints between adjacent points
    # Add domain boundaries [-1,1] as endpoints
    cell_bounds =
        [vcat(-1.0, [(coords[d][i] + coords[d][i+1]) / 2 for i = 1:GN], 1.0) for d = 1:N]

    # Compute cell volumes
    cell_volumes = [
        SVector{N,Float64}(
            ntuple(d -> cell_bounds[d][idx[d]+1] - cell_bounds[d][idx[d]], N),
        ) for idx in Iterators.product(fill(1:GN+1, N)...)
    ]

    # Compute cell volumes as products of side lengths
    volumes = [prod(vol) for vol in cell_volumes]

    # Reshape to match grid structure
    volumes = reshape(volumes, fill(GN + 1, N)...)

    # Compute Riemann sum
    sum_squares = sum(abs2(f(x)) * v for (x, v) in zip(grid, volumes))

    return sqrt(sum_squares)
end

"""Simplified Lambda Vandermode function for Chebyshev basis"""
function simple_lambda_vandermonde(Lambda::NamedTuple, points::Matrix{Float64})
    # Extract dimensions from inputs
    lambda_matrix = Matrix(Lambda.data')
    n_points = size(points, 1)
    n_terms = Lambda.size[1]
    n_vars = size(points, 2)

    # Validate inputs
    n_vars == 2 || error("Expected 2D points, got $(n_vars)D")
    size(lambda_matrix, 1) == n_vars ||
        error("Lambda matrix first dimension must match number of variables")

    # Initialize Vandermonde matrix: (n_points × n_terms)
    V = zeros(n_points, n_terms)

    # Compute Chebyshev polynomial evaluations
    for i = 1:n_points, j = 1:n_terms
        term_value = 1.0
        for k = 1:n_vars
            x = points[i, k]
            abs(x) <= 1 || error("Point $i coordinate $k = $x outside [-1,1]")

            # Evaluate Chebyshev polynomial of degree lambda_matrix[k,j] at x
            degree = lambda_matrix[k, j]
            theta = acos(x)
            term_value *= cos(degree * theta)
        end
        V[i, j] = term_value
    end

    return V
end
