# ==== For Msolve ====
"""
    process_output_file(file_path::String)

Parse the output file generated by `msolve`.

# Arguments
- `file_path::String`: Path to the output file.

# Returns
- Parsed content of the output file.
"""

function parse_rational(str::AbstractString)
    m = match(r"(-?\d+)\s*/\s*2\^(\d+)", strip(str))
    isnothing(m) && error("Invalid format: $str")
    Float64(parse(BigInt, m[1]) / BigFloat(2)^parse(Int, m[2]))
end



function process_output_file(file_path::String; dim::Int = 3)
    content = read(file_path, String)
    content = replace(content, r":\]$" => "]", r"\s+" => "")

    pair_pattern = r"\[([-\d]+/2\^[\d]+),([-\d]+/2\^[\d]+)\]"
    points = Vector{Vector{Float64}}()
    current_point = Vector{Float64}()

    for m in eachmatch(pair_pattern, content)
        # Process each rational directly to float
        for i = 1:2
            num = parse(BigInt, match(r"(-?\d+)/2\^(\d+)", m[i]).captures[1])
            exp = parse(Int, match(r"(-?\d+)/2\^(\d+)", m[i]).captures[2])
            val = Float64(num / BigFloat(2)^exp)
            i == 2 && push!(current_point, (val + last_val) / 2)
            i == 1 && (global last_val = val)
        end

        length(current_point) == dim &&
            (push!(points, copy(current_point)); current_point = Vector{Float64}())
    end

    !isempty(current_point) && error("Incomplete point")
    return points
end


function msolve_parser(file_path::String, f::Function, TR::test_input)::DataFrame
    total_time = @elapsed begin
        println("\n=== Starting MSolve Parser (dimension: $(TR.dim)) ===")

        if !isfile(file_path)
            error("File not found: $file_path")
        end

        try
            process_time = @elapsed points = process_output_file(file_path, dim = TR.dim)
            println(
                "Processed $(length(points)) points ($(round(process_time, digits=3))s)",
            )

            if !all(p -> length(p) == TR.dim, points)
                invalid_points = filter(p -> length(p) != TR.dim, points)
                error("Found points with incorrect dimension: $invalid_points")
            end

            filtered_points = filter(p -> all(-1 .<= p .<= 1), points)

            if isempty(filtered_points)
                println("No valid points found after filtering")
                return DataFrame(Dict(Symbol("x$i") => Float64[] for i = 1:TR.dim))
            end

            # Convert center to vector if it's not already
            center_vec = Vector(TR.center)
            # Transform each point
            points_to_process =
                [TR.sample_range .* p .+ center_vec for p in filtered_points]

            z = [f(p) for p in points_to_process]

            df = DataFrame(
                merge(
                    Dict(
                        Symbol("x$i") => [p[i] for p in points_to_process] for
                        i = 1:TR.dim
                    ),
                    Dict(:z => z),
                ),
            )

            return df
        catch e
            println("Error in msolve_parser: ", e)
            println("Stack trace:")
            for (exc, bt) in Base.catch_stack()
                showerror(stdout, exc, bt)
                println()
            end
            rethrow(e)
        finally
            # Clean up the output file after processing
            isfile(file_path) && rm(file_path)
        end
    end
    println("Total execution time: $(round(total_time, digits=3))s")
end



"""
    parse_point(X::Vector{Vector{Vector{BigInt}}})::Vector{Rational{BigInt}}

Parse a nested vector of `BigInt` values and convert them into a vector of `Rational{BigInt}`.

# Arguments
- `X::Vector{Vector{Vector{BigInt}}}`: A nested vector where each element is a vector of two vectors, each containing two `BigInt` values. The first value in each inner vector represents the numerator, and the second value represents the exponent of the denominator (which is a power of 2).

# Returns
- `Vector{Rational{BigInt}}`: A vector of `Rational{BigInt}` values, where each value is the average of the two rational numbers represented by the input vectors.

# Example
```julia
X = [
    [[1, 1], [3, 1]],  # Represents 1/2 and 3/2
    [[2, 2], [6, 2]]   # Represents 2/4 and 6/4
]
result = parse_point(X)
# result is a vector of Rational{BigInt} values: [1, 1]

"""
function parse_point(X::Vector{Vector{Vector{BigInt}}})::Vector{Float64}
    map(X) do x
        low = Float64(x[1][1] / BigFloat(2)^x[1][2])
        high = Float64(x[2][1] / BigFloat(2)^x[2][2])
        (low + high) / 2
    end
end


"""
    process_critical_points(
        real_pts::Vector{<:AbstractVector},
        f::Function,
        TR::test_input;
        kwargs...
    )::DataFrame

Process critical points in n-dimensional space and return a DataFrame.
Points are automatically filtered to the [-1,1]^n hypercube and transformed according to the test_input parameters.

# Arguments
- `real_pts`: Vector of points in n-dimensional space
- `f`: Function to evaluate at each point
- `TR`: test_input struct containing dimension, center, and sample range information

# Returns
- DataFrame with columns x1, x2, ..., xn (for n dimensions) and z (function values)

# Example
```julia
TR = test_input(dim=2, center=[0.0, 0.0], sample_range=1.0)
points = [[0.5, 0.5], [-0.5, 0.5]]
f(x) = sum(x.^2)
df = process_critical_points(points, f, TR)
```
"""
function process_critical_points(
    real_pts::Vector{<:AbstractVector},
    f::Function,
    TR::test_input;
    kwargs...,
)::DataFrame
    total_time = @elapsed begin
        println("\n=== Starting Critical Points Processing (dimension: $(TR.dim)) ===")

        try
            # Validate input dimensions
            if !all(p -> length(p) == TR.dim, real_pts)
                invalid_points = filter(p -> length(p) != TR.dim, real_pts)
                error("Found points with incorrect dimension: $invalid_points")
            end

            process_time = @elapsed begin
                # Filter points in [-1,1]^n hypercube
                filtered_points = filter(p -> all(-1 .<= p .<= 1), real_pts)

                if isempty(filtered_points)
                    println("No valid points found after filtering")
                    return DataFrame(Dict(Symbol("x$i") => Float64[] for i = 1:TR.dim))
                end

                # Transform points using test_input parameters
                center_vec = Vector(TR.center)
                points_to_process =
                    [TR.sample_range .* p .+ center_vec for p in filtered_points]

                # Evaluate function at transformed points
                z = [f(p) for p in points_to_process]

                # Create DataFrame
                df = DataFrame(
                    merge(
                        Dict(
                            Symbol("x$i") => [p[i] for p in points_to_process]
                            for i = 1:TR.dim
                        ),
                        Dict(:z => z),
                    ),
                )
            end

            println("Processed $(size(df, 1)) points ($(round(process_time, digits=3))s)")
            return df

        catch e
            println("Error in process_critical_points: ", e)
            println("Stack trace:")
            for (exc, bt) in Base.catch_stack()
                showerror(stdout, exc, bt)
                println()
            end
            rethrow(e)
        end
    end
    println("Total execution time: $(round(total_time, digits=3))s")
end

function average(X::Vector{T}) where {T<:Number}
    # Convert each number to rational first
    rationals = Rational{BigInt}.(X)
    # Take the average
    avg_rational = sum(rationals) // length(X)
    # Convert back to float
    return Float64(avg_rational)
end

# Helper function to check if the result is reasonable
function safe_average(X::Vector{T}) where {T<:Number}
    result = average(X)
    if isinf(result) || isnan(result)
        println("Warning: got $(result) for input: $X")
        # Could add fallback behavior here if needed
    end
    return result
end

"""
    solve_and_parse(pol::ApproxPoly, x, f::Function, TR::test_input; kwargs...)
"""
function solve_and_parse(
    pol::ApproxPoly,
    x,
    f::Function,
    TR::test_input;
    basis::Symbol = :chebyshev,
    kwargs...,
)
    # First run msolve_polynomial_system and get the output file path
    output_file = msolve_polynomial_system(pol, x; n = TR.dim, basis = basis)

    # Then parse the results and get the DataFrame
    # The output file will be automatically cleaned up after parsing
    df = msolve_parser(output_file, f, TR)

    return df
end
