# Security and Dependency Scanning for Globtim.jl

stages:
  - security-scan
  - dependency-check
  - code-quality

variables:
  JULIA_DEPOT_PATH: "$CI_PROJECT_DIR/.julia"

# Julia package vulnerability scanning
security:julia-audit:
  stage: security-scan
  before_script:
    - curl -fsSL https://install.julialang.org | sh -s -- -y
    - export PATH="$HOME/.juliaup/bin:$PATH"
    - juliaup add 1.11
  script:
    - export PATH="$HOME/.juliaup/bin:$PATH"
    - julia --project=@. -e 'using Pkg; Pkg.instantiate()'
    - |
      julia --project=@. -e '
        using Pkg
        
        println("üîç Julia Package Security Audit")
        println("=" ^ 40)
        
        # Get all dependencies
        deps = Pkg.dependencies()
        
        # Check for known vulnerabilities (basic implementation)
        vulnerable_packages = String[]
        outdated_packages = String[]
        
        for (uuid, dep) in deps
          if dep.is_direct_dep
            println("üì¶ $(dep.name) v$(dep.version)")
            
            # Check if package is significantly outdated
            # This is a simplified check - in practice you would use a vulnerability database
            if dep.name in ["HTTP", "JSON", "CSV"] && dep.version < v"1.0"
              push!(outdated_packages, "$(dep.name) v$(dep.version)")
            end
          end
        end
        
        # Report findings
        if !isempty(outdated_packages)
          println("\n‚ö†Ô∏è  Potentially outdated packages:")
          for pkg in outdated_packages
            println("  - $pkg")
          end
        else
          println("\n‚úÖ No obviously outdated packages found")
        end
        
        # Save audit results
        open("security_audit.json", "w") do f
          write(f, """
          {
            "timestamp": "$(now())",
            "total_dependencies": $(length(deps)),
            "outdated_packages": $(length(outdated_packages)),
            "vulnerable_packages": $(length(vulnerable_packages)),
            "packages": [$(join(["\"$(dep.name)\"" for (uuid, dep) in deps if dep.is_direct_dep], ", "))]
          }
          """)
        end
      '
  artifacts:
    reports:
      # GitLab can parse this for security dashboard
      dependency_scanning: security_audit.json
    paths:
      - security_audit.json
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# Dependency license compliance check
dependency:license-check:
  stage: dependency-check
  before_script:
    - curl -fsSL https://install.julialang.org | sh -s -- -y
    - export PATH="$HOME/.juliaup/bin:$PATH"
    - juliaup add 1.11
  script:
    - export PATH="$HOME/.juliaup/bin:$PATH"
    - julia --project=@. -e 'using Pkg; Pkg.instantiate()'
    - |
      julia --project=@. -e '
        using Pkg, TOML
        
        println("üìã License Compliance Check")
        println("=" ^ 30)
        
        # Define acceptable licenses for GPL-3.0 project
        acceptable_licenses = [
          "MIT", "BSD", "Apache-2.0", "GPL-3.0", "GPL-3.0+", 
          "LGPL-3.0", "LGPL-2.1", "ISC", "Zlib", "Public Domain"
        ]
        
        problematic_licenses = String[]
        unknown_licenses = String[]
        
        deps = Pkg.dependencies()
        
        for (uuid, dep) in deps
          if dep.is_direct_dep
            # Try to get license info from registry
            # This is simplified - real implementation would query Julia registry
            pkg_name = dep.name
            
            # Some known licenses for common Julia packages
            license = if pkg_name in ["DataFrames", "CSV", "JSON"]
              "MIT"
            elseif pkg_name in ["LinearAlgebra", "Statistics", "Random"]
              "MIT"  # Julia stdlib
            elseif pkg_name == "HomotopyContinuation"
              "MIT"
            else
              "Unknown"
            end
            
            status = if license in acceptable_licenses
              "‚úÖ"
            elseif license == "Unknown"
              push!(unknown_licenses, pkg_name)
              "‚ùì"
            else
              push!(problematic_licenses, "$pkg_name ($license)")
              "‚ùå"
            end
            
            println("$status $pkg_name: $license")
          end
        end
        
        # Report issues
        if !isempty(problematic_licenses)
          println("\n‚ùå Incompatible licenses found:")
          for pkg in problematic_licenses
            println("  - $pkg")
          end
          exit(1)
        end
        
        if !isempty(unknown_licenses)
          println("\n‚ùì Unknown licenses (manual review needed):")
          for pkg in unknown_licenses
            println("  - $pkg")
          end
        end
        
        println("\n‚úÖ License compliance check passed")
      '
  allow_failure: true  # Don't block pipeline on license issues
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

# Code quality analysis with Aqua.jl
quality:aqua-analysis:
  stage: code-quality
  before_script:
    - curl -fsSL https://install.julialang.org | sh -s -- -y
    - export PATH="$HOME/.juliaup/bin:$PATH"
    - juliaup add 1.11
  script:
    - export PATH="$HOME/.juliaup/bin:$PATH"
    - julia --project=@. -e 'using Pkg; Pkg.instantiate()'
    - |
      julia --project=@. -e '
        using Pkg
        
        # Install Aqua.jl for code quality analysis
        Pkg.add("Aqua")
        
        using Aqua, Globtim
        
        println("üîç Code Quality Analysis with Aqua.jl")
        println("=" ^ 40)
        
        # Run Aqua tests
        try
          # Test for ambiguities
          println("üìä Testing for method ambiguities...")
          Aqua.test_ambiguities(Globtim)
          println("‚úÖ No method ambiguities found")
          
          # Test for undefined exports
          println("üìä Testing undefined exports...")
          Aqua.test_undefined_exports(Globtim)
          println("‚úÖ No undefined exports found")
          
          # Test for unbound args
          println("üìä Testing for unbound args...")
          Aqua.test_unbound_args(Globtim)
          println("‚úÖ No unbound args found")
          
          # Test for persistent tasks
          println("üìä Testing for persistent tasks...")
          Aqua.test_persistent_tasks(Globtim)
          println("‚úÖ No persistent tasks found")
          
          println("\n‚úÖ All Aqua.jl quality checks passed!")
          
        catch e
          println("‚ùå Code quality issues found:")
          println(e)
          
          # Save detailed report
          open("quality_report.txt", "w") do f
            println(f, "Code Quality Report")
            println(f, "==================")
            println(f, "Error: $e")
          end
          
          exit(1)
        end
      '
  artifacts:
    when: on_failure
    paths:
      - quality_report.txt
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

# Documentation link checker
quality:doc-links:
  stage: code-quality
  script:
    - |
      echo "üîó Checking documentation links..."
      
      # Check for broken internal links in markdown files
      find . -name "*.md" -exec grep -l "http" {} \; | while read file; do
        echo "Checking links in $file"
        
        # Extract URLs (simplified regex)
        grep -oE 'https?://[^)]*' "$file" | while read url; do
          # Skip localhost and example URLs
          if [[ "$url" =~ localhost|example\.com|127\.0\.0\.1 ]]; then
            continue
          fi
          
          # Check if URL is accessible (with timeout)
          if ! curl -s --max-time 10 --head "$url" > /dev/null 2>&1; then
            echo "‚ùå Broken link in $file: $url"
          else
            echo "‚úÖ Valid link: $url"
          fi
        done
      done
      
      echo "‚úÖ Documentation link check completed"
  allow_failure: true
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - "**/*.md"
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual

# SAST (Static Application Security Testing) placeholder
# This would integrate with GitLab's built-in SAST analyzers
include:
  - template: Security/SAST.gitlab-ci.yml

# Override SAST for Julia (since GitLab doesn't have built-in Julia SAST)
sast:
  stage: security-scan
  script:
    - |
      echo "üîí Static Application Security Testing for Julia"
      echo "=" ^ 45
      
      # Basic security checks for Julia code
      echo "üìä Checking for potential security issues..."
      
      # Check for eval usage (potential security risk)
      if grep -r "eval(" src/; then
        echo "‚ö†Ô∏è  Found eval() usage - review for security implications"
      fi
      
      # Check for system command execution
      if grep -r "run(\|`" src/; then
        echo "‚ö†Ô∏è  Found system command execution - review for injection risks"
      fi
      
      # Check for file operations that might be risky
      if grep -r "open.*\"w\"\|write.*file" src/; then
        echo "‚ö†Ô∏è  Found file write operations - ensure proper validation"
      fi
      
      echo "‚úÖ Basic security scan completed"
      
      # Create SAST report in GitLab format
      cat > gl-sast-report.json << 'EOF'
      {
        "version": "14.0.0",
        "vulnerabilities": [],
        "scan": {
          "scanner": {
            "id": "custom-julia-sast",
            "name": "Custom Julia SAST"
          },
          "type": "sast",
          "start_time": "2025-01-01T00:00:00",
          "end_time": "2025-01-01T00:01:00",
          "status": "success"
        }
      }
      EOF
  artifacts:
    reports:
      sast: gl-sast-report.json
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
