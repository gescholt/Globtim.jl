"""
AdaptiveFormatCSV Module - Issue #86 Implementation

Adaptive Collection Pipeline for Format Compatibility - provides intelligent CSV format
detection and automatic conversion between coordinate format (x1,x2,x3,x4,z) and
summary format (degree,critical_points,l2_norm).

This module treats format complexity as a collection pipeline responsibility,
maintaining 100% backward compatibility while enabling seamless handling of
multiple CSV formats generated by HPC experiments.

Author: GlobTim Project
Date: September 27, 2025
Issue: #86 - Implement Adaptive Collection Pipeline for Format Compatibility
"""

module AdaptiveFormatCSV

using CSV
using DataFrames
using Statistics
using Printf

# Re-export DefensiveCSV for integration
include("DefensiveCSV.jl")
using .DefensiveCSV
export defensive_csv_read, CSVLoadResult

export detect_csv_format, adaptive_csv_read, AdaptiveCSVResult, CSVFormat
export convert_coordinate_to_summary, validate_format_conversion

"""
Enumeration of supported CSV formats
"""
@enum CSVFormat begin
    COORDINATE_FORMAT    # x1,x2,x3,x4,z format from HPC experiments
    SUMMARY_FORMAT      # degree,critical_points,l2_norm format expected by analysis
    UNKNOWN_FORMAT      # Unrecognized format
end

"""
Result structure for adaptive CSV loading with format detection
"""
struct AdaptiveCSVResult
    success::Bool
    data::Union{DataFrame, Nothing}
    original_format::CSVFormat
    converted_format::Union{CSVFormat, Nothing}
    warnings::Vector{String}
    error::Union{String, Nothing}
    file::String
    load_time::Float64
    conversion_applied::Bool
    metadata::Dict{String, Any}
end

"""
    detect_csv_format(df::DataFrame) -> CSVFormat

Detect the format of a CSV DataFrame based on column structure.

# Format Detection Rules
- COORDINATE_FORMAT: Contains columns x1, x2, x3, x4, z
- SUMMARY_FORMAT: Contains columns degree, critical_points, l2_norm or (degree, critical_points, z)
- UNKNOWN_FORMAT: Does not match any recognized pattern

# Examples
```julia
df_coord = DataFrame(x1=[1.0], x2=[2.0], x3=[3.0], x4=[4.0], z=[5.0])
format = detect_csv_format(df_coord)  # COORDINATE_FORMAT

df_summary = DataFrame(degree=[6], critical_points=[50], l2_norm=[2.5])
format = detect_csv_format(df_summary)  # SUMMARY_FORMAT
```
"""
function detect_csv_format(df::DataFrame)::CSVFormat
    cols = Set(string.(names(df)))

    # Check for coordinate format: x1,x2,x3,x4,z
    if all(col -> col in cols, ["x1", "x2", "x3", "x4", "z"])
        return COORDINATE_FORMAT
    end

    # Check for summary format: degree,critical_points,l2_norm
    if all(col -> col in cols, ["degree", "critical_points", "l2_norm"])
        return SUMMARY_FORMAT
    end

    # Check for alternative summary format: degree,critical_points,z
    if all(col -> col in cols, ["degree", "critical_points", "z"])
        return SUMMARY_FORMAT
    end

    return UNKNOWN_FORMAT
end

"""
    convert_coordinate_to_summary(df_coord::DataFrame, degree::Int) -> DataFrame

Convert coordinate format DataFrame to summary format.

Transforms individual critical point coordinates (x1,x2,x3,x4,z) into
summary statistics (degree, critical_points, l2_norm).

# Arguments
- `df_coord::DataFrame`: DataFrame in coordinate format
- `degree::Int`: Polynomial degree to assign to summary

# Returns
DataFrame with columns: degree, critical_points, l2_norm

# Algorithm
- critical_points: Number of rows in coordinate data
- l2_norm: Mean L2 norm of all coordinate points
- degree: Provided degree parameter

# Examples
```julia
coord_df = DataFrame(
    x1=[1.0, 2.0], x2=[1.0, 2.0], x3=[1.0, 2.0], x4=[1.0, 2.0], z=[2.0, 4.0]
)
summary_df = convert_coordinate_to_summary(coord_df, 6)
# Result: DataFrame with degree=6, critical_points=2, l2_norm=3.0
```
"""
function convert_coordinate_to_summary(df_coord::DataFrame, degree::Int)::DataFrame
    if nrow(df_coord) == 0
        return DataFrame(degree=Int[], critical_points=Int[], l2_norm=Float64[])
    end

    # Calculate L2 norms for each coordinate point
    l2_norms = Float64[]
    for i in 1:nrow(df_coord)
        coords = [df_coord[i, :x1], df_coord[i, :x2], df_coord[i, :x3], df_coord[i, :x4]]
        l2_norm = sqrt(sum(coords.^2))
        push!(l2_norms, l2_norm)
    end

    # Create summary statistics
    critical_points_count = nrow(df_coord)
    mean_l2_norm = mean(l2_norms)

    return DataFrame(
        degree = [degree],
        critical_points = [critical_points_count],
        l2_norm = [mean_l2_norm]
    )
end

"""
    validate_format_conversion(original_df::DataFrame, converted_df::DataFrame) -> (Bool, Vector{String})

Validate that format conversion preserved essential information.

# Validation Checks
- Row count preservation (coordinate points → summary count)
- L2 norm calculation accuracy
- No data loss during conversion

# Returns
- `Bool`: True if validation passes
- `Vector{String}`: List of validation warnings/errors
"""
function validate_format_conversion(original_df::DataFrame, converted_df::DataFrame)::Tuple{Bool, Vector{String}}
    warnings = String[]

    if nrow(original_df) == 0 && nrow(converted_df) == 0
        return true, warnings
    end

    if nrow(converted_df) != 1
        push!(warnings, "CONVERSION ERROR: Summary should contain exactly 1 row, got $(nrow(converted_df))")
        return false, warnings
    end

    # Validate critical points count
    expected_count = nrow(original_df)
    actual_count = converted_df[1, :critical_points]

    if expected_count != actual_count
        push!(warnings, "CONVERSION ERROR: Critical points count mismatch - expected $expected_count, got $actual_count")
        return false, warnings
    end

    # Validate L2 norm calculation
    if nrow(original_df) > 0
        # Recalculate L2 norm for validation
        manual_l2_norms = Float64[]
        for i in 1:nrow(original_df)
            coords = [original_df[i, :x1], original_df[i, :x2], original_df[i, :x3], original_df[i, :x4]]
            l2_norm = sqrt(sum(coords.^2))
            push!(manual_l2_norms, l2_norm)
        end

        expected_mean = mean(manual_l2_norms)
        actual_mean = converted_df[1, :l2_norm]

        if abs(expected_mean - actual_mean) > 1e-10
            push!(warnings, "CONVERSION WARNING: L2 norm calculation differs - expected $expected_mean, got $actual_mean")
        end
    end

    return true, warnings
end

"""
    adaptive_csv_read(file_path::String; target_format::CSVFormat = SUMMARY_FORMAT, degree::Union{Int, Nothing} = nothing, kwargs...) -> AdaptiveCSVResult

Intelligent CSV reading with automatic format detection and conversion.

This is the main function for adaptive collection pipeline - it automatically
detects CSV format and converts to target format if needed.

# Arguments
- `file_path::String`: Path to CSV file
- `target_format::CSVFormat = SUMMARY_FORMAT`: Desired output format
- `degree::Union{Int, Nothing} = nothing`: Polynomial degree for coordinate→summary conversion
- `kwargs...`: Additional options passed to defensive_csv_read

# Automatic Behavior
1. Uses DefensiveCSV for safe loading with error boundaries
2. Detects format of loaded CSV
3. Converts to target format if needed and possible
4. Validates conversion accuracy
5. Returns result with full metadata and warnings

# Conversion Logic
- COORDINATE_FORMAT → SUMMARY_FORMAT: Automatic with degree parameter
- SUMMARY_FORMAT → COORDINATE_FORMAT: Not supported (lossy conversion)
- UNKNOWN_FORMAT: No conversion attempted, returns original data

# Examples
```julia
# Basic adaptive reading (auto-converts to summary format)
result = adaptive_csv_read("critical_points_deg_6.csv", degree=6)
if result.success
    summary_df = result.data  # In summary format
    if result.conversion_applied
        println("Converted from \$(result.original_format) to \$(result.converted_format)")
    end
end

# Read coordinate format data without conversion
result = adaptive_csv_read("coords.csv", target_format=COORDINATE_FORMAT)
```
"""
function adaptive_csv_read(file_path::String;
                          target_format::CSVFormat = SUMMARY_FORMAT,
                          degree::Union{Int, Nothing} = nothing,
                          kwargs...)::AdaptiveCSVResult

    start_time = time()
    warnings = String[]
    metadata = Dict{String, Any}()

    try
        # Step 1: Use DefensiveCSV for safe loading
        defensive_result = defensive_csv_read(file_path; kwargs...)

        if !defensive_result.success
            return AdaptiveCSVResult(
                false, nothing, UNKNOWN_FORMAT, nothing,
                [defensive_result.error], defensive_result.error,
                basename(file_path), time() - start_time, false, metadata
            )
        end

        # Collect warnings from defensive loading
        append!(warnings, defensive_result.warnings)

        original_df = defensive_result.data
        metadata["original_rows"] = nrow(original_df)
        metadata["original_columns"] = ncol(original_df)
        metadata["original_column_names"] = names(original_df)

        # Step 2: Detect original format
        original_format = detect_csv_format(original_df)
        metadata["detected_format"] = string(original_format)

        # Step 3: Check if conversion is needed
        if original_format == target_format
            # No conversion needed
            load_time = time() - start_time
            return AdaptiveCSVResult(
                true, original_df, original_format, nothing,
                warnings, nothing, basename(file_path), load_time, false, metadata
            )
        end

        # Step 4: Attempt format conversion
        converted_df = nothing
        conversion_applied = false
        converted_format = nothing

        if original_format == COORDINATE_FORMAT && target_format == SUMMARY_FORMAT
            # Convert coordinate → summary
            if degree === nothing
                push!(warnings, "CONVERSION ERROR: degree parameter required for coordinate→summary conversion")
                return AdaptiveCSVResult(
                    false, nothing, original_format, nothing,
                    warnings, "Missing degree parameter for conversion",
                    basename(file_path), time() - start_time, false, metadata
                )
            end

            try
                converted_df = convert_coordinate_to_summary(original_df, degree)
                converted_format = SUMMARY_FORMAT
                conversion_applied = true

                # Validate conversion
                validation_ok, validation_warnings = validate_format_conversion(original_df, converted_df)
                append!(warnings, validation_warnings)

                if !validation_ok
                    return AdaptiveCSVResult(
                        false, nothing, original_format, converted_format,
                        warnings, "Format conversion validation failed",
                        basename(file_path), time() - start_time, false, metadata
                    )
                end

                metadata["conversion_applied"] = "COORDINATE_FORMAT → SUMMARY_FORMAT"
                metadata["converted_rows"] = nrow(converted_df)
                metadata["degree_used"] = degree

            catch e
                push!(warnings, "CONVERSION ERROR: Failed to convert coordinate→summary: $e")
                return AdaptiveCSVResult(
                    false, nothing, original_format, nothing,
                    warnings, "Coordinate→summary conversion failed: $e",
                    basename(file_path), time() - start_time, false, metadata
                )
            end

        elseif original_format == SUMMARY_FORMAT && target_format == COORDINATE_FORMAT
            # Summary → coordinate conversion not supported (lossy)
            push!(warnings, "CONVERSION ERROR: Summary→coordinate conversion not supported (would be lossy)")
            return AdaptiveCSVResult(
                false, nothing, original_format, nothing,
                warnings, "Summary→coordinate conversion not supported",
                basename(file_path), time() - start_time, false, metadata
            )

        elseif original_format == UNKNOWN_FORMAT
            # Unknown format - return as-is with warning
            push!(warnings, "FORMAT WARNING: Unknown CSV format detected, returning original data")
            load_time = time() - start_time
            return AdaptiveCSVResult(
                true, original_df, original_format, nothing,
                warnings, nothing, basename(file_path), load_time, false, metadata
            )
        else
            # Unsupported conversion
            push!(warnings, "CONVERSION ERROR: Unsupported format conversion from $original_format to $target_format")
            return AdaptiveCSVResult(
                false, nothing, original_format, nothing,
                warnings, "Unsupported format conversion",
                basename(file_path), time() - start_time, false, metadata
            )
        end

        # Step 5: Return successful result
        final_df = conversion_applied ? converted_df : original_df
        load_time = time() - start_time

        return AdaptiveCSVResult(
            true, final_df, original_format, converted_format,
            warnings, nothing, basename(file_path), load_time, conversion_applied, metadata
        )

    catch e
        load_time = time() - start_time
        return AdaptiveCSVResult(
            false, nothing, UNKNOWN_FORMAT, nothing,
            [string(e)], "Unexpected error during adaptive CSV loading: $e",
            basename(file_path), load_time, false, metadata
        )
    end
end

"""
    log_adaptive_result(result::AdaptiveCSVResult; level::String = "INFO")

Log the result of an adaptive CSV loading operation with format details.
"""
function log_adaptive_result(result::AdaptiveCSVResult; level::String = "INFO")
    if result.success
        format_info = if result.conversion_applied
            "$(result.original_format) → $(result.converted_format)"
        else
            string(result.original_format)
        end

        println("[$level] Adaptive CSV loaded $(result.file): $(nrow(result.data)) rows, $(ncol(result.data)) columns")
        println("[$level] Format: $format_info ($(round(result.load_time, digits=3))s)")

        if result.conversion_applied
            println("[$level] Conversion applied successfully")
        end

        if !isempty(result.warnings)
            for warning in result.warnings
                println("[WARN] $(result.file): $warning")
            end
        end
    else
        println("[ERROR] Adaptive CSV failed $(result.file): $(result.error) ($(round(result.load_time, digits=3))s)")
        if !isempty(result.warnings)
            for warning in result.warnings
                println("[WARN] $(result.file): $warning")
            end
        end
    end
end

"""
    get_adaptive_csv_summary(result::AdaptiveCSVResult) -> Dict{String, Any}

Get comprehensive summary of adaptive CSV loading result for logging/debugging.
"""
function get_adaptive_csv_summary(result::AdaptiveCSVResult)::Dict{String, Any}
    summary = Dict{String, Any}(
        "file" => result.file,
        "success" => result.success,
        "original_format" => string(result.original_format),
        "load_time" => result.load_time,
        "conversion_applied" => result.conversion_applied
    )

    if result.success
        summary["rows"] = nrow(result.data)
        summary["columns"] = ncol(result.data)
        summary["column_names"] = names(result.data)
    end

    if result.conversion_applied
        summary["converted_format"] = string(result.converted_format)
    end

    if !isempty(result.warnings)
        summary["warnings"] = result.warnings
    end

    if result.error !== nothing
        summary["error"] = result.error
    end

    merge!(summary, result.metadata)

    return summary
end

end # module AdaptiveFormatCSV