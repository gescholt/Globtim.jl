var documenterSearchIndex = {"docs":
[{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api_reference/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api_reference/#Problem-Setup","page":"API Reference","title":"Problem Setup","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"test_input - Create test input specification for optimization problems\nConstructor - Build polynomial approximation of objective function\nsolve_polynomial_system - Find critical points by solving ∇p(x) = 0\nprocess_crit_pts - Process and filter critical point solutions","category":"page"},{"location":"api_reference/#Analysis-Functions","page":"API Reference","title":"Analysis Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"analyze_critical_points - Comprehensive critical point analysis with BFGS refinement\nanalyze_critical_points_with_tables - Enhanced analysis with statistical tables","category":"page"},{"location":"api_reference/#Polynomial-Approximation","page":"API Reference","title":"Polynomial Approximation","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"chebyshev_extrema - Generate Chebyshev extrema points\nchebyshev_polys - Evaluate Chebyshev polynomials\ngrid_sample - Create sampling grid for polynomial fitting\nsample_objective_on_grid - Evaluate objective function on grid","category":"page"},{"location":"api_reference/#Critical-Point-Analysis","page":"API Reference","title":"Critical Point Analysis","text":"","category":"section"},{"location":"api_reference/#Core-Analysis","page":"API Reference","title":"Core Analysis","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"compute_hessians - Compute Hessian matrices at critical points\nclassify_critical_points - Classify points based on eigenvalues\nstore_all_eigenvalues - Store complete eigenvalue information\nextract_critical_eigenvalues - Extract key eigenvalues for minima/maxima","category":"page"},{"location":"api_reference/#Statistical-Measures","page":"API Reference","title":"Statistical Measures","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"compute_hessian_norms - Calculate Frobenius norms of Hessians\ncompute_eigenvalue_stats - Compute eigenvalue statistics\nanalyze_basins - Analyze basins of attraction","category":"page"},{"location":"api_reference/#BFGS-Refinement","page":"API Reference","title":"BFGS Refinement","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"enhanced_bfgs_refinement - Advanced BFGS with hyperparameter tracking\nrefine_with_enhanced_bfgs - Apply BFGS refinement to DataFrame\ndetermine_convergence_reason - Analyze optimization convergence","category":"page"},{"location":"api_reference/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api_reference/#Domain-Handling","page":"API Reference","title":"Domain Handling","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"points_in_hypercube - Check if points lie within domain\npoints_in_range - Filter points by function value range","category":"page"},{"location":"api_reference/#Spatial-Analysis","page":"API Reference","title":"Spatial Analysis","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"assign_spatial_regions - Assign region IDs for spatial statistics\ncluster_function_values - Cluster points by function values\ncompute_nearest_neighbors - Find nearest neighbor distances\ncompute_gradients - Compute gradient norms","category":"page"},{"location":"api_reference/#Visualization-Functions","page":"API Reference","title":"Visualization Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"Available when CairoMakie or GLMakie are loaded:","category":"page"},{"location":"api_reference/#Basic-Plots","page":"API Reference","title":"Basic Plots","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"plot_hessian_norms - Scatter plot of Hessian norms\nplot_condition_numbers - Log-scale condition number visualization\nplot_critical_eigenvalues - Critical eigenvalue validation plots","category":"page"},{"location":"api_reference/#Advanced-Visualizations","page":"API Reference","title":"Advanced Visualizations","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"plot_all_eigenvalues - Complete eigenvalue spectrum visualization\nplot_raw_vs_refined_eigenvalues - Compare eigenvalues before/after refinement","category":"page"},{"location":"api_reference/#Built-in-Test-Functions","page":"API Reference","title":"Built-in Test Functions","text":"","category":"section"},{"location":"api_reference/#2D-Functions","page":"API Reference","title":"2D Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"Deuflhard - Challenging function with multiple minima\nHolderTable - Four symmetric global minima\nAckley - Classic multimodal benchmark\ncamel - Six-hump camel function\nshubert - Highly multimodal function","category":"page"},{"location":"api_reference/#3D-Functions","page":"API Reference","title":"3D Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"tref_3d - Highly oscillatory 3D function","category":"page"},{"location":"api_reference/#n-Dimensional-Functions","page":"API Reference","title":"n-Dimensional Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"Rastringin - Classic multimodal benchmark (scalable)\nalpine1, alpine2 - Alpine functions\nCsendes - Smooth function with single minimum","category":"page"},{"location":"api_reference/#Export-Functions","page":"API Reference","title":"Export Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"write_tables_to_csv - Export tables to CSV format\nwrite_tables_to_latex - Export tables to LaTeX format\nwrite_tables_to_markdown - Export tables to Markdown format","category":"page"},{"location":"api_reference/#Types-and-Structures","page":"API Reference","title":"Types and Structures","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"test_input - Input specification type\nBFGSConfig - BFGS configuration parameters\nBFGSResult - BFGS optimization results\nApproxPoly - Polynomial approximation type","category":"page"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"For detailed function documentation with examples, use the Julia help system:","category":"page"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"julia> ?test_input\njulia> ?analyze_critical_points","category":"page"},{"location":"core_algorithm/#Core-Algorithm","page":"Core Algorithm","title":"Core Algorithm","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Globtim's approach to global optimization consists of three main phases:","category":"page"},{"location":"core_algorithm/#1.-Polynomial-Approximation","page":"Core Algorithm","title":"1. Polynomial Approximation","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The first step constructs a polynomial approximation of the objective function using discrete least squares.","category":"page"},{"location":"core_algorithm/#Sampling-Strategy","page":"Core Algorithm","title":"Sampling Strategy","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Globtim uses tensorized Chebyshev or Legendre grids for function sampling:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"# Create polynomial approximation\npol = Constructor(\n    TR,           # Test input specification\n    degree,       # Polynomial degree\n    \"chebyshev\"   # Basis type (default)\n)","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The sampling points are chosen to minimize approximation error and avoid Runge's phenomenon.","category":"page"},{"location":"core_algorithm/#Approximation-Quality","page":"Core Algorithm","title":"Approximation Quality","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The Constructor returns a polynomial with an L2-norm error estimate:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"pol = Constructor(TR, 8)\nprintln(\"Approximation error: \", pol.nrm)\n\n# Access polynomial coefficients\ncoeffs = pol.coeffs  # Coefficient matrix","category":"page"},{"location":"core_algorithm/#Basis-Functions","page":"Core Algorithm","title":"Basis Functions","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Two basis types are supported:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Chebyshev polynomials (default): Better for smooth functions\nLegendre polynomials: Alternative basis with different convergence properties","category":"page"},{"location":"core_algorithm/#2.-Critical-Point-Finding","page":"Core Algorithm","title":"2. Critical Point Finding","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Once we have a polynomial approximation, we find all its critical points by solving:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"∇p(x) = 0","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"where p(x) is our polynomial approximation.","category":"page"},{"location":"core_algorithm/#Polynomial-System-Setup","page":"Core Algorithm","title":"Polynomial System Setup","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"using DynamicPolynomials\n\n# Define polynomial variables\n@polyvar x[1:n_dims]\n\n# Solve the system\nsolutions = solve_polynomial_system(\n    x,          # Variables\n    n_dims,     # Dimension\n    degree,     # Polynomial degree\n    pol.coeffs  # Coefficients\n)","category":"page"},{"location":"core_algorithm/#Solver-Options","page":"Core Algorithm","title":"Solver Options","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Two solvers are available:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"HomotopyContinuation.jl (default): \nNumerical polynomial system solver\nFinds all complex solutions\nFilters for real solutions in domain\nMsolve (optional):\nExact symbolic solver\nRequires external installation\nUseful for verification","category":"page"},{"location":"core_algorithm/#Solution-Processing","page":"Core Algorithm","title":"Solution Processing","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Raw solutions are processed to extract valid critical points:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"df = process_crit_pts(\n    solutions,    # Raw solutions\n    f,           # Original function\n    TR,          # Domain specification\n    solver=\"HC\"  # Solver used\n)","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"This function:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Filters complex solutions\nChecks domain boundaries\nEvaluates function at each point\nRemoves duplicates","category":"page"},{"location":"core_algorithm/#3.-Refinement-and-Classification","page":"Core Algorithm","title":"3. Refinement and Classification","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The polynomial critical points are approximate. The final phase refines them using BFGS optimization.","category":"page"},{"location":"core_algorithm/#BFGS-Refinement","page":"Core Algorithm","title":"BFGS Refinement","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Each critical point is used as a starting point for local optimization:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"df_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    max_iters_in_optim=100,     # BFGS iterations\n    bfgs_g_tol=1e-8,           # Gradient tolerance\n    bfgs_f_abstol=1e-8,        # Function tolerance\n    tol_dist=0.025             # Clustering distance\n)","category":"page"},{"location":"core_algorithm/#Convergence-Tracking","page":"Core Algorithm","title":"Convergence Tracking","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The refinement process tracks:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Number of iterations required\nWhether optimization converged\nDistance from initial to refined point\nFunction value improvement","category":"page"},{"location":"core_algorithm/#Algorithm-Parameters","page":"Core Algorithm","title":"Algorithm Parameters","text":"","category":"section"},{"location":"core_algorithm/#Polynomial-Degree","page":"Core Algorithm","title":"Polynomial Degree","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Higher degrees improve approximation but increase cost:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Degree 4-6: Fast, suitable for smooth functions\nDegree 8-10: Good balance for most problems  \nDegree 12+: High accuracy, computationally intensive","category":"page"},{"location":"core_algorithm/#Domain-Scaling","page":"Core Algorithm","title":"Domain Scaling","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The sample_range parameter controls the search domain:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"# Symmetric domain\nTR = test_input(f, dim=2, center=[0,0], sample_range=1.0)\n\n# Asymmetric domain  \nTR = test_input(f, dim=2, center=[0,0], sample_range=[2.0, 1.0])","category":"page"},{"location":"core_algorithm/#Tolerance-Settings","page":"Core Algorithm","title":"Tolerance Settings","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Key tolerances affecting results:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"tol_dist: Distance for clustering critical points (default: 0.025)\nbfgs_g_tol: Gradient tolerance for refinement (default: 1e-8)\nhessian_tol_zero: Zero eigenvalue threshold (default: 1e-8)","category":"page"},{"location":"core_algorithm/#Performance-Considerations","page":"Core Algorithm","title":"Performance Considerations","text":"","category":"section"},{"location":"core_algorithm/#Computational-Complexity","page":"Core Algorithm","title":"Computational Complexity","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Polynomial construction: O(n^d) where n = sample points per dimension, d = dimension\nSystem solving: Depends on number of critical points (exponential in dimension)\nRefinement: O(k × m) where k = critical points, m = BFGS iterations","category":"page"},{"location":"core_algorithm/#Memory-Usage","page":"Core Algorithm","title":"Memory Usage","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Polynomial storage: O(d^n) coefficients\nSolution storage: Proportional to number of critical points\nHessian analysis: Additional O(n²) per critical point","category":"page"},{"location":"core_algorithm/#Scalability-Tips","page":"Core Algorithm","title":"Scalability Tips","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Start with lower polynomial degrees\nUse appropriate domain bounds\nEnable parallel processing where available\nConsider dimension-adaptive strategies for high dimensions","category":"page"},{"location":"critical_point_analysis/#Critical-Point-Analysis","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Version 1.1.0 introduces comprehensive Hessian-based analysis for classifying and validating critical points.","category":"page"},{"location":"critical_point_analysis/#Hessian-Based-Classification","page":"Critical Point Analysis","title":"Hessian-Based Classification","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"The analyze_critical_points function performs eigenvalue analysis to classify each critical point:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"df_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    enable_hessian=true,      # Enable classification\n    hessian_tol_zero=1e-8    # Zero eigenvalue tolerance\n)","category":"page"},{"location":"critical_point_analysis/#Classification-Types","page":"Critical Point Analysis","title":"Classification Types","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Critical points are classified based on Hessian eigenvalues:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":":minimum - All eigenvalues > hessian_tol_zero (positive definite)\n:maximum - All eigenvalues < -hessian_tol_zero (negative definite)\n:saddle - Mixed positive and negative eigenvalues\n:degenerate - At least one eigenvalue ≈ 0\n:error - Hessian computation failed","category":"page"},{"location":"critical_point_analysis/#Eigenvalue-Analysis","page":"Critical Point Analysis","title":"Eigenvalue Analysis","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"For each critical point, the following metrics are computed:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Key eigenvalue metrics\ndf_enhanced.hessian_eigenvalue_min      # Smallest eigenvalue\ndf_enhanced.hessian_eigenvalue_max      # Largest eigenvalue\ndf_enhanced.hessian_condition_number    # κ(H) = |λ_max|/|λ_min|\ndf_enhanced.hessian_determinant         # det(H)\ndf_enhanced.hessian_trace              # tr(H)\ndf_enhanced.hessian_norm               # ||H||_F (Frobenius norm)","category":"page"},{"location":"critical_point_analysis/#Special-Eigenvalues","page":"Critical Point Analysis","title":"Special Eigenvalues","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"For minima and maxima validation:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# For minima: smallest positive eigenvalue\ndf_enhanced.smallest_positive_eigenval\n\n# For maxima: largest negative eigenvalue  \ndf_enhanced.largest_negative_eigenval","category":"page"},{"location":"critical_point_analysis/#Enhanced-Statistics","page":"Critical Point Analysis","title":"Enhanced Statistics","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Beyond Hessian analysis, additional statistics are computed:","category":"page"},{"location":"critical_point_analysis/#Spatial-Analysis","page":"Critical Point Analysis","title":"Spatial Analysis","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Spatial clustering\ndf_enhanced.region_id                   # Spatial region assignment\ndf_enhanced.nearest_neighbor_dist       # Distance to nearest critical point\n\n# Function value clustering\ndf_enhanced.function_value_cluster      # Similar function values","category":"page"},{"location":"critical_point_analysis/#Convergence-Quality","page":"Critical Point Analysis","title":"Convergence Quality","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Refinement metrics\ndf_enhanced.gradient_norm              # ||∇f|| at critical point\ndf_enhanced.steps                      # BFGS iterations used\ndf_enhanced.converged                  # Convergence success\ndf_enhanced.point_improvement          # ||x_refined - x_initial||\ndf_enhanced.value_improvement          # |f(x_refined) - f(x_initial)|","category":"page"},{"location":"critical_point_analysis/#Basin-Analysis","page":"Critical Point Analysis","title":"Basin Analysis","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"For the unique minimizers in df_min:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Basin of attraction statistics\ndf_min.basin_points                    # Number of converging points\ndf_min.average_convergence_steps       # Mean BFGS iterations\ndf_min.region_coverage_count          # Spatial regions covered\ndf_min.gradient_norm_at_min          # Gradient verification","category":"page"},{"location":"critical_point_analysis/#Statistical-Tables","page":"Critical Point Analysis","title":"Statistical Tables","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Generate comprehensive reports with:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"df_enhanced, df_min, tables, stats = analyze_critical_points_with_tables(\n    f, df, TR,\n    enable_hessian=true,\n    show_tables=true,\n    table_types=[:minimum, :saddle, :maximum]\n)","category":"page"},{"location":"critical_point_analysis/#Table-Contents","page":"Critical Point Analysis","title":"Table Contents","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Each table includes:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Point coordinates and function values\nEigenvalue statistics\nCondition numbers\nConvergence metrics\nDistance measurements","category":"page"},{"location":"critical_point_analysis/#Export-Options","page":"Critical Point Analysis","title":"Export Options","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Export to different formats\nwrite_tables_to_csv(tables, \"results.csv\")\nwrite_tables_to_latex(tables, \"results.tex\")\nwrite_tables_to_markdown(tables, \"results.md\")","category":"page"},{"location":"critical_point_analysis/#Advanced-Options","page":"Critical Point Analysis","title":"Advanced Options","text":"","category":"section"},{"location":"critical_point_analysis/#Custom-Tolerances","page":"Critical Point Analysis","title":"Custom Tolerances","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Fine-tune the analysis with specific tolerances:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"df_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    tol_dist=0.01,              # Tighter clustering\n    bfgs_g_tol=1e-10,          # Higher precision\n    bfgs_f_abstol=1e-12,       # Function tolerance\n    hessian_tol_zero=1e-10     # Eigenvalue threshold\n)","category":"page"},{"location":"critical_point_analysis/#Performance-Mode","page":"Critical Point Analysis","title":"Performance Mode","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"For large problems, disable Hessian analysis:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Basic analysis only (faster)\ndf_basic, df_min = analyze_critical_points(\n    f, df, TR,\n    enable_hessian=false  # Skip eigenvalue computation\n)","category":"page"},{"location":"critical_point_analysis/#Verbose-Output","page":"Critical Point Analysis","title":"Verbose Output","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Track progress with detailed output:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"df_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    verbose=true  # Show progress messages\n)","category":"page"},{"location":"critical_point_analysis/#Interpreting-Results","page":"Critical Point Analysis","title":"Interpreting Results","text":"","category":"section"},{"location":"critical_point_analysis/#Quality-Indicators","page":"Critical Point Analysis","title":"Quality Indicators","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Good critical points typically have:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"gradient_norm < 1e-6\nconverged = true\nhessian_condition_number < 1e6\nConsistent classification between raw and refined points","category":"page"},{"location":"critical_point_analysis/#Warning-Signs","page":"Critical Point Analysis","title":"Warning Signs","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Potential issues indicated by:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Large point_improvement values (poor initial approximation)\ndegenerate classification (numerical instability)\nHigh condition numbers (ill-conditioned Hessian)\nFailed convergence within domain","category":"page"},{"location":"critical_point_analysis/#Basin-Structure","page":"Critical Point Analysis","title":"Basin Structure","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"The df_min DataFrame reveals the optimization landscape:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Large basin_points: Strong attractor\nHigh region_coverage_count: Wide basin\nLow average_convergence_steps: Smooth basin","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide walks you through the basic usage of Globtim.jl for finding all local minima of continuous functions.","category":"page"},{"location":"getting_started/#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The typical Globtim workflow consists of three main steps:","category":"page"},{"location":"getting_started/#1.-Define-the-Problem","page":"Getting Started","title":"1. Define the Problem","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Globtim, DynamicPolynomials, DataFrames\n\n# Use a built-in test function\nf = Deuflhard  \n\n# Or define your own\nf(x) = x[1]^2 + sin(5*x[1]) + x[2]^2 + sin(5*x[2])\n\n# Create test input specification\nTR = test_input(\n    f,                    # Objective function\n    dim=2,               # Dimension\n    center=[0.0, 0.0],   # Domain center\n    sample_range=1.2     # Domain radius\n)","category":"page"},{"location":"getting_started/#2.-Find-Critical-Points","page":"Getting Started","title":"2. Find Critical Points","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create polynomial approximation\npol = Constructor(TR, 8)  # Degree 8 polynomial\nprintln(\"L2-norm approximation error: \", pol.nrm)\n\n# Set up polynomial variables\n@polyvar x[1:2]\n\n# Solve polynomial system for critical points\nsolutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\n\n# Process solutions\ndf = process_crit_pts(solutions, f, TR)\nprintln(\"Found $(nrow(df)) critical points\")","category":"page"},{"location":"getting_started/#3.-Refine-and-Classify","page":"Getting Started","title":"3. Refine and Classify","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Enhanced analysis with Hessian classification\ndf_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    enable_hessian=true,      # Enable eigenvalue analysis\n    verbose=true,             # Show progress\n    tol_dist=0.025           # Clustering tolerance\n)\n\nprintln(\"Found $(nrow(df_min)) unique local minima\")\n\n# Check classifications\nprintln(\"Critical point types:\")\nfor type in unique(df_enhanced.critical_point_type)\n    count = sum(df_enhanced.critical_point_type .== type)\n    println(\"  $type: $count points\")\nend","category":"page"},{"location":"getting_started/#Domain-Specification","page":"Getting Started","title":"Domain Specification","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Globtim supports both uniform and non-uniform domain scaling:","category":"page"},{"location":"getting_started/#Uniform-Scaling","page":"Getting Started","title":"Uniform Scaling","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Square/cube domain\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=1.0)\n# Domain: [-1, 1] × [-1, 1]","category":"page"},{"location":"getting_started/#Non-uniform-Scaling","page":"Getting Started","title":"Non-uniform Scaling","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Rectangular domain\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=[2.0, 1.0])\n# Domain: [-2, 2] × [-1, 1]","category":"page"},{"location":"getting_started/#Polynomial-Degree-Selection","page":"Getting Started","title":"Polynomial Degree Selection","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Higher polynomial degrees provide better approximation but increase computational cost:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Compare different degrees\nfor degree in [4, 6, 8, 10]\n    pol = Constructor(TR, degree)\n    println(\"Degree $degree: L2-norm error = $(pol.nrm)\")\nend","category":"page"},{"location":"getting_started/#Built-in-Test-Functions","page":"Getting Started","title":"Built-in Test Functions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Globtim includes several standard test functions:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Deuflhard - Challenging 2D function with multiple minima\nRastringin - Classic multimodal benchmark\nHolderTable - 2D function with 4 global minima\ntref_3d - 3D test function\nBeale, Rosenbrock, Branin - Standard optimization benchmarks","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Example:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Test on Rastringin function\nf = Rastringin\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=5.12)\n# ... continue with standard workflow","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"See Core Algorithm for details on the polynomial approximation method\nSee Critical Point Analysis for advanced refinement options\nSee Examples for complete working examples\nSee API Reference for detailed function documentation","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page provides complete working examples demonstrating various features of Globtim.jl.","category":"page"},{"location":"examples/#Example-1:-Basic-Usage","page":"Examples","title":"Example 1: Basic Usage","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finding all minima of the Deuflhard function:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Globtim, DynamicPolynomials, DataFrames\n\n# Define the problem\nf = Deuflhard\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=1.2)\n\n# Polynomial approximation\npol = Constructor(TR, 8)\nprintln(\"Approximation error: \", pol.nrm)\n\n# Find critical points\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\ndf = process_crit_pts(solutions, f, TR)\n\n# Refine and classify\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)\n\n# Display results\nprintln(\"\\\\nUnique minima found:\")\nfor i in 1:nrow(df_min)\n    x1, x2 = df_min[i, :x1], df_min[i, :x2]\n    val = df_min[i, :value]\n    println(\"  Minimum $i: ($x1, $x2) with f = $val\")\nend","category":"page"},{"location":"examples/#Example-2:-Custom-Function","page":"Examples","title":"Example 2: Custom Function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Optimizing a user-defined function:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Define custom objective\nfunction my_function(x)\n    return (x[1]^2 - 1)^2 + (x[2]^2 - 1)^2 + 0.1*sin(10*x[1]*x[2])\nend\n\n# Set up problem\nTR = test_input(my_function, dim=2, center=[0.0, 0.0], sample_range=2.0)\n\n# Higher degree for complex function\npol = Constructor(TR, 10)\n\n# Standard workflow\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, 2, 10, pol.coeffs)\ndf = process_crit_pts(solutions, my_function, TR)\ndf_enhanced, df_min = analyze_critical_points(my_function, df, TR)\n\n# Analyze critical point types\ntypes = unique(df_enhanced.critical_point_type)\nfor t in types\n    count = sum(df_enhanced.critical_point_type .== t)\n    println(\"$t: $count points\")\nend","category":"page"},{"location":"examples/#Example-3:-Statistical-Analysis","page":"Examples","title":"Example 3: Statistical Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Generating comprehensive reports:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Run analysis with tables\ndf_enhanced, df_min, tables, stats = analyze_critical_points_with_tables(\n    f, df, TR,\n    enable_hessian=true,\n    show_tables=true,\n    table_types=[:minimum, :saddle, :maximum]\n)\n\n# Access statistics\nprintln(\"\\\\nStatistical Summary:\")\nprintln(\"Average condition number: \", mean(df_enhanced.hessian_condition_number))\nprintln(\"Max gradient norm: \", maximum(df_enhanced.gradient_norm))\nprintln(\"Convergence rate: \", sum(df_enhanced.converged) / nrow(df_enhanced))\n\n# Export results\nwrite_tables_to_csv(tables, \"deuflhard_results.csv\")\nwrite_tables_to_markdown(tables, \"deuflhard_results.md\")","category":"page"},{"location":"examples/#Example-4:-High-Dimensional-Problem","page":"Examples","title":"Example 4: High-Dimensional Problem","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Handling higher dimensions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# 3D Rastringin function\nf = Rastringin\nTR = test_input(f, dim=3, center=[0.0, 0.0, 0.0], sample_range=5.12)\n\n# Use moderate degree for 3D\npol = Constructor(TR, 6)\n\n# Find critical points\n@polyvar x[1:3]\nsolutions = solve_polynomial_system(x, 3, 6, pol.coeffs)\ndf = process_crit_pts(solutions, f, TR)\n\n# Refine without Hessian for speed\ndf_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    enable_hessian=false,  # Faster for high dimensions\n    verbose=true\n)\n\nprintln(\"Found $(nrow(df_min)) local minima in 3D\")","category":"page"},{"location":"examples/#Example-5:-Domain-Exploration","page":"Examples","title":"Example 5: Domain Exploration","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Testing different domain sizes:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"f = HolderTable  # Has 4 global minima\n\n# Try different domain sizes\nfor r in [8.0, 10.0, 12.0]\n    TR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=r)\n    pol = Constructor(TR, 8)\n    \n    @polyvar x[1:2]\n    solutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\n    df = process_crit_pts(solutions, f, TR)\n    df_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=false)\n    \n    println(\"Domain ±$r: found $(nrow(df_min)) minima\")\nend","category":"page"},{"location":"examples/#Example-6:-Visualization","page":"Examples","title":"Example 6: Visualization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Creating plots (requires CairoMakie):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using CairoMakie\n\n# Run standard analysis\nf = Deuflhard\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=1.2)\npol = Constructor(TR, 8)\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\ndf = process_crit_pts(solutions, f, TR)\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)\n\n# Create visualizations\nfig1 = plot_hessian_norms(df_enhanced)\nsave(\"hessian_norms.png\", fig1)\n\nfig2 = plot_condition_numbers(df_enhanced)\nsave(\"condition_numbers.png\", fig2)\n\nfig3 = plot_critical_eigenvalues(df_enhanced)\nsave(\"critical_eigenvalues.png\", fig3)\n\nfig4 = plot_all_eigenvalues(f, df_enhanced, sort_by=:magnitude)\nsave(\"all_eigenvalues.png\", fig4)","category":"page"},{"location":"examples/#Example-7:-Comparing-Polynomial-Degrees","page":"Examples","title":"Example 7: Comparing Polynomial Degrees","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Analyzing approximation quality:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"f = Branin\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=15.0)\n\nresults = DataFrame(\n    degree = Int[],\n    l2_error = Float64[],\n    n_critical = Int[],\n    n_minima = Int[]\n)\n\nfor deg in [4, 6, 8, 10]\n    pol = Constructor(TR, deg)\n    @polyvar x[1:2]\n    solutions = solve_polynomial_system(x, 2, deg, pol.coeffs)\n    df = process_crit_pts(solutions, f, TR)\n    df_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=false)\n    \n    push!(results, (deg, pol.nrm, nrow(df), nrow(df_min)))\nend\n\nprintln(results)","category":"page"},{"location":"examples/#Example-8:-Basin-Analysis","page":"Examples","title":"Example 8: Basin Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Understanding convergence basins:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Function with interesting basin structure\nf(x) = (x[1]^2 + x[2]^2 - 1)^2 + 0.1*(x[1]^2 + x[2]^2)\n\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=2.0)\npol = Constructor(TR, 8)\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\ndf = process_crit_pts(solutions, f, TR)\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)\n\n# Analyze basins\nprintln(\"\\\\nBasin Analysis:\")\nfor i in 1:nrow(df_min)\n    basin_size = df_min[i, :basin_points]\n    avg_steps = df_min[i, :average_convergence_steps]\n    coverage = df_min[i, :region_coverage_count]\n    \n    println(\"Minimum $i:\")\n    println(\"  Basin size: $basin_size points\")\n    println(\"  Average convergence: $avg_steps steps\")\n    println(\"  Spatial coverage: $coverage regions\")\nend","category":"page"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Globtim provides comprehensive visualization capabilities through extension packages. These functions become available when you load CairoMakie or GLMakie.","category":"page"},{"location":"visualization/#Setup","page":"Visualization","title":"Setup","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using Globtim\nusing CairoMakie  # or GLMakie for interactive plots\n\n# Run your analysis first\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)","category":"page"},{"location":"visualization/#Hessian-Analysis-Plots","page":"Visualization","title":"Hessian Analysis Plots","text":"","category":"section"},{"location":"visualization/#Hessian-Norms","page":"Visualization","title":"Hessian Norms","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Visualize the Frobenius norm of Hessian matrices:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = plot_hessian_norms(df_enhanced)\nsave(\"hessian_norms.png\", fig)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This scatter plot shows ||H||_F for each critical point, colored by type (minimum, maximum, saddle).","category":"page"},{"location":"visualization/#Condition-Numbers","page":"Visualization","title":"Condition Numbers","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Analyze numerical stability:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = plot_condition_numbers(df_enhanced)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Displays log-scale condition numbers κ(H) = |λmax|/|λmin|. High values indicate potential numerical issues.","category":"page"},{"location":"visualization/#Critical-Eigenvalues","page":"Visualization","title":"Critical Eigenvalues","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Validate minima and maxima:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = plot_critical_eigenvalues(df_enhanced)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Shows:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Left: Smallest positive eigenvalues for minima\nRight: Largest negative eigenvalues for maxima","category":"page"},{"location":"visualization/#Eigenvalue-Spectrum-Plots","page":"Visualization","title":"Eigenvalue Spectrum Plots","text":"","category":"section"},{"location":"visualization/#All-Eigenvalues","page":"Visualization","title":"All Eigenvalues","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Comprehensive eigenvalue visualization:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# Sort by magnitude (preserves signs)\nfig1 = plot_all_eigenvalues(f, df_enhanced, sort_by=:magnitude)\n\n# Sort by absolute value\nfig2 = plot_all_eigenvalues(f, df_enhanced, sort_by=:abs_magnitude)\n\n# Sort by eigenvalue spread\nfig3 = plot_all_eigenvalues(f, df_enhanced, sort_by=:spread)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Features:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Separate subplots for each critical point type\nVertical alignment with dotted connections\nColor coding by point index","category":"page"},{"location":"visualization/#Raw-vs-Refined-Comparison","page":"Visualization","title":"Raw vs Refined Comparison","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Compare eigenvalues before and after BFGS refinement:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# Default: ordered by point distance\nfig = plot_raw_vs_refined_eigenvalues(f, df_raw, df_enhanced)\n\n# Order by function value difference\nfig = plot_raw_vs_refined_eigenvalues(f, df_raw, df_enhanced, \n                                     sort_by=:function_value_diff)\n\n# Order by eigenvalue norm difference\nfig = plot_raw_vs_refined_eigenvalues(f, df_raw, df_enhanced,\n                                     sort_by=:eigenvalue_diff)","category":"page"},{"location":"visualization/#Customization-Options","page":"Visualization","title":"Customization Options","text":"","category":"section"},{"location":"visualization/#Color-Schemes","page":"Visualization","title":"Color Schemes","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"All plots support custom color schemes:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = plot_hessian_norms(df_enhanced, \n    colors=Dict(\n        :minimum => :blue,\n        :maximum => :red,\n        :saddle => :green,\n        :degenerate => :orange\n    )\n)","category":"page"},{"location":"visualization/#Figure-Properties","page":"Visualization","title":"Figure Properties","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Adjust figure size and resolution:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = plot_condition_numbers(df_enhanced,\n    size=(800, 600),\n    fontsize=14,\n    markersize=10\n)","category":"page"},{"location":"visualization/#Saving-Plots","page":"Visualization","title":"Saving Plots","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Export in various formats:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# High-resolution PNG\nsave(\"plot.png\", fig, px_per_unit=2)\n\n# Vector format\nsave(\"plot.pdf\", fig)\nsave(\"plot.svg\", fig)","category":"page"},{"location":"visualization/#Interactive-Features-(GLMakie)","page":"Visualization","title":"Interactive Features (GLMakie)","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"When using GLMakie, plots become interactive:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using GLMakie\n\nfig = plot_all_eigenvalues(f, df_enhanced)\n# - Zoom with mouse wheel\n# - Pan by dragging\n# - Reset with double-click","category":"page"},{"location":"visualization/#Combined-Visualizations","page":"Visualization","title":"Combined Visualizations","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Create multi-panel figures:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = Figure(resolution=(1200, 800))\n\n# Hessian norms\nax1 = Axis(fig[1, 1], title=\"Hessian Norms\")\nplot_hessian_norms!(ax1, df_enhanced)\n\n# Condition numbers\nax2 = Axis(fig[1, 2], title=\"Condition Numbers\")\nplot_condition_numbers!(ax2, df_enhanced)\n\n# Critical eigenvalues\nax3 = Axis(fig[2, 1:2], title=\"Critical Eigenvalues\")\nplot_critical_eigenvalues!(ax3, df_enhanced)\n\nsave(\"combined_analysis.png\", fig)","category":"page"},{"location":"visualization/#Plotting-Tips","page":"Visualization","title":"Plotting Tips","text":"","category":"section"},{"location":"visualization/#Large-Datasets","page":"Visualization","title":"Large Datasets","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"For many critical points:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# Filter to specific types\ndf_minima = filter(row -> row.critical_point_type == :minimum, df_enhanced)\nfig = plot_hessian_norms(df_minima)","category":"page"},{"location":"visualization/#Publication-Quality","page":"Visualization","title":"Publication Quality","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# Set theme for publication\nset_theme!(\n    fontsize=16,\n    resolution=(800, 600),\n    Axis=(\n        spinewidth=1.5,\n        xgridwidth=0.5,\n        ygridwidth=0.5\n    )\n)\n\nfig = plot_condition_numbers(df_enhanced)\nsave(\"publication_figure.pdf\", fig)\n\n# Reset theme\nset_theme!()","category":"page"},{"location":"visualization/#Animation-(GLMakie)","page":"Visualization","title":"Animation (GLMakie)","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Create animations showing eigenvalue evolution:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using GLMakie\n\n# Animate eigenvalue changes\npoints = Observable(1:10)\nfig = Figure()\nax = Axis(fig[1, 1])\n\non(points) do range\n    # Update plot based on point range\n    # ... plotting code ...\nend\n\n# Create animation\nrecord(fig, \"eigenvalue_evolution.mp4\", 1:nrow(df_enhanced)) do i\n    points[] = 1:i\nend","category":"page"},{"location":"#Globtim.jl-Documentation","page":"Home","title":"Globtim.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Run Tests) (Image: Julia 1.11) (Image: License: GPL v3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Global optimization of continuous functions via polynomial approximation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Globtim finds all local minima of continuous functions over compact domains using Chebyshev/Legendre polynomial approximation and critical point analysis.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Globtim.jl provides a comprehensive framework for global optimization through:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Polynomial Approximation: High-accuracy approximation using Chebyshev/Legendre polynomials\nCritical Point Finding: Systematic identification of all stationary points\nHessian Analysis: Classification and validation of critical points\nStatistical Assessment: Quality metrics and convergence analysis","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add Globtim","category":"page"},{"location":"#Optional-Dependencies","page":"Home","title":"Optional Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For visualization: add CairoMakie or add GLMakie\nFor exact solving: Install Msolve","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Globtim, DynamicPolynomials, DataFrames\n\n# Define problem\nf = Deuflhard  # Built-in test function\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=1.2)\n\n# Step 1: Polynomial approximation\npol = Constructor(TR, 8)  # Degree 8 approximation\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\ndf = process_crit_pts(solutions, f, TR)\n\n# Step 2: Enhanced analysis\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting_started.md\", \"core_algorithm.md\", \"critical_point_analysis.md\", \"api_reference.md\", \"examples.md\", \"visualization.md\"]\nDepth = 2","category":"page"}]
}
