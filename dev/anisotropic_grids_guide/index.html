<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Anisotropic Grids · Globtim.jl Documentation</title><meta name="title" content="Anisotropic Grids · Globtim.jl Documentation"/><meta property="og:title" content="Anisotropic Grids · Globtim.jl Documentation"/><meta property="twitter:title" content="Anisotropic Grids · Globtim.jl Documentation"/><meta name="description" content="Documentation for Globtim.jl Documentation."/><meta property="og:description" content="Documentation for Globtim.jl Documentation."/><meta property="twitter:description" content="Documentation for Globtim.jl Documentation."/><meta property="og:url" content="https://gescholt.github.io/Globtim.jl/dev/anisotropic_grids_guide/"/><meta property="twitter:url" content="https://gescholt.github.io/Globtim.jl/dev/anisotropic_grids_guide/"/><link rel="canonical" href="https://gescholt.github.io/Globtim.jl/dev/anisotropic_grids_guide/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Globtim.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../core_algorithm/">Core Algorithm</a></li><li><a class="tocitem" href="../polynomial_approximation/">Polynomial Approximation</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../critical_point_analysis/">Critical Point Analysis</a></li><li class="is-active"><a class="tocitem" href>Anisotropic Grids</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Why-Use-Anisotropic-Grids?"><span>Why Use Anisotropic Grids?</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Practical-Examples"><span>Practical Examples</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li><li><a class="tocitem" href="#Advanced-Topics"><span>Advanced Topics</span></a></li><li><a class="tocitem" href="#Common-Pitfalls"><span>Common Pitfalls</span></a></li><li><a class="tocitem" href="#Performance-Tips"><span>Performance Tips</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../sparsification/">Sparsification</a></li><li><a class="tocitem" href="../exact_conversion/">Exact Conversion</a></li><li><a class="tocitem" href="../grid_formats/">Grid Formats</a></li><li><a class="tocitem" href="../precision_parameters/">Precision</a></li><li><span class="tocitem">Testing</span><ul><li><a class="tocitem" href="../test_documentation/">Test Documentation</a></li><li><a class="tocitem" href="../test_running_guide/">Test Running Guide</a></li><li><a class="tocitem" href="../anisotropic_grid_tests/">Anisotropic Grid Tests</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../visualization/">Visualization</a></li><li><a class="tocitem" href="../globtimplots/">GlobtimPlots</a></li><li><a class="tocitem" href="../api_reference/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Anisotropic Grids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Anisotropic Grids</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gescholt/Globtim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="github.com/gescholt/Globtim.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Anisotropic-Grids-User-Guide"><a class="docs-heading-anchor" href="#Anisotropic-Grids-User-Guide">Anisotropic Grids User Guide</a><a id="Anisotropic-Grids-User-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Anisotropic-Grids-User-Guide" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Anisotropic grids allow you to use different numbers of quadrature points in each dimension, enabling more efficient approximation of functions that vary at different rates along different axes. This guide explains how to use anisotropic grids in Globtim.</p><h2 id="Why-Use-Anisotropic-Grids?"><a class="docs-heading-anchor" href="#Why-Use-Anisotropic-Grids?">Why Use Anisotropic Grids?</a><a id="Why-Use-Anisotropic-Grids?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Use-Anisotropic-Grids?" title="Permalink"></a></h2><p>Consider approximating a function like <code>f(x,y) = exp(-100x² - y²)</code>. This function:</p><ul><li>Changes rapidly in the x-direction (due to the factor 100)</li><li>Changes slowly in the y-direction</li></ul><p>Using an isotropic grid wastes computational resources by placing unnecessary points in the y-direction. An anisotropic grid can achieve the same accuracy with fewer total points by allocating more points where the function varies rapidly.</p><p><img src="../assets/plots/grid_comparison.png" alt="Isotropic vs Anisotropic Grid Comparison"/></p><p><em>Both grids use 64 points, but the anisotropic grid allocates more points in the x-direction where higher resolution is needed.</em></p><p><img src="../assets/plots/multiscale_function.png" alt="Multiscale Function Example"/></p><p><em>A multiscale function with rapid oscillation in x and slow variation in y. This function benefits significantly from anisotropic sampling.</em></p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><h3 id="Generating-Anisotropic-Grids"><a class="docs-heading-anchor" href="#Generating-Anisotropic-Grids">Generating Anisotropic Grids</a><a id="Generating-Anisotropic-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Anisotropic-Grids" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Globtim

# Create a 2D anisotropic grid with 20 points in x, 10 in y
grid = generate_anisotropic_grid([19, 9], basis=:chebyshev)
# Results in a 20×10 grid (input n gives n+1 points)

# 3D anisotropic grid
grid_3d = generate_anisotropic_grid([30, 20, 10], basis=:legendre)
# Results in a 31×21×11 grid

# High-dimensional grids work the same way
grid_5d = generate_anisotropic_grid([10, 8, 6, 4, 2], basis=:uniform)</code></pre><h3 id="Available-Basis-Types"><a class="docs-heading-anchor" href="#Available-Basis-Types">Available Basis Types</a><a id="Available-Basis-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Basis-Types" title="Permalink"></a></h3><ul><li><strong><code>:chebyshev</code></strong> - Chebyshev nodes (default), cluster at boundaries</li><li><strong><code>:legendre</code></strong> - Uniform spacing (Legendre-Gauss-Lobatto nodes)  </li><li><strong><code>:uniform</code></strong> - True uniform spacing including endpoints</li></ul><h3 id="Computing-L-Norms"><a class="docs-heading-anchor" href="#Computing-L-Norms">Computing L² Norms</a><a id="Computing-L-Norms-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-L-Norms" title="Permalink"></a></h3><p>Anisotropic grids work seamlessly with both L²-norm computation methods:</p><pre><code class="language-julia hljs"># Define a test function
f = x -&gt; exp(-50*x[1]^2 - 2*x[2]^2)

# Method 1: Quadrature-based (more accurate)
l2_quad = compute_l2_norm_quadrature(f, [40, 15], :chebyshev)

# Method 2: Riemann sum (works with pre-generated grids)
grid = generate_anisotropic_grid([40, 15], basis=:chebyshev)
l2_riemann = discrete_l2_norm_riemann(f, grid)</code></pre><h2 id="Practical-Examples"><a class="docs-heading-anchor" href="#Practical-Examples">Practical Examples</a><a id="Practical-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-Examples" title="Permalink"></a></h2><h3 id="Example-1:-Multiscale-Function"><a class="docs-heading-anchor" href="#Example-1:-Multiscale-Function">Example 1: Multiscale Function</a><a id="Example-1:-Multiscale-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Multiscale-Function" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Function with different scales
f_multiscale = x -&gt; sin(20*x[1]) * exp(-x[2]^2)

# Poor choice: isotropic grid
l2_iso = compute_l2_norm_quadrature(f_multiscale, [25, 25], :chebyshev)
# Uses 26×26 = 676 points

# Better choice: anisotropic grid
l2_aniso = compute_l2_norm_quadrature(f_multiscale, [40, 15], :chebyshev)
# Uses 41×16 = 656 points, but more accurate!</code></pre><h3 id="Example-2:-Choosing-Grid-Sizes"><a class="docs-heading-anchor" href="#Example-2:-Choosing-Grid-Sizes">Example 2: Choosing Grid Sizes</a><a id="Example-2:-Choosing-Grid-Sizes-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Choosing-Grid-Sizes" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Function that varies as exp(-a₁x₁² - a₂x₂² - ... - aₙxₙ²)
# Rule of thumb: grid_size[i] ∝ √(a[i])

# For f(x,y,z) = exp(-100x² - 25y² - 4z²)
# Relative scales: √100:√25:√4 = 10:5:2
grid_sizes = [40, 20, 8]  # Proportional allocation

l2 = compute_l2_norm_quadrature(
    x -&gt; exp(-100*x[1]^2 - 25*x[2]^2 - 4*x[3]^2),
    grid_sizes,
    :chebyshev
)</code></pre><h3 id="Example-3:-Performance-Comparison"><a class="docs-heading-anchor" href="#Example-3:-Performance-Comparison">Example 3: Performance Comparison</a><a id="Example-3:-Performance-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Performance-Comparison" title="Permalink"></a></h3><pre><code class="language-julia hljs">using BenchmarkTools

f = x -&gt; exp(-50*x[1]^2 - 2*x[2]^2)

# Reference value
l2_ref = compute_l2_norm_quadrature(f, [200, 200], :chebyshev)

# Compare different strategies
configs = [
    ([30, 30], &quot;Isotropic 30×30&quot;),
    ([50, 18], &quot;Anisotropic 50×18&quot;),
    ([60, 15], &quot;Anisotropic 60×15&quot;)
]

for (grid_size, name) in configs
    l2 = compute_l2_norm_quadrature(f, grid_size, :chebyshev)
    error = abs(l2 - l2_ref)
    total = prod(grid_size .+ 1)
    println(&quot;$name ($total points): error = $error&quot;)
end</code></pre><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><h3 id="Checking-Grid-Properties"><a class="docs-heading-anchor" href="#Checking-Grid-Properties">Checking Grid Properties</a><a id="Checking-Grid-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-Grid-Properties" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Get dimensions of an existing grid
grid = generate_anisotropic_grid([10, 20, 30])
dims = get_grid_dimensions(grid)  # Returns [11, 21, 31]

# Check if a grid is anisotropic
is_aniso = is_anisotropic(grid)  # Returns true</code></pre><h3 id="Backward-Compatibility"><a class="docs-heading-anchor" href="#Backward-Compatibility">Backward Compatibility</a><a id="Backward-Compatibility-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-Compatibility" title="Permalink"></a></h3><p>The old isotropic interface still works:</p><pre><code class="language-julia hljs"># Old way (isotropic)
grid_iso = generate_grid(2, 20, basis=:chebyshev)  # 2D, 21×21 grid

# Equivalent anisotropic call
grid_aniso = generate_anisotropic_grid([20, 20], basis=:chebyshev)

# These produce identical grids
@assert grid_iso == grid_aniso</code></pre><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><ol><li><p><strong>Analyze your function first</strong>: Understand where it varies rapidly</p><pre><code class="language-julia hljs"># Quick visual check in 2D
f = x -&gt; your_function(x)
x = range(-1, 1, 100)
y = range(-1, 1, 100)
z = [f([xi, yi]) for xi in x, yi in y]
heatmap(x, y, z)  # Look for directional variation</code></pre></li><li><p><strong>Start with moderate anisotropy</strong>: Begin with ratios like 2:1 or 3:1</p><pre><code class="language-julia hljs"># Conservative start
grid_sizes = [30, 15]  # 2:1 ratio

# More aggressive if function supports it
grid_sizes = [50, 10]  # 5:1 ratio</code></pre></li><li><p><strong>Validate your choice</strong>: Compare with high-resolution reference</p><pre><code class="language-julia hljs">l2_ref = compute_l2_norm_quadrature(f, [100, 100], :chebyshev)
l2_test = compute_l2_norm_quadrature(f, your_grid_sizes, :chebyshev)
rel_error = abs(l2_test - l2_ref) / l2_ref
println(&quot;Relative error: $(rel_error * 100)%&quot;)</code></pre></li><li><p><strong>Consider total point budget</strong>: Anisotropic grids shine when points are limited</p><pre><code class="language-julia hljs">total_points = 1000
# Isotropic: ~31×31
# Anisotropic options: 50×19, 40×24, 60×16, etc.</code></pre></li></ol><h2 id="Advanced-Topics"><a class="docs-heading-anchor" href="#Advanced-Topics">Advanced Topics</a><a id="Advanced-Topics-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Topics" title="Permalink"></a></h2><h3 id="Adaptive-Grid-Selection"><a class="docs-heading-anchor" href="#Adaptive-Grid-Selection">Adaptive Grid Selection</a><a id="Adaptive-Grid-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Grid-Selection" title="Permalink"></a></h3><p>For automatic grid size selection based on function behavior:</p><pre><code class="language-julia hljs">function estimate_directional_variation(f, n_dims; n_samples=100)
    variations = zeros(n_dims)
    
    for d in 1:n_dims
        # Sample along dimension d
        for _ in 1:n_samples
            x = randn(n_dims) .* 0.5  # Random point
            h = 0.01
            x_plus = copy(x); x_plus[d] += h
            x_minus = copy(x); x_minus[d] -= h
            
            # Finite difference approximation
            deriv = (f(x_plus) - f(x_minus)) / (2h)
            variations[d] += abs(deriv)
        end
    end
    
    return variations / n_samples
end

# Use variations to guide grid sizes
variations = estimate_directional_variation(f, 3)
base_size = 20
grid_sizes = round.(Int, base_size * sqrt.(variations / minimum(variations)))</code></pre><h3 id="Integration-with-Polynomial-Approximation"><a class="docs-heading-anchor" href="#Integration-with-Polynomial-Approximation">Integration with Polynomial Approximation</a><a id="Integration-with-Polynomial-Approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-Polynomial-Approximation" title="Permalink"></a></h3><p>Anisotropic grids are now fully integrated with Globtim&#39;s polynomial approximation workflow through the enhanced <code>lambda_vandermonde</code> function:</p><pre><code class="language-julia hljs"># Method 1: Using MainGenerate with pre-generated grid
grid = generate_anisotropic_grid([40, 20], basis=:chebyshev)
grid_matrix = convert_to_matrix_grid(vec(grid))

# MainGenerate automatically detects anisotropic structure
pol = MainGenerate(f, 2, grid_matrix, 0.1, 0.99, 1.0, 1.0)
# Output: &quot;Detected anisotropic grid structure - using enhanced algorithm&quot;

# Method 2: Using Constructor with test_input
TR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=1.0)
pol_aniso = Constructor(TR, 0, grid=grid_matrix)  # degree ignored with grid

# Method 3: Direct lambda_vandermonde usage
Lambda = SupportGen(2, (:one_d_for_all, 10))
V = lambda_vandermonde(Lambda, grid_matrix)  # Auto-detects anisotropic</code></pre><p>The system automatically:</p><ul><li>Detects when grids have different nodes per dimension</li><li>Routes to the optimized <code>lambda_vandermonde_anisotropic</code> implementation</li><li>Maintains type stability and performance</li><li>Supports Chebyshev and Legendre bases</li></ul><h2 id="Common-Pitfalls"><a class="docs-heading-anchor" href="#Common-Pitfalls">Common Pitfalls</a><a id="Common-Pitfalls-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Pitfalls" title="Permalink"></a></h2><ol><li><p><strong>Over-anisotropy</strong>: Too extreme ratios can miss features</p><pre><code class="language-julia hljs"># Bad: might miss y-direction features
grid_sizes = [100, 5]  # 20:1 ratio

# Better: more balanced
grid_sizes = [50, 10]  # 5:1 ratio</code></pre></li><li><p><strong>Wrong direction</strong>: Ensure more points go where function varies more</p><pre><code class="language-julia hljs"># Check your allocation is correct
f = x -&gt; exp(-10*x[1]^2 - 100*x[2]^2)
# Here y varies MORE, so need more points in y!
grid_sizes = [20, 40]  # More in y</code></pre></li><li><p><strong>Dimension ordering</strong>: Remember Julia&#39;s column-major ordering</p><pre><code class="language-julia hljs">grid = generate_anisotropic_grid([10, 20])
size(grid)  # Returns (11, 21), not (21, 11)</code></pre></li></ol><h2 id="Performance-Tips"><a class="docs-heading-anchor" href="#Performance-Tips">Performance Tips</a><a id="Performance-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips" title="Permalink"></a></h2><ol><li><p><strong>Reuse grids</strong>: Generate once, use multiple times</p><pre><code class="language-julia hljs">grid = generate_anisotropic_grid([50, 25], basis=:chebyshev)
l2_f1 = discrete_l2_norm_riemann(f1, grid)
l2_f2 = discrete_l2_norm_riemann(f2, grid)</code></pre></li><li><p><strong>Batch operations</strong>: Process multiple functions together</p><pre><code class="language-julia hljs">functions = [f1, f2, f3, f4]
grid_spec = [40, 20]
l2_norms = [compute_l2_norm_quadrature(f, grid_spec, :chebyshev) 
            for f in functions]</code></pre></li><li><p><strong>Choose appropriate basis</strong>: </p><ul><li>Chebyshev: Best for smooth functions</li><li>Uniform: Simple, predictable</li><li>Legendre: Good general choice</li></ul></li></ol><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>Anisotropic grids provide a powerful tool for efficient function approximation when functions have different scales in different directions. Key benefits:</p><ul><li><strong>Efficiency</strong>: Same accuracy with fewer points</li><li><strong>Flexibility</strong>: Adapt to function behavior</li><li><strong>Simplicity</strong>: Easy to use with existing tools</li><li><strong>Scalability</strong>: Works in any dimension</li></ul><p>Start with moderate anisotropy ratios and validate against high-resolution references to ensure accuracy.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../critical_point_analysis/">« Critical Point Analysis</a><a class="docs-footer-nextpage" href="../sparsification/">Sparsification »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 20 December 2025 20:15">Saturday 20 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
