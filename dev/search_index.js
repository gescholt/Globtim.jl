var documenterSearchIndex = {"docs":
[{"location":"test_running_guide/#Test-Running-Guide","page":"Test Running Guide","title":"Test Running Guide","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"This guide explains how to run tests for the Globtim package, including different approaches, common issues, and best practices.","category":"page"},{"location":"test_running_guide/#Quick-Start","page":"Test Running Guide","title":"Quick Start","text":"","category":"section"},{"location":"test_running_guide/#Run-All-Tests","page":"Test Running Guide","title":"Run All Tests","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"cd /path/to/globtim\njulia --project test/runtests.jl","category":"page"},{"location":"test_running_guide/#Run-Specific-Test-Suite","page":"Test Running Guide","title":"Run Specific Test Suite","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"julia --project test/test_anisotropic_grids.jl","category":"page"},{"location":"test_running_guide/#Using-Package-Manager","page":"Test Running Guide","title":"Using Package Manager","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"using Pkg\nPkg.activate(\".\")\nPkg.test()","category":"page"},{"location":"test_running_guide/#Test-Organization","page":"Test Running Guide","title":"Test Organization","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"test/\n# Main test suite\n├── runtests.jl                              # Main test runner\n├── test_forwarddiff_integration.jl         # ForwardDiff integration tests\n├── test_function_value_analysis.jl         # Function value error analysis\n├── test_exact_conversion.jl                # Exact conversion tests\n├── test_sparsification.jl                  # Sparsification tests\n├── test_truncation.jl                      # Truncation tests\n├── test_l2_norm_scaling.jl                 # L2 norm scaling tests\n├── test_anisotropic_grids.jl               # Anisotropic grid tests\n├── test_quadrature_l2_norm.jl              # Quadrature L2 norm tests\n├── test_quadrature_l2_phase1_2.jl          # Phase 1/2 quadrature integration\n├── test_quadrature_vs_riemann.jl           # Quadrature vs Riemann comparison\n├── test_hessian_analysis.jl                # Phase 2 Hessian analysis\n├── test_enhanced_analysis_integration.jl   # Phase 3 enhanced analysis\n├── test_statistical_tables.jl              # Phase 3 statistical tables\n# Debug utilities\n├── debug_conversion.jl                     # Debug exact conversion\n├── debug_legendre.jl                        # Debug Legendre polynomials\n└── run_quadrature_tests.jl                  # Standalone quadrature runner","category":"page"},{"location":"test_running_guide/#Running-Tests-Detailed-Instructions","page":"Test Running Guide","title":"Running Tests - Detailed Instructions","text":"","category":"section"},{"location":"test_running_guide/#Method-1:-Command-Line-(Recommended)","page":"Test Running Guide","title":"Method 1: Command Line (Recommended)","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Always use the --project flag to ensure correct package environment:","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"# From the globtim directory\njulia --project test/runtests.jl\n\n# Run specific test\njulia --project test/test_anisotropic_grids.jl\n\n# With custom Julia options\njulia --project --threads=4 test/runtests.jl","category":"page"},{"location":"test_running_guide/#Method-2:-Julia-REPL","page":"Test Running Guide","title":"Method 2: Julia REPL","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"# Start Julia in project directory\njulia> using Pkg\njulia> Pkg.activate(\".\")\njulia> Pkg.test()\n\n# Or run specific test\njulia> include(\"test/test_anisotropic_grids.jl\")","category":"page"},{"location":"test_running_guide/#Method-3:-VS-Code-/-IDE","page":"Test Running Guide","title":"Method 3: VS Code / IDE","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Open the project folder\nEnsure Julia environment is set to project\nRun test file directly or use test runner","category":"page"},{"location":"test_running_guide/#Common-Issues-and-Solutions","page":"Test Running Guide","title":"Common Issues and Solutions","text":"","category":"section"},{"location":"test_running_guide/#Issue-1:-Package-Not-Found","page":"Test Running Guide","title":"Issue 1: Package Not Found","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"ERROR: LoadError: ArgumentError: Package Globtim not found in current path","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Solution: Use --project flag","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"julia --project test/your_test.jl","category":"page"},{"location":"test_running_guide/#Issue-2:-Missing-Dependencies","page":"Test Running Guide","title":"Issue 2: Missing Dependencies","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"ERROR: LoadError: ArgumentError: Package Test not found in current path","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Solution: Ensure test dependencies are installed","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"using Pkg\nPkg.activate(\".\")\nPkg.instantiate()  # Install all dependencies","category":"page"},{"location":"test_running_guide/#Issue-3:-Module-Not-Loaded","page":"Test Running Guide","title":"Issue 3: Module Not Loaded","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"ERROR: UndefVarError: Globtim not defined","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Solution: Add proper using statement","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"using Globtim\nusing Test","category":"page"},{"location":"test_running_guide/#Issue-4:-Path-Issues","page":"Test Running Guide","title":"Issue 4: Path Issues","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"ERROR: could not open file test/test_file.jl","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Solution: Run from project root directory","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"cd /path/to/globtim\njulia --project test/test_file.jl","category":"page"},{"location":"test_running_guide/#Test-Selection-Strategies","page":"Test Running Guide","title":"Test Selection Strategies","text":"","category":"section"},{"location":"test_running_guide/#By-Feature-Area","page":"Test Running Guide","title":"By Feature Area","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"# Core functionality tests\njulia --project test/test_forwarddiff_integration.jl\njulia --project test/test_function_value_analysis.jl\n\n# Grid generation tests\njulia --project test/test_anisotropic_grids.jl\n\n# L2 norm computation tests\njulia --project test/test_quadrature_l2_norm.jl\njulia --project test/test_l2_norm_scaling.jl\njulia --project test/test_quadrature_vs_riemann.jl\n\n# Polynomial manipulation tests\njulia --project test/test_exact_conversion.jl\njulia --project test/test_sparsification.jl\njulia --project test/test_truncation.jl\n\n# Phase 2 analysis tests\njulia --project test/test_hessian_analysis.jl\n\n# Phase 3 analysis tests\njulia --project test/test_enhanced_analysis_integration.jl\njulia --project test/test_statistical_tables.jl\n\n# Phase integration tests\njulia --project test/test_quadrature_l2_phase1_2.jl","category":"page"},{"location":"test_running_guide/#By-Development-Task","page":"Test Running Guide","title":"By Development Task","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"When modifying optimization integration:","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"julia --project test/test_forwarddiff_integration.jl","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"When modifying grid generation:","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"julia --project test/test_anisotropic_grids.jl","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"When modifying L2 norm computation:","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"julia --project test/test_quadrature_l2_norm.jl\njulia --project test/test_l2_norm_scaling.jl\njulia --project test/test_quadrature_vs_riemann.jl","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"When modifying polynomial methods:","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"julia --project test/test_exact_conversion.jl\njulia --project test/test_sparsification.jl\njulia --project test/test_truncation.jl","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"When modifying critical point analysis:","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"julia --project test/test_hessian_analysis.jl\njulia --project test/test_function_value_analysis.jl","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"When modifying Phase 3 features:","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"julia --project test/test_enhanced_analysis_integration.jl\njulia --project test/test_statistical_tables.jl","category":"page"},{"location":"test_running_guide/#Quick-Validation","page":"Test Running Guide","title":"Quick Validation","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"For rapid validation during development:","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"# In REPL with project activated\ninclude(\"test/test_anisotropic_grids.jl\")\n# Make changes\ninclude(\"test/test_anisotropic_grids.jl\")  # Re-run","category":"page"},{"location":"test_running_guide/#Performance-Testing","page":"Test Running Guide","title":"Performance Testing","text":"","category":"section"},{"location":"test_running_guide/#Basic-Timing","page":"Test Running Guide","title":"Basic Timing","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"# Time a specific test suite\n@time include(\"test/test_quadrature_l2_norm.jl\")","category":"page"},{"location":"test_running_guide/#Detailed-Profiling","page":"Test Running Guide","title":"Detailed Profiling","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"using Profile\nProfile.clear()\n@profile include(\"test/test_anisotropic_grids.jl\")\nProfile.print()","category":"page"},{"location":"test_running_guide/#Memory-Usage","page":"Test Running Guide","title":"Memory Usage","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"# Check allocations\n@time @allocated include(\"test/test_anisotropic_grids.jl\")","category":"page"},{"location":"test_running_guide/#Continuous-Integration-Setup","page":"Test Running Guide","title":"Continuous Integration Setup","text":"","category":"section"},{"location":"test_running_guide/#Local-Pre-commit-Hook","page":"Test Running Guide","title":"Local Pre-commit Hook","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Create .git/hooks/pre-commit:","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"#!/bin/bash\necho \"Running tests...\"\njulia --project test/runtests.jl\nif [ $? -ne 0 ]; then\n    echo \"Tests failed. Commit aborted.\"\n    exit 1\nfi","category":"page"},{"location":"test_running_guide/#GitHub-Actions-(Example)","page":"Test Running Guide","title":"GitHub Actions (Example)","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":".github/workflows/test.yml:","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"name: Run tests\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - uses: julia-actions/setup-julia@v1\n      with:\n        version: '1.10'\n    - run: julia --project -e 'using Pkg; Pkg.instantiate()'\n    - run: julia --project test/runtests.jl","category":"page"},{"location":"test_running_guide/#Test-Status-and-Known-Issues","page":"Test Running Guide","title":"Test Status and Known Issues","text":"","category":"section"},{"location":"test_running_guide/#Currently-Passing-Tests","page":"Test Running Guide","title":"Currently Passing Tests","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Main polynomial system solving\nForwardDiff integration\nFunction value error analysis\nExact polynomial conversion\nPolynomial sparsification\nAnisotropic grids\nPhase 1/2 quadrature integration\nPhase 2 Hessian analysis","category":"page"},{"location":"test_running_guide/#Tests-with-Known-Issues","page":"Test Running Guide","title":"Tests with Known Issues","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"test_truncation.jl - L2 norm verification test failing\ntestl2norm_scaling.jl - BoundsError with residual function\ntestquadraturel2_norm.jl - Missing ChebyshevOrthoPoly dependency\ntestquadraturevs_riemann.jl - Missing BenchmarkTools dependency\ntestenhancedanalysis_integration.jl - Tests expect empty stderr\nteststatisticaltables.jl - String formatting test failure","category":"page"},{"location":"test_running_guide/#Test-Coverage-Analysis","page":"Test Running Guide","title":"Test Coverage Analysis","text":"","category":"section"},{"location":"test_running_guide/#Generate-Coverage-Report","page":"Test Running Guide","title":"Generate Coverage Report","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"julia --project --code-coverage test/runtests.jl","category":"page"},{"location":"test_running_guide/#View-Coverage","page":"Test Running Guide","title":"View Coverage","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"using Coverage\ncoverage = process_folder()\ncovered_lines = sum(x -> x.covered, coverage)\ntotal_lines = sum(x -> x.total, coverage)\nprintln(\"Coverage: $(100 * covered_lines / total_lines)%\")","category":"page"},{"location":"test_running_guide/#Debugging-Test-Failures","page":"Test Running Guide","title":"Debugging Test Failures","text":"","category":"section"},{"location":"test_running_guide/#Step-1:-Isolate-the-Test","page":"Test Running Guide","title":"Step 1: Isolate the Test","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"# Run just the failing test set\n@testset \"Specific failing test\" begin\n    # test code\nend","category":"page"},{"location":"test_running_guide/#Step-2:-Add-Debugging-Output","page":"Test Running Guide","title":"Step 2: Add Debugging Output","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"# Temporarily add prints\n@testset \"Debug test\" begin\n    result = some_function()\n    @info \"Result\" result\n    @test result == expected\nend","category":"page"},{"location":"test_running_guide/#Step-3:-Use-Debugger","page":"Test Running Guide","title":"Step 3: Use Debugger","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"using Debugger\n@enter failing_function(args...)","category":"page"},{"location":"test_running_guide/#Step-4:-Check-Environment","page":"Test Running Guide","title":"Step 4: Check Environment","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"# Verify package versions\nusing Pkg\nPkg.status()\n\n# Check Julia version\nversioninfo()","category":"page"},{"location":"test_running_guide/#Best-Practices","page":"Test Running Guide","title":"Best Practices","text":"","category":"section"},{"location":"test_running_guide/#1.-Run-Tests-Frequently","page":"Test Running Guide","title":"1. Run Tests Frequently","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Before commits\nAfter pulling changes\nWhen switching branches","category":"page"},{"location":"test_running_guide/#2.-Test-Incrementally","page":"Test Running Guide","title":"2. Test Incrementally","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Run relevant tests during development\nRun full suite before pushing","category":"page"},{"location":"test_running_guide/#3.-Keep-Tests-Fast","page":"Test Running Guide","title":"3. Keep Tests Fast","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Use smaller grids for routine testing\nSave extensive tests for CI","category":"page"},{"location":"test_running_guide/#4.-Document-Test-Failures","page":"Test Running Guide","title":"4. Document Test Failures","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Note error messages\nRecord steps to reproduce\nCheck if issue is environment-specific","category":"page"},{"location":"test_running_guide/#5.-Maintain-Test-Independence","page":"Test Running Guide","title":"5. Maintain Test Independence","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Tests should not depend on order\nClean up any generated files\nReset global state if modified","category":"page"},{"location":"test_running_guide/#Writing-New-Tests","page":"Test Running Guide","title":"Writing New Tests","text":"","category":"section"},{"location":"test_running_guide/#Test-File-Template","page":"Test Running Guide","title":"Test File Template","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"using Test\nusing Globtim\n\n@testset \"Feature Name Tests\" begin\n    @testset \"Basic functionality\" begin\n        # Test basic usage\n    end\n    \n    @testset \"Edge cases\" begin\n        # Test boundary conditions\n    end\n    \n    @testset \"Error handling\" begin\n        # Test error conditions\n    end\nend","category":"page"},{"location":"test_running_guide/#Adding-to-Test-Suite","page":"Test Running Guide","title":"Adding to Test Suite","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Create test file: test/test_new_feature.jl\nAdd to runtests.jl:\ninclude(\"test_new_feature.jl\")\nDocument in test_documentation.md","category":"page"},{"location":"test_running_guide/#Environment-Variables","page":"Test Running Guide","title":"Environment Variables","text":"","category":"section"},{"location":"test_running_guide/#Parallel-Testing","page":"Test Running Guide","title":"Parallel Testing","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"JULIA_NUM_THREADS=4 julia --project test/runtests.jl","category":"page"},{"location":"test_running_guide/#Verbose-Output","page":"Test Running Guide","title":"Verbose Output","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"JULIA_DEBUG=all julia --project test/runtests.jl","category":"page"},{"location":"test_running_guide/#Custom-Test-Selection","page":"Test Running Guide","title":"Custom Test Selection","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"# In runtests.jl\nif get(ENV, \"TEST_ANISOTROPIC\", \"false\") == \"true\"\n    include(\"test_anisotropic_grids.jl\")\nend","category":"page"},{"location":"test_running_guide/#Troubleshooting-Checklist","page":"Test Running Guide","title":"Troubleshooting Checklist","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"[ ] Using --project flag?\n[ ] In correct directory?\n[ ] Dependencies installed? (Pkg.instantiate())\n[ ] Julia version compatible?\n[ ] Package versions match Project.toml?\n[ ] No conflicting global packages?\n[ ] Clean git working directory?\n[ ] Test files have correct includes?","category":"page"},{"location":"test_running_guide/#Summary","page":"Test Running Guide","title":"Summary","text":"","category":"section"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Running tests effectively requires:","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Correct environment setup (--project)\nUnderstanding test organization\nKnowing when to run which tests\nDebugging skills for failures\nIntegration with development workflow","category":"page"},{"location":"test_running_guide/","page":"Test Running Guide","title":"Test Running Guide","text":"Regular testing ensures code quality and catches regressions early.","category":"page"},{"location":"anisotropic_grids_guide/#Anisotropic-Grids-User-Guide","page":"Anisotropic Grids","title":"Anisotropic Grids User Guide","text":"","category":"section"},{"location":"anisotropic_grids_guide/#Introduction","page":"Anisotropic Grids","title":"Introduction","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Anisotropic grids allow you to use different numbers of quadrature points in each dimension, enabling more efficient approximation of functions that vary at different rates along different axes. This guide explains how to use anisotropic grids in Globtim.","category":"page"},{"location":"anisotropic_grids_guide/#Why-Use-Anisotropic-Grids?","page":"Anisotropic Grids","title":"Why Use Anisotropic Grids?","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Consider approximating a function like f(x,y) = exp(-100x² - y²). This function:","category":"page"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Changes rapidly in the x-direction (due to the factor 100)\nChanges slowly in the y-direction","category":"page"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Using an isotropic grid wastes computational resources by placing unnecessary points in the y-direction. An anisotropic grid can achieve the same accuracy with fewer total points by allocating more points where the function varies rapidly.","category":"page"},{"location":"anisotropic_grids_guide/#Basic-Usage","page":"Anisotropic Grids","title":"Basic Usage","text":"","category":"section"},{"location":"anisotropic_grids_guide/#Generating-Anisotropic-Grids","page":"Anisotropic Grids","title":"Generating Anisotropic Grids","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"using Globtim\n\n# Create a 2D anisotropic grid with 20 points in x, 10 in y\ngrid = generate_anisotropic_grid([19, 9], basis=:chebyshev)\n# Results in a 20×10 grid (input n gives n+1 points)\n\n# 3D anisotropic grid\ngrid_3d = generate_anisotropic_grid([30, 20, 10], basis=:legendre)\n# Results in a 31×21×11 grid\n\n# High-dimensional grids work the same way\ngrid_5d = generate_anisotropic_grid([10, 8, 6, 4, 2], basis=:uniform)","category":"page"},{"location":"anisotropic_grids_guide/#Available-Basis-Types","page":"Anisotropic Grids","title":"Available Basis Types","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":":chebyshev - Chebyshev nodes (default), cluster at boundaries\n:legendre - Uniform spacing (Legendre-Gauss-Lobatto nodes)  \n:uniform - True uniform spacing including endpoints","category":"page"},{"location":"anisotropic_grids_guide/#Computing-L-Norms","page":"Anisotropic Grids","title":"Computing L² Norms","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Anisotropic grids work seamlessly with both L²-norm computation methods:","category":"page"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"# Define a test function\nf = x -> exp(-50*x[1]^2 - 2*x[2]^2)\n\n# Method 1: Quadrature-based (more accurate)\nl2_quad = compute_l2_norm_quadrature(f, [40, 15], :chebyshev)\n\n# Method 2: Riemann sum (works with pre-generated grids)\ngrid = generate_anisotropic_grid([40, 15], basis=:chebyshev)\nl2_riemann = discrete_l2_norm_riemann(f, grid)","category":"page"},{"location":"anisotropic_grids_guide/#Practical-Examples","page":"Anisotropic Grids","title":"Practical Examples","text":"","category":"section"},{"location":"anisotropic_grids_guide/#Example-1:-Multiscale-Function","page":"Anisotropic Grids","title":"Example 1: Multiscale Function","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"# Function with different scales\nf_multiscale = x -> sin(20*x[1]) * exp(-x[2]^2)\n\n# Poor choice: isotropic grid\nl2_iso = compute_l2_norm_quadrature(f_multiscale, [25, 25], :chebyshev)\n# Uses 26×26 = 676 points\n\n# Better choice: anisotropic grid\nl2_aniso = compute_l2_norm_quadrature(f_multiscale, [40, 15], :chebyshev)\n# Uses 41×16 = 656 points, but more accurate!","category":"page"},{"location":"anisotropic_grids_guide/#Example-2:-Choosing-Grid-Sizes","page":"Anisotropic Grids","title":"Example 2: Choosing Grid Sizes","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"# Function that varies as exp(-a₁x₁² - a₂x₂² - ... - aₙxₙ²)\n# Rule of thumb: grid_size[i] ∝ √(a[i])\n\n# For f(x,y,z) = exp(-100x² - 25y² - 4z²)\n# Relative scales: √100:√25:√4 = 10:5:2\ngrid_sizes = [40, 20, 8]  # Proportional allocation\n\nl2 = compute_l2_norm_quadrature(\n    x -> exp(-100*x[1]^2 - 25*x[2]^2 - 4*x[3]^2),\n    grid_sizes,\n    :chebyshev\n)","category":"page"},{"location":"anisotropic_grids_guide/#Example-3:-Performance-Comparison","page":"Anisotropic Grids","title":"Example 3: Performance Comparison","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"using BenchmarkTools\n\nf = x -> exp(-50*x[1]^2 - 2*x[2]^2)\n\n# Reference value\nl2_ref = compute_l2_norm_quadrature(f, [200, 200], :chebyshev)\n\n# Compare different strategies\nconfigs = [\n    ([30, 30], \"Isotropic 30×30\"),\n    ([50, 18], \"Anisotropic 50×18\"),\n    ([60, 15], \"Anisotropic 60×15\")\n]\n\nfor (grid_size, name) in configs\n    l2 = compute_l2_norm_quadrature(f, grid_size, :chebyshev)\n    error = abs(l2 - l2_ref)\n    total = prod(grid_size .+ 1)\n    println(\"$name ($total points): error = $error\")\nend","category":"page"},{"location":"anisotropic_grids_guide/#Utility-Functions","page":"Anisotropic Grids","title":"Utility Functions","text":"","category":"section"},{"location":"anisotropic_grids_guide/#Checking-Grid-Properties","page":"Anisotropic Grids","title":"Checking Grid Properties","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"# Get dimensions of an existing grid\ngrid = generate_anisotropic_grid([10, 20, 30])\ndims = get_grid_dimensions(grid)  # Returns [11, 21, 31]\n\n# Check if a grid is anisotropic\nis_aniso = is_anisotropic(grid)  # Returns true","category":"page"},{"location":"anisotropic_grids_guide/#Backward-Compatibility","page":"Anisotropic Grids","title":"Backward Compatibility","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"The old isotropic interface still works:","category":"page"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"# Old way (isotropic)\ngrid_iso = generate_grid(2, 20, basis=:chebyshev)  # 2D, 21×21 grid\n\n# Equivalent anisotropic call\ngrid_aniso = generate_anisotropic_grid([20, 20], basis=:chebyshev)\n\n# These produce identical grids\n@assert grid_iso == grid_aniso","category":"page"},{"location":"anisotropic_grids_guide/#Best-Practices","page":"Anisotropic Grids","title":"Best Practices","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Analyze your function first: Understand where it varies rapidly\n# Quick visual check in 2D\nf = x -> your_function(x)\nx = range(-1, 1, 100)\ny = range(-1, 1, 100)\nz = [f([xi, yi]) for xi in x, yi in y]\nheatmap(x, y, z)  # Look for directional variation\nStart with moderate anisotropy: Begin with ratios like 2:1 or 3:1\n# Conservative start\ngrid_sizes = [30, 15]  # 2:1 ratio\n\n# More aggressive if function supports it\ngrid_sizes = [50, 10]  # 5:1 ratio\nValidate your choice: Compare with high-resolution reference\nl2_ref = compute_l2_norm_quadrature(f, [100, 100], :chebyshev)\nl2_test = compute_l2_norm_quadrature(f, your_grid_sizes, :chebyshev)\nrel_error = abs(l2_test - l2_ref) / l2_ref\nprintln(\"Relative error: $(rel_error * 100)%\")\nConsider total point budget: Anisotropic grids shine when points are limited\ntotal_points = 1000\n# Isotropic: ~31×31\n# Anisotropic options: 50×19, 40×24, 60×16, etc.","category":"page"},{"location":"anisotropic_grids_guide/#Advanced-Topics","page":"Anisotropic Grids","title":"Advanced Topics","text":"","category":"section"},{"location":"anisotropic_grids_guide/#Adaptive-Grid-Selection","page":"Anisotropic Grids","title":"Adaptive Grid Selection","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"For automatic grid size selection based on function behavior:","category":"page"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"function estimate_directional_variation(f, n_dims; n_samples=100)\n    variations = zeros(n_dims)\n    \n    for d in 1:n_dims\n        # Sample along dimension d\n        for _ in 1:n_samples\n            x = randn(n_dims) .* 0.5  # Random point\n            h = 0.01\n            x_plus = copy(x); x_plus[d] += h\n            x_minus = copy(x); x_minus[d] -= h\n            \n            # Finite difference approximation\n            deriv = (f(x_plus) - f(x_minus)) / (2h)\n            variations[d] += abs(deriv)\n        end\n    end\n    \n    return variations / n_samples\nend\n\n# Use variations to guide grid sizes\nvariations = estimate_directional_variation(f, 3)\nbase_size = 20\ngrid_sizes = round.(Int, base_size * sqrt.(variations / minimum(variations)))","category":"page"},{"location":"anisotropic_grids_guide/#Integration-with-Polynomial-Approximation","page":"Anisotropic Grids","title":"Integration with Polynomial Approximation","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Anisotropic grids are now fully integrated with Globtim's polynomial approximation workflow through the enhanced lambda_vandermonde function:","category":"page"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"# Method 1: Using MainGenerate with pre-generated grid\ngrid = generate_anisotropic_grid([40, 20], basis=:chebyshev)\ngrid_matrix = convert_to_matrix_grid(vec(grid))\n\n# MainGenerate automatically detects anisotropic structure\npol = MainGenerate(f, 2, grid_matrix, 0.1, 0.99, 1.0, 1.0)\n# Output: \"Detected anisotropic grid structure - using enhanced algorithm\"\n\n# Method 2: Using Constructor with test_input\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=1.0)\npol_aniso = Constructor(TR, 0, grid=grid_matrix)  # degree ignored with grid\n\n# Method 3: Direct lambda_vandermonde usage\nLambda = SupportGen(2, (:one_d_for_all, 10))\nV = lambda_vandermonde(Lambda, grid_matrix)  # Auto-detects anisotropic","category":"page"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"The system automatically:","category":"page"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Detects when grids have different nodes per dimension\nRoutes to the optimized lambda_vandermonde_anisotropic implementation\nMaintains type stability and performance\nSupports Chebyshev and Legendre bases","category":"page"},{"location":"anisotropic_grids_guide/#Common-Pitfalls","page":"Anisotropic Grids","title":"Common Pitfalls","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Over-anisotropy: Too extreme ratios can miss features\n# Bad: might miss y-direction features\ngrid_sizes = [100, 5]  # 20:1 ratio\n\n# Better: more balanced\ngrid_sizes = [50, 10]  # 5:1 ratio\nWrong direction: Ensure more points go where function varies more\n# Check your allocation is correct\nf = x -> exp(-10*x[1]^2 - 100*x[2]^2)\n# Here y varies MORE, so need more points in y!\ngrid_sizes = [20, 40]  # More in y\nDimension ordering: Remember Julia's column-major ordering\ngrid = generate_anisotropic_grid([10, 20])\nsize(grid)  # Returns (11, 21), not (21, 11)","category":"page"},{"location":"anisotropic_grids_guide/#Performance-Tips","page":"Anisotropic Grids","title":"Performance Tips","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Reuse grids: Generate once, use multiple times\ngrid = generate_anisotropic_grid([50, 25], basis=:chebyshev)\nl2_f1 = discrete_l2_norm_riemann(f1, grid)\nl2_f2 = discrete_l2_norm_riemann(f2, grid)\nBatch operations: Process multiple functions together\nfunctions = [f1, f2, f3, f4]\ngrid_spec = [40, 20]\nl2_norms = [compute_l2_norm_quadrature(f, grid_spec, :chebyshev) \n            for f in functions]\nChoose appropriate basis: \nChebyshev: Best for smooth functions\nUniform: Simple, predictable\nLegendre: Good general choice","category":"page"},{"location":"anisotropic_grids_guide/#Summary","page":"Anisotropic Grids","title":"Summary","text":"","category":"section"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Anisotropic grids provide a powerful tool for efficient function approximation when functions have different scales in different directions. Key benefits:","category":"page"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Efficiency: Same accuracy with fewer points\nFlexibility: Adapt to function behavior\nSimplicity: Easy to use with existing tools\nScalability: Works in any dimension","category":"page"},{"location":"anisotropic_grids_guide/","page":"Anisotropic Grids","title":"Anisotropic Grids","text":"Start with moderate anisotropy ratios and validate against high-resolution references to ensure accuracy.","category":"page"},{"location":"core_algorithm/#Core-Algorithm","page":"Core Algorithm","title":"Core Algorithm","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Globtim's approach to global optimization consists of three main phases:","category":"page"},{"location":"core_algorithm/#1.-Polynomial-Approximation","page":"Core Algorithm","title":"1. Polynomial Approximation","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The first step constructs a polynomial approximation of the objective function using discrete least squares. For detailed coverage of approximation methods, see Polynomial Approximation.","category":"page"},{"location":"core_algorithm/#Sampling-Strategy","page":"Core Algorithm","title":"Sampling Strategy","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Globtim uses tensorized Chebyshev or Legendre grids for function sampling:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"# Create polynomial approximation\npol = Constructor(\n    TR,           # Test input specification\n    degree,       # Polynomial degree\n    \"chebyshev\"   # Basis type (default)\n)","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The sampling points are chosen to minimize approximation error and avoid Runge's phenomenon.","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"For functions with different scales in different dimensions, see Anisotropic Grids Guide.","category":"page"},{"location":"core_algorithm/#Approximation-Quality","page":"Core Algorithm","title":"Approximation Quality","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The Constructor returns a polynomial with an L2-norm error estimate:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"pol = Constructor(TR, 8)\nprintln(\"Approximation error: \", pol.nrm)\n\n# Access polynomial coefficients\ncoeffs = pol.coeffs  # Coefficient matrix","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The L2-norm can be computed using either Riemann sums or high-accuracy quadrature methods. For details on polynomial post-processing and sparsification, see Polynomial Sparsification.","category":"page"},{"location":"core_algorithm/#Basis-Functions","page":"Core Algorithm","title":"Basis Functions","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Two basis types are supported:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Chebyshev polynomials (default): Better for smooth functions\nLegendre polynomials: Alternative basis with different convergence properties","category":"page"},{"location":"core_algorithm/#2.-Critical-Point-Finding","page":"Core Algorithm","title":"2. Critical Point Finding","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Once we have a polynomial approximation, we find all its critical points by solving:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"∇p(x) = 0","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"where p(x) is our polynomial approximation.","category":"page"},{"location":"core_algorithm/#Polynomial-System-Setup","page":"Core Algorithm","title":"Polynomial System Setup","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"using DynamicPolynomials\n\n# Define polynomial variables\n@polyvar x[1:n_dims]\n\n# Solve the system\nsolutions = solve_polynomial_system(\n    x,          # Variables\n    n_dims,     # Dimension\n    degree,     # Polynomial degree\n    pol.coeffs  # Coefficients\n)","category":"page"},{"location":"core_algorithm/#Solver-Options","page":"Core Algorithm","title":"Solver Options","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Two solvers are available:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"HomotopyContinuation.jl (default): \nNumerical polynomial system solver\nFinds all complex solutions\nFilters for real solutions in domain\nMsolve (optional):\nExact symbolic solver\nRequires external installation\nUseful for verification","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"For detailed solver configuration and selection guidelines, see Polynomial System Solvers.","category":"page"},{"location":"core_algorithm/#Solution-Processing","page":"Core Algorithm","title":"Solution Processing","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Raw solutions are processed to extract valid critical points:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"df = process_crit_pts(\n    solutions,    # Raw solutions\n    f,           # Original function\n    TR,          # Domain specification\n    solver=\"HC\"  # Solver used\n)","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"This function:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Filters complex solutions\nChecks domain boundaries\nEvaluates function at each point\nRemoves duplicates","category":"page"},{"location":"core_algorithm/#3.-Refinement-and-Classification","page":"Core Algorithm","title":"3. Refinement and Classification","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The polynomial critical points are approximate. The final phase refines them using BFGS optimization.","category":"page"},{"location":"core_algorithm/#BFGS-Refinement","page":"Core Algorithm","title":"BFGS Refinement","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Each critical point is used as a starting point for local optimization:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"df_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    max_iters_in_optim=100,     # BFGS iterations\n    bfgs_g_tol=1e-8,           # Gradient tolerance\n    bfgs_f_abstol=1e-8,        # Function tolerance\n    tol_dist=0.025             # Clustering distance\n)","category":"page"},{"location":"core_algorithm/#Convergence-Tracking","page":"Core Algorithm","title":"Convergence Tracking","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The refinement process tracks:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Number of iterations required\nWhether optimization converged\nDistance from initial to refined point\nFunction value improvement","category":"page"},{"location":"core_algorithm/#Algorithm-Parameters","page":"Core Algorithm","title":"Algorithm Parameters","text":"","category":"section"},{"location":"core_algorithm/#Polynomial-Degree","page":"Core Algorithm","title":"Polynomial Degree","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Higher degrees improve approximation but increase cost:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Degree 4-6: Fast, suitable for smooth functions\nDegree 8-10: Good balance for most problems  \nDegree 12+: High accuracy, computationally intensive","category":"page"},{"location":"core_algorithm/#Domain-Scaling","page":"Core Algorithm","title":"Domain Scaling","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"The sample_range parameter controls the search domain:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"# Symmetric domain\nTR = test_input(f, dim=2, center=[0,0], sample_range=1.0)\n\n# Asymmetric domain  \nTR = test_input(f, dim=2, center=[0,0], sample_range=[2.0, 1.0])","category":"page"},{"location":"core_algorithm/#Tolerance-Settings","page":"Core Algorithm","title":"Tolerance Settings","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Key tolerances affecting results:","category":"page"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"tol_dist: Distance for clustering critical points (default: 0.025)\nbfgs_g_tol: Gradient tolerance for refinement (default: 1e-8)\nhessian_tol_zero: Zero eigenvalue threshold (default: 1e-8)","category":"page"},{"location":"core_algorithm/#Performance-Considerations","page":"Core Algorithm","title":"Performance Considerations","text":"","category":"section"},{"location":"core_algorithm/#Computational-Complexity","page":"Core Algorithm","title":"Computational Complexity","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Polynomial construction: O(n^d) where n = sample points per dimension, d = dimension\nSystem solving: Depends on number of critical points (exponential in dimension)\nRefinement: O(k × m) where k = critical points, m = BFGS iterations","category":"page"},{"location":"core_algorithm/#Memory-Usage","page":"Core Algorithm","title":"Memory Usage","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Polynomial storage: O(d^n) coefficients\nSolution storage: Proportional to number of critical points\nHessian analysis: Additional O(n²) per critical point","category":"page"},{"location":"core_algorithm/#Scalability-Tips","page":"Core Algorithm","title":"Scalability Tips","text":"","category":"section"},{"location":"core_algorithm/","page":"Core Algorithm","title":"Core Algorithm","text":"Start with lower polynomial degrees\nUse appropriate domain bounds\nEnable parallel processing where available\nConsider dimension-adaptive strategies for high dimensions","category":"page"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Globtim provides comprehensive visualization capabilities through extension packages. These functions become available when you load CairoMakie or GLMakie.","category":"page"},{"location":"visualization/#Setup","page":"Visualization","title":"Setup","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using Globtim\nusing CairoMakie  # or GLMakie for interactive plots\n\n# Run your analysis first\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)","category":"page"},{"location":"visualization/#Hessian-Analysis-Plots","page":"Visualization","title":"Hessian Analysis Plots","text":"","category":"section"},{"location":"visualization/#Hessian-Norms","page":"Visualization","title":"Hessian Norms","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Visualize the Frobenius norm of Hessian matrices:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = plot_hessian_norms(df_enhanced)\nsave(\"hessian_norms.png\", fig)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This scatter plot shows ||H||_F for each critical point, colored by type (minimum, maximum, saddle).","category":"page"},{"location":"visualization/#Condition-Numbers","page":"Visualization","title":"Condition Numbers","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Analyze numerical stability:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = plot_condition_numbers(df_enhanced)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Displays log-scale condition numbers κ(H) = |λmax|/|λmin|. High values indicate potential numerical issues.","category":"page"},{"location":"visualization/#Critical-Eigenvalues","page":"Visualization","title":"Critical Eigenvalues","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Validate minima and maxima:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = plot_critical_eigenvalues(df_enhanced)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Shows:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Left: Smallest positive eigenvalues for minima\nRight: Largest negative eigenvalues for maxima","category":"page"},{"location":"visualization/#Eigenvalue-Spectrum-Plots","page":"Visualization","title":"Eigenvalue Spectrum Plots","text":"","category":"section"},{"location":"visualization/#All-Eigenvalues","page":"Visualization","title":"All Eigenvalues","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Comprehensive eigenvalue visualization:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# Sort by magnitude (preserves signs)\nfig1 = plot_all_eigenvalues(f, df_enhanced, sort_by=:magnitude)\n\n# Sort by absolute value\nfig2 = plot_all_eigenvalues(f, df_enhanced, sort_by=:abs_magnitude)\n\n# Sort by eigenvalue spread\nfig3 = plot_all_eigenvalues(f, df_enhanced, sort_by=:spread)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Features:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Separate subplots for each critical point type\nVertical alignment with dotted connections\nColor coding by point index","category":"page"},{"location":"visualization/#Raw-vs-Refined-Comparison","page":"Visualization","title":"Raw vs Refined Comparison","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Compare eigenvalues before and after BFGS refinement:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# Default: ordered by point distance\nfig = plot_raw_vs_refined_eigenvalues(f, df_raw, df_enhanced)\n\n# Order by function value difference\nfig = plot_raw_vs_refined_eigenvalues(f, df_raw, df_enhanced, \n                                     sort_by=:function_value_diff)\n\n# Order by eigenvalue norm difference\nfig = plot_raw_vs_refined_eigenvalues(f, df_raw, df_enhanced,\n                                     sort_by=:eigenvalue_diff)","category":"page"},{"location":"visualization/#Customization-Options","page":"Visualization","title":"Customization Options","text":"","category":"section"},{"location":"visualization/#Color-Schemes","page":"Visualization","title":"Color Schemes","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"All plots support custom color schemes:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = plot_hessian_norms(df_enhanced, \n    colors=Dict(\n        :minimum => :blue,\n        :maximum => :red,\n        :saddle => :green,\n        :degenerate => :orange\n    )\n)","category":"page"},{"location":"visualization/#Figure-Properties","page":"Visualization","title":"Figure Properties","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Adjust figure size and resolution:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = plot_condition_numbers(df_enhanced,\n    size=(800, 600),\n    fontsize=14,\n    markersize=10\n)","category":"page"},{"location":"visualization/#Saving-Plots","page":"Visualization","title":"Saving Plots","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Export in various formats:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# High-resolution PNG\nsave(\"plot.png\", fig, px_per_unit=2)\n\n# Vector format\nsave(\"plot.pdf\", fig)\nsave(\"plot.svg\", fig)","category":"page"},{"location":"visualization/#Interactive-Features-(GLMakie)","page":"Visualization","title":"Interactive Features (GLMakie)","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"When using GLMakie, plots become interactive:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using GLMakie\n\nfig = plot_all_eigenvalues(f, df_enhanced)\n# - Zoom with mouse wheel\n# - Pan by dragging\n# - Reset with double-click","category":"page"},{"location":"visualization/#Combined-Visualizations","page":"Visualization","title":"Combined Visualizations","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Create multi-panel figures:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"fig = Figure(resolution=(1200, 800))\n\n# Hessian norms\nax1 = Axis(fig[1, 1], title=\"Hessian Norms\")\nplot_hessian_norms!(ax1, df_enhanced)\n\n# Condition numbers\nax2 = Axis(fig[1, 2], title=\"Condition Numbers\")\nplot_condition_numbers!(ax2, df_enhanced)\n\n# Critical eigenvalues\nax3 = Axis(fig[2, 1:2], title=\"Critical Eigenvalues\")\nplot_critical_eigenvalues!(ax3, df_enhanced)\n\nsave(\"combined_analysis.png\", fig)","category":"page"},{"location":"visualization/#Plotting-Tips","page":"Visualization","title":"Plotting Tips","text":"","category":"section"},{"location":"visualization/#Large-Datasets","page":"Visualization","title":"Large Datasets","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"For many critical points:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# Filter to specific types\ndf_minima = filter(row -> row.critical_point_type == :minimum, df_enhanced)\nfig = plot_hessian_norms(df_minima)","category":"page"},{"location":"visualization/#Publication-Quality","page":"Visualization","title":"Publication Quality","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# Set theme for publication\nset_theme!(\n    fontsize=16,\n    resolution=(800, 600),\n    Axis=(\n        spinewidth=1.5,\n        xgridwidth=0.5,\n        ygridwidth=0.5\n    )\n)\n\nfig = plot_condition_numbers(df_enhanced)\nsave(\"publication_figure.pdf\", fig)\n\n# Reset theme\nset_theme!()","category":"page"},{"location":"visualization/#Animation-(GLMakie)","page":"Visualization","title":"Animation (GLMakie)","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Create animations showing eigenvalue evolution:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using GLMakie\n\n# Animate eigenvalue changes\npoints = Observable(1:10)\nfig = Figure()\nax = Axis(fig[1, 1])\n\non(points) do range\n    # Update plot based on point range\n    # ... plotting code ...\nend\n\n# Create animation\nrecord(fig, \"eigenvalue_evolution.mp4\", 1:nrow(df_enhanced)) do i\n    points[] = 1:i\nend","category":"page"},{"location":"critical_point_analysis/#Critical-Point-Analysis","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Version 1.1.0 introduces comprehensive Hessian-based analysis for classifying and validating critical points.","category":"page"},{"location":"critical_point_analysis/#Hessian-Based-Classification","page":"Critical Point Analysis","title":"Hessian-Based Classification","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"The analyze_critical_points function performs eigenvalue analysis to classify each critical point:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"df_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    enable_hessian=true,      # Enable classification\n    hessian_tol_zero=1e-8    # Zero eigenvalue tolerance\n)","category":"page"},{"location":"critical_point_analysis/#Classification-Types","page":"Critical Point Analysis","title":"Classification Types","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Critical points are classified based on Hessian eigenvalues:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":":minimum - All eigenvalues > hessian_tol_zero (positive definite)\n:maximum - All eigenvalues < -hessian_tol_zero (negative definite)\n:saddle - Mixed positive and negative eigenvalues\n:degenerate - At least one eigenvalue ≈ 0\n:error - Hessian computation failed","category":"page"},{"location":"critical_point_analysis/#Eigenvalue-Analysis","page":"Critical Point Analysis","title":"Eigenvalue Analysis","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"For each critical point, the following metrics are computed:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Key eigenvalue metrics\ndf_enhanced.hessian_eigenvalue_min      # Smallest eigenvalue\ndf_enhanced.hessian_eigenvalue_max      # Largest eigenvalue\ndf_enhanced.hessian_condition_number    # κ(H) = |λ_max|/|λ_min|\ndf_enhanced.hessian_determinant         # det(H)\ndf_enhanced.hessian_trace              # tr(H)\ndf_enhanced.hessian_norm               # ||H||_F (Frobenius norm)","category":"page"},{"location":"critical_point_analysis/#Special-Eigenvalues","page":"Critical Point Analysis","title":"Special Eigenvalues","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"For minima and maxima validation:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# For minima: smallest positive eigenvalue\ndf_enhanced.smallest_positive_eigenval\n\n# For maxima: largest negative eigenvalue  \ndf_enhanced.largest_negative_eigenval","category":"page"},{"location":"critical_point_analysis/#Enhanced-Statistics","page":"Critical Point Analysis","title":"Enhanced Statistics","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Beyond Hessian analysis, additional statistics are computed:","category":"page"},{"location":"critical_point_analysis/#Spatial-Analysis","page":"Critical Point Analysis","title":"Spatial Analysis","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Spatial clustering\ndf_enhanced.region_id                   # Spatial region assignment\ndf_enhanced.nearest_neighbor_dist       # Distance to nearest critical point\n\n# Function value clustering\ndf_enhanced.function_value_cluster      # Similar function values","category":"page"},{"location":"critical_point_analysis/#Convergence-Quality","page":"Critical Point Analysis","title":"Convergence Quality","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Refinement metrics\ndf_enhanced.gradient_norm              # ||∇f|| at critical point\ndf_enhanced.steps                      # BFGS iterations used\ndf_enhanced.converged                  # Convergence success\ndf_enhanced.point_improvement          # ||x_refined - x_initial||\ndf_enhanced.value_improvement          # |f(x_refined) - f(x_initial)|","category":"page"},{"location":"critical_point_analysis/#Basin-Analysis","page":"Critical Point Analysis","title":"Basin Analysis","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"For the unique minimizers in df_min:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Basin of attraction statistics\ndf_min.basin_points                    # Number of converging points\ndf_min.average_convergence_steps       # Mean BFGS iterations\ndf_min.region_coverage_count          # Spatial regions covered\ndf_min.gradient_norm_at_min          # Gradient verification","category":"page"},{"location":"critical_point_analysis/#Statistical-Tables","page":"Critical Point Analysis","title":"Statistical Tables","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Generate comprehensive reports with:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"df_enhanced, df_min, tables, stats = analyze_critical_points_with_tables(\n    f, df, TR,\n    enable_hessian=true,\n    show_tables=true,\n    table_types=[:minimum, :saddle, :maximum]\n)","category":"page"},{"location":"critical_point_analysis/#Table-Contents","page":"Critical Point Analysis","title":"Table Contents","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Each table includes:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Point coordinates and function values\nEigenvalue statistics\nCondition numbers\nConvergence metrics\nDistance measurements","category":"page"},{"location":"critical_point_analysis/#Export-Options","page":"Critical Point Analysis","title":"Export Options","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Export to different formats\nwrite_tables_to_csv(tables, \"results.csv\")\nwrite_tables_to_latex(tables, \"results.tex\")\nwrite_tables_to_markdown(tables, \"results.md\")","category":"page"},{"location":"critical_point_analysis/#Advanced-Options","page":"Critical Point Analysis","title":"Advanced Options","text":"","category":"section"},{"location":"critical_point_analysis/#Custom-Tolerances","page":"Critical Point Analysis","title":"Custom Tolerances","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Fine-tune the analysis with specific tolerances:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"df_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    tol_dist=0.01,              # Tighter clustering\n    bfgs_g_tol=1e-10,          # Higher precision\n    bfgs_f_abstol=1e-12,       # Function tolerance\n    hessian_tol_zero=1e-10     # Eigenvalue threshold\n)","category":"page"},{"location":"critical_point_analysis/#Performance-Mode","page":"Critical Point Analysis","title":"Performance Mode","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"For large problems, disable Hessian analysis:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"# Basic analysis only (faster)\ndf_basic, df_min = analyze_critical_points(\n    f, df, TR,\n    enable_hessian=false  # Skip eigenvalue computation\n)","category":"page"},{"location":"critical_point_analysis/#Verbose-Output","page":"Critical Point Analysis","title":"Verbose Output","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Track progress with detailed output:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"df_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    verbose=true  # Show progress messages\n)","category":"page"},{"location":"critical_point_analysis/#Interpreting-Results","page":"Critical Point Analysis","title":"Interpreting Results","text":"","category":"section"},{"location":"critical_point_analysis/#Quality-Indicators","page":"Critical Point Analysis","title":"Quality Indicators","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Good critical points typically have:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"gradient_norm < 1e-6\nconverged = true\nhessian_condition_number < 1e6\nConsistent classification between raw and refined points","category":"page"},{"location":"critical_point_analysis/#Warning-Signs","page":"Critical Point Analysis","title":"Warning Signs","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Potential issues indicated by:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Large point_improvement values (poor initial approximation)\ndegenerate classification (numerical instability)\nHigh condition numbers (ill-conditioned Hessian)\nFailed convergence within domain","category":"page"},{"location":"critical_point_analysis/#Basin-Structure","page":"Critical Point Analysis","title":"Basin Structure","text":"","category":"section"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"The df_min DataFrame reveals the optimization landscape:","category":"page"},{"location":"critical_point_analysis/","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"Large basin_points: Strong attractor\nHigh region_coverage_count: Wide basin\nLow average_convergence_steps: Smooth basin","category":"page"},{"location":"solvers/#Polynomial-System-Solvers","page":"Solvers","title":"Polynomial System Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Globtim uses polynomial system solvers to find critical points by solving ∇p(x) = 0. This guide covers the available solvers and how to choose between them.","category":"page"},{"location":"solvers/#Available-Solvers","page":"Solvers","title":"Available Solvers","text":"","category":"section"},{"location":"solvers/#HomotopyContinuation.jl-(Default)","page":"Solvers","title":"HomotopyContinuation.jl (Default)","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Numerical polynomial system solver using homotopy continuation methods.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"solutions = solve_polynomial_system(\n    x, n_dims, degree, coeffs,\n    solver=\"HC\"  # Default\n)","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Advantages:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Finds all complex solutions reliably\nHandles high-degree systems well\nGood performance for moderate dimensions\nNo external dependencies","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Limitations:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Numerical accuracy limited by floating point\nMay miss solutions in degenerate cases\nPerformance degrades in high dimensions","category":"page"},{"location":"solvers/#Msolve-(Optional)","page":"Solvers","title":"Msolve (Optional)","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Exact arithmetic solver for polynomial systems.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"solutions = solve_polynomial_system(\n    x, n_dims, degree, coeffs,\n    solver=\"msolve\",\n    msolve_path=\"/path/to/msolve\"\n)","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Advantages:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Exact rational arithmetic\nGuaranteed to find all solutions\nHandles degenerate cases perfectly\nUseful for verification","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Limitations:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Requires external installation\nSlower than numerical methods\nMemory intensive for large systems\nLimited to moderate polynomial degrees","category":"page"},{"location":"solvers/#Installing-Msolve","page":"Solvers","title":"Installing Msolve","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Download from: https://msolve.lip6.fr/\nBuild according to platform instructions\nAdd to PATH or specify path in function call","category":"page"},{"location":"solvers/#macOS/Linux","page":"Solvers","title":"macOS/Linux","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"git clone https://github.com/algebraic-solving/msolve.git\ncd msolve\n./autogen.sh\n./configure\nmake\nsudo make install","category":"page"},{"location":"solvers/#Verification","page":"Solvers","title":"Verification","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"msolve --help","category":"page"},{"location":"solvers/#Solver-Selection-Guidelines","page":"Solvers","title":"Solver Selection Guidelines","text":"","category":"section"},{"location":"solvers/#Use-HomotopyContinuation-when:","page":"Solvers","title":"Use HomotopyContinuation when:","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Working with smooth, well-conditioned problems\nNeed fast solutions for exploration\nDealing with higher dimensions (>4)\nNumerical accuracy is sufficient","category":"page"},{"location":"solvers/#Use-Msolve-when:","page":"Solvers","title":"Use Msolve when:","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Need exact verification of results\nWorking with rational coefficients\nDealing with degenerate or near-singular systems\nPublishing results requiring certainty","category":"page"},{"location":"solvers/#Example-Comparison","page":"Solvers","title":"Example Comparison","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"using Globtim, DynamicPolynomials\n\n# Setup problem\nf = Deuflhard\nTR = test_input(f, dim=2, center=[0,0], sample_range=1.2)\npol = Constructor(TR, 8)\n\n@polyvar x[1:2]\n\n# HomotopyContinuation (fast)\n@time solutions_hc = solve_polynomial_system(\n    x, 2, 8, pol.coeffs,\n    solver=\"HC\"\n)\n\n# Msolve (exact)\n@time solutions_ms = solve_polynomial_system(\n    x, 2, 8, pol.coeffs,\n    solver=\"msolve\"\n)\n\n# Compare results\nprintln(\"HC found $(length(solutions_hc)) solutions\")\nprintln(\"Msolve found $(length(solutions_ms)) solutions\")","category":"page"},{"location":"solvers/#Advanced-Options","page":"Solvers","title":"Advanced Options","text":"","category":"section"},{"location":"solvers/#HomotopyContinuation-Parameters","page":"Solvers","title":"HomotopyContinuation Parameters","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Control solver behavior:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"solutions = solve_polynomial_system(\n    x, n_dims, degree, coeffs,\n    solver=\"HC\",\n    hc_options=Dict(\n        :compile => false,      # Disable compilation for small problems\n        :threading => true,     # Enable parallel tracking\n        :tracker_options => TrackerOptions(\n            automatic_differentiation=2,  # AD order\n            refinement_accuracy=1e-12    # Target accuracy\n        )\n    )\n)","category":"page"},{"location":"solvers/#Msolve-Parameters","page":"Solvers","title":"Msolve Parameters","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Fine-tune exact solving:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"solutions = solve_polynomial_system(\n    x, n_dims, degree, coeffs,\n    solver=\"msolve\",\n    msolve_options=Dict(\n        :precision => 128,      # Bit precision for intermediate computations\n        :threads => 4,          # Number of threads\n        :output_format => \"qq\"  # Rational output format\n    )\n)","category":"page"},{"location":"solvers/#Handling-Solver-Results","page":"Solvers","title":"Handling Solver Results","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Both solvers return solutions in a common format:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"# Process solutions\ndf = process_crit_pts(solutions, f, TR, solver=solver_name)\n\n# Check solution quality\nfor sol in solutions\n    grad_norm = norm(gradient(pol.polynomial, sol))\n    println(\"Solution: $sol, |∇p|: $grad_norm\")\nend","category":"page"},{"location":"solvers/#Performance-Tips","page":"Solvers","title":"Performance Tips","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Problem Scaling\nNormalize domain to [-1,1]ⁿ for better conditioning\nUse appropriate polynomial degree (8-12 typical)\nMemory Management\nHomotopyContinuation: Enable compilation for repeated solves\nMsolve: Monitor RAM usage, may need 10-100x problem size\nParallel Execution\nBoth solvers support multithreading\nSet environment variable: export JULIA_NUM_THREADS=8","category":"page"},{"location":"solvers/#Troubleshooting","page":"Solvers","title":"Troubleshooting","text":"","category":"section"},{"location":"solvers/#HomotopyContinuation-Issues","page":"Solvers","title":"HomotopyContinuation Issues","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Missing solutions:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Increase tracker accuracy\nCheck for solutions at infinity\nTry different random seed","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Slow performance:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Reduce polynomial degree\nEnable compilation\nUse fewer tracker steps","category":"page"},{"location":"solvers/#Msolve-Issues","page":"Solvers","title":"Msolve Issues","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Installation problems:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Check GMP/MPFR dependencies\nVerify compiler support (C99)\nTry pre-built binaries","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Memory errors:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Reduce polynomial degree\nIncrease system RAM/swap\nUse HomotopyContinuation instead","category":"page"},{"location":"solvers/#Related-Documentation","page":"Solvers","title":"Related Documentation","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Core Algorithm - Overall optimization approach\nPolynomial Approximation - Polynomial construction\nAPI Reference - Function documentation","category":"page"},{"location":"anisotropic_grid_tests/#Anisotropic-Grid-Tests-Detailed-Documentation","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests - Detailed Documentation","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"This document provides detailed documentation of the anisotropic grid test suite, explaining each test's purpose, methodology, and expected outcomes.","category":"page"},{"location":"anisotropic_grid_tests/#Test-File:-test/test_anisotropic_grids.jl","page":"Anisotropic Grid Tests","title":"Test File: test/test_anisotropic_grids.jl","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Overview","page":"Anisotropic Grid Tests","title":"Overview","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"The anisotropic grid test suite validates the implementation of grids with different numbers of points per dimension, a critical feature for efficiently approximating multiscale functions.","category":"page"},{"location":"anisotropic_grid_tests/#Test-Structure","page":"Anisotropic Grid Tests","title":"Test Structure","text":"","category":"section"},{"location":"anisotropic_grid_tests/#1.-Basic-Anisotropic-Grid-Generation","page":"Anisotropic Grid Tests","title":"1. Basic Anisotropic Grid Generation","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-2D-Anisotropic-Grid","page":"Anisotropic Grid Tests","title":"Test: 2D Anisotropic Grid","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"grid_2d = generate_anisotropic_grid([3, 5], basis=:chebyshev)\n@test size(grid_2d) == (4, 6)  # 3+1, 5+1","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Verify correct grid dimensions\nValidates: Grid has (n+1) points when n is specified\nExpected: 4×6 grid of SVector{2,Float64} points","category":"page"},{"location":"anisotropic_grid_tests/#Test:-3D-Anisotropic-Grid","page":"Anisotropic Grid Tests","title":"Test: 3D Anisotropic Grid","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"grid_3d = generate_anisotropic_grid([2, 4, 3], basis=:legendre)\n@test size(grid_3d) == (3, 5, 4)","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Test multi-dimensional grid generation\nValidates: Correct handling of 3D specifications\nExpected: 3×5×4 grid with Legendre nodes","category":"page"},{"location":"anisotropic_grid_tests/#Test:-High-Dimensional-Grid-(5D)","page":"Anisotropic Grid Tests","title":"Test: High-Dimensional Grid (5D)","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"grid_5d = generate_anisotropic_grid([2, 3, 2, 4, 3], basis=:uniform)\n@test size(grid_5d) == (3, 4, 3, 5, 4)","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Ensure scalability to high dimensions\nValidates: Memory efficiency and correctness in 5D\nExpected: Proper tensor product structure","category":"page"},{"location":"anisotropic_grid_tests/#2.-Grid-Properties-Tests","page":"Anisotropic Grid Tests","title":"2. Grid Properties Tests","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Chebyshev-Node-Distribution","page":"Anisotropic Grid Tests","title":"Test: Chebyshev Node Distribution","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"grid_cheb = generate_anisotropic_grid([5, 3], basis=:chebyshev)\nx_coords = unique([p[1] for p in grid_cheb])\n@test maximum(x_coords) < 1.0\n@test minimum(x_coords) > -1.0","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Verify Chebyshev nodes cluster at boundaries\nKey Point: Chebyshev nodes use cos((2i+1)π/(2n+2)) formula\nExpected: Nodes strictly within (-1, 1)","category":"page"},{"location":"anisotropic_grid_tests/#Test:-Uniform-Node-Spacing","page":"Anisotropic Grid Tests","title":"Test: Uniform Node Spacing","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"grid_unif = generate_anisotropic_grid(n_points, basis=:uniform)\nspacings = diff(x_coords_unif)\n@test all(s -> isapprox(s, spacings[1], rtol=1e-10), spacings)","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Verify uniform grids have equal spacing\nValidates: Correct implementation of linspace-like behavior\nExpected: All spacings identical to machine precision","category":"page"},{"location":"anisotropic_grid_tests/#3.-L2-Norm-Computation-Quadrature-Method","page":"Anisotropic Grid Tests","title":"3. L2 Norm Computation - Quadrature Method","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Separable-Polynomial-Function","page":"Anisotropic Grid Tests","title":"Test: Separable Polynomial Function","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"f_sep = x -> x[1]^2\nl2_aniso = compute_l2_norm_quadrature(f_sep, [10, 3], :chebyshev)\n@test isapprox(l2_aniso, 2/sqrt(5), rtol=1e-12)","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Mathematical Background: \nFunction: f(x,y) = x²\nL2 norm: √(∫∫ x⁴ dxdy) over [-1,1]²\nAnalytical value: 2/√5\nPurpose: Validate exact quadrature for polynomials\nKey Point: Tests tensor product quadrature accuracy","category":"page"},{"location":"anisotropic_grid_tests/#Test:-Multiscale-Function-Efficiency","page":"Anisotropic Grid Tests","title":"Test: Multiscale Function Efficiency","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"f_aniso = x -> exp(-10*x[1]^2 - x[2]^2)\nl2_iso = compute_l2_norm_quadrature(f_aniso, [7, 7], :chebyshev)  # 49 points\nl2_aniso_smart = compute_l2_norm_quadrature(f_aniso, [10, 5], :chebyshev)  # 50 points\n@test abs(l2_iso - l2_aniso_smart) / l2_iso < 0.1","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Demonstrate anisotropic advantage\nFunction characteristics: Rapid variation in x, slow in y\nExpected: Similar accuracy with different point allocations","category":"page"},{"location":"anisotropic_grid_tests/#4.-L2-Norm-Computation-Riemann-Method","page":"Anisotropic Grid Tests","title":"4. L2 Norm Computation - Riemann Method","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Riemann-Sum-on-Anisotropic-Grid","page":"Anisotropic Grid Tests","title":"Test: Riemann Sum on Anisotropic Grid","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"grid = generate_anisotropic_grid([15, 8], basis=:chebyshev)\nl2_riemann = discrete_l2_norm_riemann(f_test, grid)\nl2_quad = compute_l2_norm_quadrature(f_test, [15, 8], :chebyshev)\n@test abs(l2_riemann - l2_quad) / l2_quad < 0.05","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Validate Riemann sum handles anisotropic grids\nMethod: Constructs cell volumes from point spacing\nExpected: Agreement within 5% of quadrature method","category":"page"},{"location":"anisotropic_grid_tests/#5.-Optimal-Anisotropic-Grid-Performance","page":"Anisotropic Grid Tests","title":"5. Optimal Anisotropic Grid Performance","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Multiscale-Function-with-Large-Scale-Separation","page":"Anisotropic Grid Tests","title":"Test: Multiscale Function with Large Scale Separation","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"f_multiscale = x -> exp(-100*x[1]^2 - x[2]^2)\n# Isotropic: 15×15 = 225 points\n# Anisotropic: 25×9 = 225 points\n@test error_aniso < error_iso","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Quantify improvement for multiscale problems\nKey Result: Typically 10-15x error reduction\nPrinciple: Allocate points based on directional variation","category":"page"},{"location":"anisotropic_grid_tests/#6.-High-Dimensional-Anisotropic-Grids","page":"Anisotropic Grid Tests","title":"6. High-Dimensional Anisotropic Grids","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-4D-Function-with-Varying-Scales","page":"Anisotropic Grid Tests","title":"Test: 4D Function with Varying Scales","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"f_4d = x -> exp(-sum(i*x[i]^2 for i in 1:4))\ngrid_sizes = [10, 8, 6, 4]  # Decreasing resolution","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Test curse of dimensionality mitigation\nStrategy: Fewer points in smoother directions\nValidates: Tensor product structure in 4D","category":"page"},{"location":"anisotropic_grid_tests/#7.-Utility-Function-Tests","page":"Anisotropic Grid Tests","title":"7. Utility Function Tests","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Grid-Dimension-Extraction","page":"Anisotropic Grid Tests","title":"Test: Grid Dimension Extraction","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"dims = get_grid_dimensions(grid)\n@test dims == [4, 6, 3]  # For a [3, 5, 2] input","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Extract actual grid sizes\nUse case: Generic algorithms needing grid info","category":"page"},{"location":"anisotropic_grid_tests/#Test:-Anisotropy-Detection","page":"Anisotropic Grid Tests","title":"Test: Anisotropy Detection","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"@test is_anisotropic(aniso_grid) == true\n@test is_anisotropic(iso_grid) == false","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Distinguish grid types\nApplication: Algorithm selection based on grid type","category":"page"},{"location":"anisotropic_grid_tests/#8.-Backward-Compatibility","page":"Anisotropic Grid Tests","title":"8. Backward Compatibility","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Legacy-Interface-Support","page":"Anisotropic Grid Tests","title":"Test: Legacy Interface Support","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"grid_old = generate_grid(2, 5, basis=:chebyshev)\ngrid_new = generate_anisotropic_grid([5, 5], basis=:chebyshev)\n@test grid_old == grid_new","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Purpose: Ensure old code continues working\nValidates: Seamless migration path","category":"page"},{"location":"anisotropic_grid_tests/#Performance-Demonstration","page":"Anisotropic Grid Tests","title":"Performance Demonstration","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"The test suite includes a demonstration function showing real-world benefits:","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"function demonstrate_anisotropic_benefits()\n    f = x -> exp(-50*x[1]^2 - 2*x[2]^2)\n    # Shows 15x error reduction for anisotropic vs isotropic\nend","category":"page"},{"location":"anisotropic_grid_tests/#Key-Results:","page":"Anisotropic Grid Tests","title":"Key Results:","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Isotropic 20×20 (400 points): Error ~1e-3\nAnisotropic 50×8 (400 points): Error ~6e-5\nImprovement: 15x accuracy gain","category":"page"},{"location":"anisotropic_grid_tests/#Common-Test-Patterns","page":"Anisotropic Grid Tests","title":"Common Test Patterns","text":"","category":"section"},{"location":"anisotropic_grid_tests/#1.-Analytical-Validation","page":"Anisotropic Grid Tests","title":"1. Analytical Validation","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Use functions with known L2 norms\nTest polynomial exactness\nVerify error bounds","category":"page"},{"location":"anisotropic_grid_tests/#2.-Comparative-Testing","page":"Anisotropic Grid Tests","title":"2. Comparative Testing","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Compare methods (quadrature vs Riemann)\nCompare grids (isotropic vs anisotropic)\nBenchmark performance","category":"page"},{"location":"anisotropic_grid_tests/#3.-Edge-Cases","page":"Anisotropic Grid Tests","title":"3. Edge Cases","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Single point per dimension\nVery high dimensions\nExtreme anisotropy ratios","category":"page"},{"location":"anisotropic_grid_tests/#Debugging-Test-Failures","page":"Anisotropic Grid Tests","title":"Debugging Test Failures","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Common-Issues:","page":"Anisotropic Grid Tests","title":"Common Issues:","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Boundary Expectations\nChebyshev nodes don't reach ±1 exactly\nTest for strict inequalities\nAnalytical Values\nDouble-check integral calculations\nConsider domain normalization\nDimension Ordering\nJulia uses column-major ordering\nGrid dimensions may appear transposed\nFunction Passing\nEnsure functions accept SVector arguments\nCheck closure variable capture","category":"page"},{"location":"anisotropic_grid_tests/#Test-Coverage-Metrics","page":"Anisotropic Grid Tests","title":"Test Coverage Metrics","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Current coverage:","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"✓ Grid generation (all bases)\n✓ L2 norm computation (both methods)\n✓ Dimension handling (1D to 5D)\n✓ Performance validation\n✓ Backward compatibility\n✓ Utility functions","category":"page"},{"location":"anisotropic_grid_tests/#Future-Test-Additions","page":"Anisotropic Grid Tests","title":"Future Test Additions","text":"","category":"section"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Potential expansions:","category":"page"},{"location":"anisotropic_grid_tests/","page":"Anisotropic Grid Tests","title":"Anisotropic Grid Tests","text":"Adaptive anisotropic refinement\nOptimal grid size selection\nIntegration with sparsification\nGPU acceleration tests\nParallel computation validation","category":"page"},{"location":"polynomial_approximation/#Polynomial-Approximation","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"This guide covers the polynomial approximation methods used in Globtim, including basis functions, L2-norm computation, and post-processing techniques.","category":"page"},{"location":"polynomial_approximation/#Overview","page":"Polynomial Approximation","title":"Overview","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Globtim uses orthogonal polynomial bases (Chebyshev or Legendre) to approximate objective functions over compact domains. This approach provides:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Stable numerical computation\nOptimal convergence for smooth functions\nEfficient critical point finding via polynomial system solving","category":"page"},{"location":"polynomial_approximation/#Basis-Functions","page":"Polynomial Approximation","title":"Basis Functions","text":"","category":"section"},{"location":"polynomial_approximation/#Chebyshev-Polynomials","page":"Polynomial Approximation","title":"Chebyshev Polynomials","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Default choice for most problems:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"pol = Constructor(TR, degree, basis=:chebyshev)","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Advantages:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Near-optimal approximation for continuous functions\nExtrema at grid boundaries minimize Runge phenomenon\nFast convergence for smooth functions","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Grid points: Chebyshev extrema at cos(πk/n) for k=0,...,n","category":"page"},{"location":"polynomial_approximation/#Legendre-Polynomials","page":"Polynomial Approximation","title":"Legendre Polynomials","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Alternative basis with different properties:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"pol = Constructor(TR, degree, basis=:legendre)","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Advantages:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Orthogonal with respect to uniform weight\nSometimes better for functions with boundary singularities\nNatural for probability-weighted problems","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Grid points: Zeros of Legendre polynomials","category":"page"},{"location":"polynomial_approximation/#L2-Norm-Computation","page":"Polynomial Approximation","title":"L2-Norm Computation","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"The L2-norm measures approximation quality and is used throughout Globtim for error tracking.","category":"page"},{"location":"polynomial_approximation/#Riemann-Sum-Method","page":"Polynomial Approximation","title":"Riemann Sum Method","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Fast discrete approximation using grid points:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"norm_riemann = discrete_l2_norm_riemann(polynomial, grid)","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Characteristics:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"O(n^d) complexity for d dimensions\nAccuracy depends on grid density\nSuitable for quick estimates","category":"page"},{"location":"polynomial_approximation/#Quadrature-Method","page":"Polynomial Approximation","title":"Quadrature Method","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"High-accuracy integration using Gaussian quadrature:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"norm_quad = compute_l2_norm_quadrature(polynomial, grid_spec, basis=:chebyshev)","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Characteristics:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Exact for polynomials up to degree 2n-1\nUses tensor product quadrature\nSupports anisotropic grids\nHigher accuracy than Riemann sums","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Example comparison:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"# Create polynomial approximation\npol = Constructor(TR, 10)\n\n# Compare methods\nnorm_r = discrete_l2_norm_riemann(pol.polynomial, pol.grid)\nnorm_q = compute_l2_norm_quadrature(pol.polynomial, [11, 11], basis=:chebyshev)\n\nprintln(\"Riemann norm: \", norm_r)\nprintln(\"Quadrature norm: \", norm_q)\nprintln(\"Relative difference: \", abs(norm_r - norm_q) / norm_q)","category":"page"},{"location":"polynomial_approximation/#Exact-Arithmetic-Conversion","page":"Polynomial Approximation","title":"Exact Arithmetic Conversion","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Convert from orthogonal basis to exact monomial representation:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"# Get exact monomial coefficients\nexact_coeffs = to_exact_monomial_basis(pol, grid_points)\n\n# Or directly from function\nexact_coeffs = exact_polynomial_coefficients(f, degree, domain_bounds)","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"This enables:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Symbolic manipulation\nExact solver usage (Msolve)\nSparsification analysis","category":"page"},{"location":"polynomial_approximation/#Post-Processing","page":"Polynomial Approximation","title":"Post-Processing","text":"","category":"section"},{"location":"polynomial_approximation/#Sparsification","page":"Polynomial Approximation","title":"Sparsification","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Remove small coefficients while tracking quality:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"# Basic sparsification\nsparse_poly, stats = sparsify_polynomial(polynomial, threshold=1e-10)\n\n# Analyze tradeoffs\nresults = analyze_sparsification_tradeoff(\n    polynomial,\n    thresholds=logspace(-12, -6, 20),\n    compute_error_norm=true\n)","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"See Polynomial Sparsification for detailed guide.","category":"page"},{"location":"polynomial_approximation/#Truncation","page":"Polynomial Approximation","title":"Truncation","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Alternative to sparsification that removes entire monomials:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"# Truncate with L2-norm monitoring\ntruncated, removed_norm = truncate_polynomial(polynomial, threshold=1e-8)\n\n# Analyze impact\nimpact = analyze_truncation_impact(polynomial, threshold)","category":"page"},{"location":"polynomial_approximation/#Anisotropic-Grids","page":"Polynomial Approximation","title":"Anisotropic Grids","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"For functions with different scales per dimension:","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"# Different points per dimension\ngrid = generate_anisotropic_grid([20, 10, 5], basis=:chebyshev)\npol = Constructor(TR, grid)","category":"page"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"See Anisotropic Grids Guide for details.","category":"page"},{"location":"polynomial_approximation/#Best-Practices","page":"Polynomial Approximation","title":"Best Practices","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Degree Selection\nStart with degree 6-8 for exploration\nIncrease to 10-12 for production runs\nMonitor approximation error via pol.nrm\nBasis Choice\nUse Chebyshev (default) for general functions\nTry Legendre for uniform-weighted problems\nBoth support exact conversion and sparsification\nL2-Norm Computation\nUse quadrature for final results\nRiemann sums for quick iteration\nCheck relative difference for validation\nMemory Management\nEnable sparsification for high-degree polynomials\nUse anisotropic grids for multiscale functions\nMonitor coefficient growth with dimension","category":"page"},{"location":"polynomial_approximation/#Related-Documentation","page":"Polynomial Approximation","title":"Related Documentation","text":"","category":"section"},{"location":"polynomial_approximation/","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"Core Algorithm - Overall optimization approach\nAnisotropic Grids Guide - Advanced grid generation\nPolynomial Sparsification - Memory optimization techniques\nAPI Reference - Complete function documentation","category":"page"},{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api_reference/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api_reference/#Problem-Setup","page":"API Reference","title":"Problem Setup","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"test_input - Create test input specification for optimization problems\nConstructor - Build polynomial approximation with automatic grid support\nAccepts pre-generated grids via grid parameter\nAutomatically detects and handles anisotropic grids\nMainGenerate - Core polynomial approximation engine\nSupports degree-based or grid-based input\nAutomatic anisotropic grid detection\nReturns ApproxPoly with L2-norm error\nsolve_polynomial_system - Find critical points by solving ∇p(x) = 0\nprocess_crit_pts - Process and filter critical point solutions","category":"page"},{"location":"api_reference/#Analysis-Functions","page":"API Reference","title":"Analysis Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"analyze_critical_points - Comprehensive critical point analysis with BFGS refinement\nanalyze_critical_points_with_tables - Enhanced analysis with statistical tables","category":"page"},{"location":"api_reference/#Polynomial-Approximation","page":"API Reference","title":"Polynomial Approximation","text":"","category":"section"},{"location":"api_reference/#Core-Functions","page":"API Reference","title":"Core Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"chebyshev_extrema - Generate Chebyshev extrema points\nchebyshev_polys - Evaluate Chebyshev polynomials\ngrid_sample - Create sampling grid for polynomial fitting\nsample_objective_on_grid - Evaluate objective function on grid","category":"page"},{"location":"api_reference/#Vandermonde-Matrix-Construction","page":"API Reference","title":"Vandermonde Matrix Construction","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"lambda_vandermonde - Construct Vandermonde matrix with automatic anisotropic detection\nlambda_vandermonde_anisotropic - Enhanced Vandermonde for anisotropic grids\nis_grid_anisotropic - Check if grid has different nodes per dimension\nanalyze_grid_structure - Extract detailed grid structure information","category":"page"},{"location":"api_reference/#Critical-Point-Analysis","page":"API Reference","title":"Critical Point Analysis","text":"","category":"section"},{"location":"api_reference/#Core-Analysis","page":"API Reference","title":"Core Analysis","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"compute_hessians - Compute Hessian matrices at critical points\nclassify_critical_points - Classify points based on eigenvalues\nstore_all_eigenvalues - Store complete eigenvalue information\nextract_critical_eigenvalues - Extract key eigenvalues for minima/maxima","category":"page"},{"location":"api_reference/#Statistical-Measures","page":"API Reference","title":"Statistical Measures","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"compute_hessian_norms - Calculate Frobenius norms of Hessians\ncompute_eigenvalue_stats - Compute eigenvalue statistics\nanalyze_basins - Analyze basins of attraction","category":"page"},{"location":"api_reference/#BFGS-Refinement","page":"API Reference","title":"BFGS Refinement","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"enhanced_bfgs_refinement - Advanced BFGS with hyperparameter tracking\nrefine_with_enhanced_bfgs - Apply BFGS refinement to DataFrame\ndetermine_convergence_reason - Analyze optimization convergence","category":"page"},{"location":"api_reference/#Exact-Arithmetic-and-Sparsification","page":"API Reference","title":"Exact Arithmetic and Sparsification","text":"","category":"section"},{"location":"api_reference/#Exact-Conversion","page":"API Reference","title":"Exact Conversion","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"to_exact_monomial_basis - Convert polynomial from orthogonal to monomial basis\nexact_polynomial_coefficients - Get exact monomial coefficients from function","category":"page"},{"location":"api_reference/#L-Norm-Analysis","page":"API Reference","title":"L²-Norm Analysis","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"compute_l2_norm_vandermonde - Compute L²-norm using Vandermonde matrices\ncompute_l2_norm_coeffs - Compute L²-norm with modified coefficients\ncompute_l2_norm - Compute L²-norm over a domain\nverify_truncation_quality - Verify L²-norm preservation after truncation\nintegrate_monomial - Analytically integrate monomials","category":"page"},{"location":"api_reference/#Sparsification","page":"API Reference","title":"Sparsification","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"sparsify_polynomial - Zero small coefficients with L²-norm tracking\nanalyze_sparsification_tradeoff - Analyze sparsity vs accuracy\ncompute_approximation_error - Compute error between function and polynomial\nanalyze_approximation_error_tradeoff - Analyze error under sparsification","category":"page"},{"location":"api_reference/#Truncation","page":"API Reference","title":"Truncation","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"truncate_polynomial - Remove small terms with L²-norm monitoring\nmonomial_l2_contributions - Compute L²-norm contribution per monomial\nanalyze_truncation_impact - Analyze truncation effects","category":"page"},{"location":"api_reference/#Domain-Types","page":"API Reference","title":"Domain Types","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"BoxDomain{T} - Box domain [-a,a]ⁿ representation\nAbstractDomain - Abstract type for integration domains","category":"page"},{"location":"api_reference/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api_reference/#Domain-Handling","page":"API Reference","title":"Domain Handling","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"points_in_hypercube - Check if points lie within domain\npoints_in_range - Filter points by function value range","category":"page"},{"location":"api_reference/#Spatial-Analysis","page":"API Reference","title":"Spatial Analysis","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"assign_spatial_regions - Assign region IDs for spatial statistics\ncluster_function_values - Cluster points by function values\ncompute_nearest_neighbors - Find nearest neighbor distances\ncompute_gradients - Compute gradient norms","category":"page"},{"location":"api_reference/#Visualization-Functions","page":"API Reference","title":"Visualization Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"Available when CairoMakie or GLMakie are loaded:","category":"page"},{"location":"api_reference/#Basic-Plots","page":"API Reference","title":"Basic Plots","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"plot_hessian_norms - Scatter plot of Hessian norms\nplot_condition_numbers - Log-scale condition number visualization\nplot_critical_eigenvalues - Critical eigenvalue validation plots","category":"page"},{"location":"api_reference/#Advanced-Visualizations","page":"API Reference","title":"Advanced Visualizations","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"plot_all_eigenvalues - Complete eigenvalue spectrum visualization\nplot_raw_vs_refined_eigenvalues - Compare eigenvalues before/after refinement","category":"page"},{"location":"api_reference/#Built-in-Test-Functions","page":"API Reference","title":"Built-in Test Functions","text":"","category":"section"},{"location":"api_reference/#2D-Functions","page":"API Reference","title":"2D Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"Deuflhard - Challenging function with multiple minima\nHolderTable - Four symmetric global minima\nAckley - Classic multimodal benchmark\ncamel - Six-hump camel function\nshubert - Highly multimodal function","category":"page"},{"location":"api_reference/#3D-Functions","page":"API Reference","title":"3D Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"tref_3d - Highly oscillatory 3D function","category":"page"},{"location":"api_reference/#n-Dimensional-Functions","page":"API Reference","title":"n-Dimensional Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"Rastringin - Classic multimodal benchmark (scalable)\nalpine1, alpine2 - Alpine functions\nCsendes - Smooth function with single minimum","category":"page"},{"location":"api_reference/#Grid-Generation-and-L-Norm-Computation","page":"API Reference","title":"Grid Generation and L²-Norm Computation","text":"","category":"section"},{"location":"api_reference/#Grid-Generation","page":"API Reference","title":"Grid Generation","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"generate_grid - Generate isotropic grid with same points per dimension\ngenerate_anisotropic_grid - Generate grid with different points per dimension\nget_grid_dimensions - Extract number of points in each dimension\nis_anisotropic - Check if grid has different points per dimension","category":"page"},{"location":"api_reference/#Grid-Format-Conversion","page":"API Reference","title":"Grid Format Conversion","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"grid_to_matrix - Convert Array{SVector} grid to matrix format\nensure_matrix_format - Ensure grid is in matrix format for BLAS operations\nmatrix_to_grid - Convert matrix back to Array{SVector} format\nget_grid_info - Query grid format and dimensions","category":"page"},{"location":"api_reference/#L-Norm-Computation","page":"API Reference","title":"L²-Norm Computation","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"discrete_l2_norm_riemann - Compute L²-norm using Riemann sum on grid\ncompute_l2_norm_quadrature - Compute L²-norm using polynomial quadrature","category":"page"},{"location":"api_reference/#Export-Functions","page":"API Reference","title":"Export Functions","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"write_tables_to_csv - Export tables to CSV format\nwrite_tables_to_latex - Export tables to LaTeX format\nwrite_tables_to_markdown - Export tables to Markdown format","category":"page"},{"location":"api_reference/#Types-and-Structures","page":"API Reference","title":"Types and Structures","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"test_input - Input specification type\nBFGSConfig - BFGS configuration parameters\nBFGSResult - BFGS optimization results\nApproxPoly - Polynomial approximation type","category":"page"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"For detailed function documentation with examples, use the Julia help system:","category":"page"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"julia> ?test_input\njulia> ?analyze_critical_points","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide walks you through the basic usage of Globtim.jl for finding all local minima of continuous functions.","category":"page"},{"location":"getting_started/#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The typical Globtim workflow consists of three main steps:","category":"page"},{"location":"getting_started/#1.-Define-the-Problem","page":"Getting Started","title":"1. Define the Problem","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Globtim, DynamicPolynomials, DataFrames\n\n# Use a built-in test function\nf = Deuflhard  \n\n# Or define your own\nf(x) = x[1]^2 + sin(5*x[1]) + x[2]^2 + sin(5*x[2])\n\n# Create test input specification\nTR = test_input(\n    f,                    # Objective function\n    dim=2,               # Dimension\n    center=[0.0, 0.0],   # Domain center\n    sample_range=1.2     # Domain radius\n)","category":"page"},{"location":"getting_started/#2.-Find-Critical-Points","page":"Getting Started","title":"2. Find Critical Points","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create polynomial approximation\npol = Constructor(TR, 8)  # Degree 8 polynomial\nprintln(\"L2-norm approximation error: \", pol.nrm)\n\n# Set up polynomial variables\n@polyvar x[1:2]\n\n# Solve polynomial system for critical points\nsolutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\n\n# Process solutions\ndf = process_crit_pts(solutions, f, TR)\nprintln(\"Found $(nrow(df)) critical points\")","category":"page"},{"location":"getting_started/#3.-Refine-and-Classify","page":"Getting Started","title":"3. Refine and Classify","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Enhanced analysis with Hessian classification\ndf_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    enable_hessian=true,      # Enable eigenvalue analysis\n    verbose=true,             # Show progress\n    tol_dist=0.025           # Clustering tolerance\n)\n\nprintln(\"Found $(nrow(df_min)) unique local minima\")\n\n# Check classifications\nprintln(\"Critical point types:\")\nfor type in unique(df_enhanced.critical_point_type)\n    count = sum(df_enhanced.critical_point_type .== type)\n    println(\"  $type: $count points\")\nend","category":"page"},{"location":"getting_started/#Domain-Specification","page":"Getting Started","title":"Domain Specification","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Globtim supports both uniform and non-uniform domain scaling:","category":"page"},{"location":"getting_started/#Uniform-Scaling","page":"Getting Started","title":"Uniform Scaling","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Square/cube domain\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=1.0)\n# Domain: [-1, 1] × [-1, 1]","category":"page"},{"location":"getting_started/#Non-uniform-Scaling","page":"Getting Started","title":"Non-uniform Scaling","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Rectangular domain\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=[2.0, 1.0])\n# Domain: [-2, 2] × [-1, 1]","category":"page"},{"location":"getting_started/#Polynomial-Degree-Selection","page":"Getting Started","title":"Polynomial Degree Selection","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Higher polynomial degrees provide better approximation but increase computational cost:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Compare different degrees\nfor degree in [4, 6, 8, 10]\n    pol = Constructor(TR, degree)\n    println(\"Degree $degree: L2-norm error = $(pol.nrm)\")\nend","category":"page"},{"location":"getting_started/#Built-in-Test-Functions","page":"Getting Started","title":"Built-in Test Functions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Globtim includes several standard test functions:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Deuflhard - Challenging 2D function with multiple minima\nRastringin - Classic multimodal benchmark\nHolderTable - 2D function with 4 global minima\ntref_3d - 3D test function\nBeale, Rosenbrock, Branin - Standard optimization benchmarks","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Example:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Test on Rastringin function\nf = Rastringin\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=5.12)\n# ... continue with standard workflow","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"See Core Algorithm for details on the polynomial approximation method\nSee Critical Point Analysis for advanced refinement options\nSee Examples for complete working examples\nSee API Reference for detailed function documentation","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page provides complete working examples demonstrating various features of Globtim.jl.","category":"page"},{"location":"examples/#Example-1:-Basic-Usage","page":"Examples","title":"Example 1: Basic Usage","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finding all minima of the Deuflhard function:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Globtim, DynamicPolynomials, DataFrames\n\n# Define the problem\nf = Deuflhard\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=1.2)\n\n# Polynomial approximation\npol = Constructor(TR, 8)\nprintln(\"Approximation error: \", pol.nrm)\n\n# Find critical points\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\ndf = process_crit_pts(solutions, f, TR)\n\n# Refine and classify\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)\n\n# Display results\nprintln(\"\\\\nUnique minima found:\")\nfor i in 1:nrow(df_min)\n    x1, x2 = df_min[i, :x1], df_min[i, :x2]\n    val = df_min[i, :value]\n    println(\"  Minimum $i: ($x1, $x2) with f = $val\")\nend","category":"page"},{"location":"examples/#Example-2:-Custom-Function","page":"Examples","title":"Example 2: Custom Function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Optimizing a user-defined function:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Define custom objective\nfunction my_function(x)\n    return (x[1]^2 - 1)^2 + (x[2]^2 - 1)^2 + 0.1*sin(10*x[1]*x[2])\nend\n\n# Set up problem\nTR = test_input(my_function, dim=2, center=[0.0, 0.0], sample_range=2.0)\n\n# Higher degree for complex function\npol = Constructor(TR, 10)\n\n# Standard workflow\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, 2, 10, pol.coeffs)\ndf = process_crit_pts(solutions, my_function, TR)\ndf_enhanced, df_min = analyze_critical_points(my_function, df, TR)\n\n# Analyze critical point types\ntypes = unique(df_enhanced.critical_point_type)\nfor t in types\n    count = sum(df_enhanced.critical_point_type .== t)\n    println(\"$t: $count points\")\nend","category":"page"},{"location":"examples/#Example-3:-Statistical-Analysis","page":"Examples","title":"Example 3: Statistical Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Generating comprehensive reports:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Run analysis with tables\ndf_enhanced, df_min, tables, stats = analyze_critical_points_with_tables(\n    f, df, TR,\n    enable_hessian=true,\n    show_tables=true,\n    table_types=[:minimum, :saddle, :maximum]\n)\n\n# Access statistics\nprintln(\"\\\\nStatistical Summary:\")\nprintln(\"Average condition number: \", mean(df_enhanced.hessian_condition_number))\nprintln(\"Max gradient norm: \", maximum(df_enhanced.gradient_norm))\nprintln(\"Convergence rate: \", sum(df_enhanced.converged) / nrow(df_enhanced))\n\n# Export results\nwrite_tables_to_csv(tables, \"deuflhard_results.csv\")\nwrite_tables_to_markdown(tables, \"deuflhard_results.md\")","category":"page"},{"location":"examples/#Example-4:-High-Dimensional-Problem","page":"Examples","title":"Example 4: High-Dimensional Problem","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Handling higher dimensions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# 3D Rastringin function\nf = Rastringin\nTR = test_input(f, dim=3, center=[0.0, 0.0, 0.0], sample_range=5.12)\n\n# Use moderate degree for 3D\npol = Constructor(TR, 6)\n\n# Find critical points\n@polyvar x[1:3]\nsolutions = solve_polynomial_system(x, 3, 6, pol.coeffs)\ndf = process_crit_pts(solutions, f, TR)\n\n# Refine without Hessian for speed\ndf_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    enable_hessian=false,  # Faster for high dimensions\n    verbose=true\n)\n\nprintln(\"Found $(nrow(df_min)) local minima in 3D\")","category":"page"},{"location":"examples/#Example-5:-Domain-Exploration","page":"Examples","title":"Example 5: Domain Exploration","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Testing different domain sizes:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"f = HolderTable  # Has 4 global minima\n\n# Try different domain sizes\nfor r in [8.0, 10.0, 12.0]\n    TR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=r)\n    pol = Constructor(TR, 8)\n    \n    @polyvar x[1:2]\n    solutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\n    df = process_crit_pts(solutions, f, TR)\n    df_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=false)\n    \n    println(\"Domain ±$r: found $(nrow(df_min)) minima\")\nend","category":"page"},{"location":"examples/#Example-6:-Visualization","page":"Examples","title":"Example 6: Visualization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Creating plots (requires CairoMakie):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using CairoMakie\n\n# Run standard analysis\nf = Deuflhard\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=1.2)\npol = Constructor(TR, 8)\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\ndf = process_crit_pts(solutions, f, TR)\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)\n\n# Create visualizations\nfig1 = plot_hessian_norms(df_enhanced)\nsave(\"hessian_norms.png\", fig1)\n\nfig2 = plot_condition_numbers(df_enhanced)\nsave(\"condition_numbers.png\", fig2)\n\nfig3 = plot_critical_eigenvalues(df_enhanced)\nsave(\"critical_eigenvalues.png\", fig3)\n\nfig4 = plot_all_eigenvalues(f, df_enhanced, sort_by=:magnitude)\nsave(\"all_eigenvalues.png\", fig4)","category":"page"},{"location":"examples/#Example-7:-Comparing-Polynomial-Degrees","page":"Examples","title":"Example 7: Comparing Polynomial Degrees","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Analyzing approximation quality:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"f = Branin\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=15.0)\n\nresults = DataFrame(\n    degree = Int[],\n    l2_error = Float64[],\n    n_critical = Int[],\n    n_minima = Int[]\n)\n\nfor deg in [4, 6, 8, 10]\n    pol = Constructor(TR, deg)\n    @polyvar x[1:2]\n    solutions = solve_polynomial_system(x, 2, deg, pol.coeffs)\n    df = process_crit_pts(solutions, f, TR)\n    df_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=false)\n    \n    push!(results, (deg, pol.nrm, nrow(df), nrow(df_min)))\nend\n\nprintln(results)","category":"page"},{"location":"examples/#Example-8:-Basin-Analysis","page":"Examples","title":"Example 8: Basin Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Understanding convergence basins:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Function with interesting basin structure\nf(x) = (x[1]^2 + x[2]^2 - 1)^2 + 0.1*(x[1]^2 + x[2]^2)\n\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=2.0)\npol = Constructor(TR, 8)\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\ndf = process_crit_pts(solutions, f, TR)\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)\n\n# Analyze basins\nprintln(\"\\\\nBasin Analysis:\")\nfor i in 1:nrow(df_min)\n    basin_size = df_min[i, :basin_points]\n    avg_steps = df_min[i, :average_convergence_steps]\n    coverage = df_min[i, :region_coverage_count]\n    \n    println(\"Minimum $i:\")\n    println(\"  Basin size: $basin_size points\")\n    println(\"  Average convergence: $avg_steps steps\")\n    println(\"  Spatial coverage: $coverage regions\")\nend","category":"page"},{"location":"grid_formats/#Grid-Formats-in-Globtim","page":"Grid Formats","title":"Grid Formats in Globtim","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"This document explains the two grid representations used in Globtim and how to work with them.","category":"page"},{"location":"grid_formats/#Overview","page":"Grid Formats","title":"Overview","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Globtim uses two different grid formats for different purposes:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Array{SVector} format - Natural Julia arrays of static vectors\nMatrix format - Traditional matrix representation required for linear algebra operations","category":"page"},{"location":"grid_formats/#Grid-Formats","page":"Grid Formats","title":"Grid Formats","text":"","category":"section"},{"location":"grid_formats/#Array{SVector}-Format","page":"Grid Formats","title":"Array{SVector} Format","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"This is the natural output from generate_grid:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"grid = generate_grid(2, 10, basis=:chebyshev)  \n# Returns: 11×11 Array{SVector{2,Float64},2}","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Characteristics:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Each element is an SVector{N,Float64} representing a point\nN-dimensional array structure preserves grid topology\nEfficient for point-wise function evaluation\nNatural for Julia's multiple dispatch","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Used for:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Function evaluation at grid points\nGrid traversal and manipulation\nDiscrete L²-norm computation","category":"page"},{"location":"grid_formats/#Matrix-Format","page":"Grid Formats","title":"Matrix Format","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Required for Vandermonde matrix construction:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"matrix_grid = grid_to_matrix(grid)\n# Returns: 121×2 Matrix{Float64}","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Characteristics:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Each row represents a point\nEach column represents a dimension\nCompatible with BLAS operations\nRequired by lambda_vandermonde","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Used for:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Vandermonde matrix construction\nLinear algebra operations\nPolynomial basis evaluation","category":"page"},{"location":"grid_formats/#Conversion-Utilities","page":"Grid Formats","title":"Conversion Utilities","text":"","category":"section"},{"location":"grid_formats/#grid*to*matrix","page":"Grid Formats","title":"gridtomatrix","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Convert from Array{SVector} to Matrix format:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"grid = generate_grid(2, 10, basis=:chebyshev)\nmatrix = grid_to_matrix(grid)","category":"page"},{"location":"grid_formats/#ensure*matrix*format","page":"Grid Formats","title":"ensurematrixformat","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Automatically handle both formats:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"# Works with either format\nmatrix = ensure_matrix_format(grid_or_matrix)","category":"page"},{"location":"grid_formats/#matrix*to*grid","page":"Grid Formats","title":"matrixtogrid","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Convert back to Array{SVector} format:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"grid = matrix_to_grid(matrix, dim)","category":"page"},{"location":"grid_formats/#get*grid*info","page":"Grid Formats","title":"getgridinfo","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Query information about any grid:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"info = get_grid_info(grid)\n# Returns: (format=:svector_array, n_points=121, dim=2, is_regular=true)","category":"page"},{"location":"grid_formats/#Usage-Examples","page":"Grid Formats","title":"Usage Examples","text":"","category":"section"},{"location":"grid_formats/#Function-Evaluation","page":"Grid Formats","title":"Function Evaluation","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Use Array{SVector} format directly:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"f = x -> sum(x.^2)\ngrid = generate_grid(2, 10)\nvalues = map(f, reshape(grid, :))","category":"page"},{"location":"grid_formats/#Vandermonde-Matrix-Construction","page":"Grid Formats","title":"Vandermonde Matrix Construction","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Convert to matrix format first:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"grid = generate_grid(2, 10, basis=:chebyshev)\nmatrix_grid = grid_to_matrix(grid)\nLambda = SupportGen(2, 5)\nV = lambda_vandermonde(Lambda, matrix_grid, basis=:chebyshev)","category":"page"},{"location":"grid_formats/#Working-with-ApproxPoly","page":"Grid Formats","title":"Working with ApproxPoly","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"The ApproxPoly type stores grids in matrix format:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"pol = Constructor(TR, 10, basis=:chebyshev)\n# pol.grid is already in matrix format\nV = lambda_vandermonde(Lambda, pol.grid, basis=pol.basis)","category":"page"},{"location":"grid_formats/#Best-Practices","page":"Grid Formats","title":"Best Practices","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Let functions handle conversion: Use ensure_matrix_format in functions that need matrix format\nPreserve original format: Don't convert unnecessarily - each format has its advantages\nDocument expectations: Clearly state which format your functions expect\nUse type annotations: Help catch format mismatches early","category":"page"},{"location":"grid_formats/#Why-Two-Formats?","page":"Grid Formats","title":"Why Two Formats?","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Historical reasons:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Early Globtim used matrix format exclusively\nJulia's StaticArrays provide better performance for point operations\nGrid generation evolved to use SVector for efficiency","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Technical reasons:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"Array{SVector} is more natural for Julia's type system\nMatrix format is required for BLAS/LAPACK compatibility\nDifferent algorithms work better with different representations","category":"page"},{"location":"grid_formats/#Migration-Guide","page":"Grid Formats","title":"Migration Guide","text":"","category":"section"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"If you have code expecting one format:","category":"page"},{"location":"grid_formats/","page":"Grid Formats","title":"Grid Formats","text":"# Old code expecting matrix\nfunction my_function(grid::Matrix)\n    # ...\nend\n\n# Updated to handle both\nfunction my_function(grid)\n    matrix_grid = ensure_matrix_format(grid)\n    # ...\nend","category":"page"},{"location":"test_documentation/#Globtim-Test-Documentation","page":"Test Documentation","title":"Globtim Test Documentation","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"This document provides a comprehensive overview of all test suites in the Globtim package, their purpose, and when to run them.","category":"page"},{"location":"test_documentation/#Test-Organization","page":"Test Documentation","title":"Test Organization","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Tests are organized by feature area in the test/ directory:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"test/\n├── runtests.jl                              # Main test runner\n├── test_forwarddiff_integration.jl         # ForwardDiff optimization integration\n├── test_function_value_analysis.jl         # Function value error analysis\n├── test_exact_conversion.jl                # Exact arithmetic conversion\n├── test_sparsification.jl                  # Polynomial sparsification\n├── test_truncation.jl                      # Polynomial truncation\n├── test_l2_norm_scaling.jl                 # L2 norm scaling tests\n├── test_anisotropic_grids.jl               # Anisotropic grid functionality\n├── test_quadrature_l2_norm.jl              # Quadrature-based L2 norm computation\n├── test_quadrature_l2_phase1_2.jl          # Phase 1/2 quadrature integration\n├── test_quadrature_vs_riemann.jl           # Quadrature vs Riemann comparison\n├── test_hessian_analysis.jl                # Phase 2 Hessian analysis\n├── test_enhanced_analysis_integration.jl   # Phase 3 enhanced analysis\n├── test_statistical_tables.jl              # Phase 3 statistical tables\n└── Debug utilities (not in main test suite):\n    ├── debug_conversion.jl\n    ├── debug_legendre.jl\n    └── run_quadrature_tests.jl","category":"page"},{"location":"test_documentation/#Running-Tests","page":"Test Documentation","title":"Running Tests","text":"","category":"section"},{"location":"test_documentation/#Run-All-Tests","page":"Test Documentation","title":"Run All Tests","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"julia --project test/runtests.jl","category":"page"},{"location":"test_documentation/#Run-Specific-Test-Suite","page":"Test Documentation","title":"Run Specific Test Suite","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"julia --project test/test_anisotropic_grids.jl","category":"page"},{"location":"test_documentation/#Run-Tests-with-Package-Manager","page":"Test Documentation","title":"Run Tests with Package Manager","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"using Pkg\nPkg.test(\"Globtim\")","category":"page"},{"location":"test_documentation/#Test-Suites","page":"Test Documentation","title":"Test Suites","text":"","category":"section"},{"location":"test_documentation/#1.-ForwardDiff-Integration-Tests-(test_forwarddiff_integration.jl)","page":"Test Documentation","title":"1. ForwardDiff Integration Tests (test_forwarddiff_integration.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests integration with ForwardDiff.jl for gradient and Hessian computation.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying gradient computation methods\nWhen changing automatic differentiation usage\nAfter updates to optimization routines","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Key tests:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Gradient computation accuracy\nHessian computation correctness\nPerformance of AD operations\nIntegration with polynomial approximations","category":"page"},{"location":"test_documentation/#2.-Function-Value-Error-Analysis-(test_function_value_analysis.jl)","page":"Test Documentation","title":"2. Function Value Error Analysis (test_function_value_analysis.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests the accuracy of function value computations and error metrics.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying error analysis methods\nWhen changing function evaluation procedures\nAfter updates to error metrics","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Test categories:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Error computation methods\nStatistical error analysis\nError propagation through pipeline\nConvergence analysis","category":"page"},{"location":"test_documentation/#3.-Anisotropic-Grid-Tests-(test_anisotropic_grids.jl)","page":"Test Documentation","title":"3. Anisotropic Grid Tests (test_anisotropic_grids.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests the generation and usage of anisotropic grids with different number of points per dimension.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run: ","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying anisotropic_grids.jl\nAfter changes to generate_grid functions\nAfter modifications to L2 norm computation methods","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Test categories:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Basic grid generation (2D, 3D, high-dimensional)\nGrid properties (Chebyshev, Legendre, uniform nodes)\nL2 norm computation on anisotropic grids\nComparison with isotropic grids\nPerformance benefits for multiscale functions\nBackward compatibility","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Key tests:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Verifies grid dimensions match specifications\nTests node distributions for different bases\nValidates L2 norm accuracy on anisotropic grids\nDemonstrates 15x improvement for multiscale functions","category":"page"},{"location":"test_documentation/#4.-Quadrature-L2-Norm-Tests-(test_quadrature_l2_norm.jl)","page":"Test Documentation","title":"4. Quadrature L2 Norm Tests (test_quadrature_l2_norm.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests the quadrature-based L2 norm computation using orthogonal polynomials.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying quadrature_l2_norm.jl\nAfter changes to polynomial quadrature methods\nWhen updating orthogonal polynomial implementations","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Test categories:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Basic functionality for all dimensions (1D-4D)\nDifferent polynomial bases (Chebyshev, Legendre, uniform)\nPolynomial test functions with known L2 norms\nGaussian and exponential functions\nComparison with Riemann sum methods","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Key validations:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Exact computation for polynomials up to degree 2n\nAccurate results for smooth functions\nConsistency across different bases","category":"page"},{"location":"test_documentation/#5.-Exact-Conversion-Tests-(test_exact_conversion.jl)","page":"Test Documentation","title":"5. Exact Conversion Tests (test_exact_conversion.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests conversion of polynomial approximations to exact monomial basis.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying exact_conversion.jl\nWhen changing polynomial representation\nAfter updates to basis conversion methods","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Test coverage:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Conversion from orthogonal to monomial basis\nPreservation of polynomial identity\nExact arithmetic operations\nMulti-dimensional polynomial handling","category":"page"},{"location":"test_documentation/#6.-Sparsification-Tests-(test_sparsification.jl)","page":"Test Documentation","title":"6. Sparsification Tests (test_sparsification.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests polynomial sparsification based on L2 contributions.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying sparsification algorithms\nWhen updating L2 norm computations\nAfter changes to polynomial manipulation","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Key features tested:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Identification of significant monomials\nControlled approximation error\nSparsity vs accuracy tradeoffs\nPerformance improvements","category":"page"},{"location":"test_documentation/#7.-Truncation-Tests-(test_truncation.jl)","page":"Test Documentation","title":"7. Truncation Tests (test_truncation.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests polynomial truncation with L2 error bounds.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying truncation methods\nWhen updating error analysis\nAfter changes to polynomial degree reduction","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Validates:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Truncation error bounds\nOptimal degree selection\nL2 norm preservation","category":"page"},{"location":"test_documentation/#8.-L2-Norm-Scaling-Tests-(test_l2_norm_scaling.jl)","page":"Test Documentation","title":"8. L2 Norm Scaling Tests (test_l2_norm_scaling.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests L2 norm computation with different scaling factors.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying scaling utilities\nWhen updating coordinate transformations\nAfter changes to norm computation","category":"page"},{"location":"test_documentation/#9.-Phase-1/2-Quadrature-Integration-(test_quadrature_l2_phase1_2.jl)","page":"Test Documentation","title":"9. Phase 1/2 Quadrature Integration (test_quadrature_l2_phase1_2.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests integration of quadrature methods with Phase 1 and 2 features.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying quadrature implementations\nWhen updating Phase 1/2 integration\nAfter changes to polynomial basis functions","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Key validations:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Phase 1 polynomial approximation with quadrature\nPhase 2 critical point analysis with quadrature norms\nCross-phase consistency","category":"page"},{"location":"test_documentation/#10.-Quadrature-vs-Riemann-Comparison-(test_quadrature_vs_riemann.jl)","page":"Test Documentation","title":"10. Quadrature vs Riemann Comparison (test_quadrature_vs_riemann.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Benchmarks and compares quadrature vs Riemann sum methods.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When optimizing L2 norm computation\nAfter implementing new norm methods\nFor performance analysis","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Test categories:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Accuracy comparison\nPerformance benchmarks\nConvergence rates\nMethod selection guidance","category":"page"},{"location":"test_documentation/#11.-Phase-2-Hessian-Analysis-(test_hessian_analysis.jl)","page":"Test Documentation","title":"11. Phase 2 Hessian Analysis (test_hessian_analysis.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests Hessian-based critical point classification.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying Hessian computation\nWhen updating critical point classification\nAfter changes to eigenvalue analysis","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Key features tested:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Hessian computation accuracy\nEigenvalue extraction\nCritical point classification (min/max/saddle)\nCondition number analysis","category":"page"},{"location":"test_documentation/#12.-Phase-3-Enhanced-Analysis-Integration-(test_enhanced_analysis_integration.jl)","page":"Test Documentation","title":"12. Phase 3 Enhanced Analysis Integration (test_enhanced_analysis_integration.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests the complete Phase 3 analysis pipeline integration.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying Phase 3 features\nWhen updating analysis pipelines\nAfter changes to data structures","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Test coverage:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Multi-tolerance analysis\nEnhanced BFGS refinement\nOrthant decomposition\nResult aggregation","category":"page"},{"location":"test_documentation/#13.-Phase-3-Statistical-Tables-(test_statistical_tables.jl)","page":"Test Documentation","title":"13. Phase 3 Statistical Tables (test_statistical_tables.jl)","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Purpose: Tests statistical analysis and table generation features.","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When to run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"After modifying statistical computations\nWhen updating table formatting\nAfter changes to analysis outputs","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Validates:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Statistical metric computation\nTable rendering (console and LaTeX)\nData aggregation\nExport functionality","category":"page"},{"location":"test_documentation/#Test-Dependencies","page":"Test Documentation","title":"Test Dependencies","text":"","category":"section"},{"location":"test_documentation/#Required-Packages","page":"Test Documentation","title":"Required Packages","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Test\nLinearAlgebra\nStaticArrays\nPolyChaos (for quadrature tests)\nForwardDiff (for differentiation tests)\nDataFrames (for analysis tests)\nHomotopyContinuation (for critical point tests)\nBenchmarkTools (for performance comparisons)","category":"page"},{"location":"test_documentation/#File-Dependencies","page":"Test Documentation","title":"File Dependencies","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"All test files depend on the main Globtim module\nQuadrature tests require quadrature_l2_norm.jl\nAnisotropic tests require anisotropic_grids.jl\nExact conversion tests require exact_conversion.jl\nPhase 2 tests require hessian_analysis.jl\nPhase 3 tests require enhanced_analysis.jl and data_structures.jl\nStatistical tests require statistical_tables.jl","category":"page"},{"location":"test_documentation/#Adding-New-Tests","page":"Test Documentation","title":"Adding New Tests","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"When adding new functionality:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Create a new test file: test_<feature_name>.jl\nAdd to runtests.jl\nDocument the test suite here\nInclude:\nPurpose and scope\nWhen to run the tests\nDependencies\nKey validations","category":"page"},{"location":"test_documentation/#Continuous-Integration","page":"Test Documentation","title":"Continuous Integration","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Tests should be run:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Before committing changes\nAfter merging branches\nWhen preparing releases\nAs part of CI/CD pipeline","category":"page"},{"location":"test_documentation/#Performance-Benchmarks","page":"Test Documentation","title":"Performance Benchmarks","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Some test files include performance comparisons:","category":"page"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"test_anisotropic_grids.jl: Demonstrates 15x improvement for multiscale functions\ntest_quadrature_l2_norm.jl: Compares quadrature vs Riemann methods","category":"page"},{"location":"test_documentation/#Debugging-Failed-Tests","page":"Test Documentation","title":"Debugging Failed Tests","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"Run the specific test file in isolation\nCheck for missing dependencies (--project flag)\nVerify file paths are correct\nLook for version conflicts in Project.toml\nCheck if new exports are added to Globtim.jl","category":"page"},{"location":"test_documentation/#Test-Coverage-Goals","page":"Test Documentation","title":"Test Coverage Goals","text":"","category":"section"},{"location":"test_documentation/","page":"Test Documentation","title":"Test Documentation","text":"All exported functions should have tests\nEdge cases and error conditions\nPerformance regression tests\nIntegration tests for combined features\nDocumentation examples as tests","category":"page"},{"location":"#Globtim.jl-Documentation","page":"Home","title":"Globtim.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Run Tests) (Image: Julia 1.11) (Image: License: GPL v3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Global optimization of continuous functions via polynomial approximation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Globtim finds all local minima of continuous functions over compact domains using Chebyshev/Legendre polynomial approximation and critical point analysis.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Globtim.jl provides a comprehensive framework for global optimization through:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Polynomial Approximation: High-accuracy approximation using Chebyshev/Legendre polynomials\nCritical Point Finding: Systematic identification of all stationary points\nHessian Analysis: Classification and validation of critical points\nStatistical Assessment: Quality metrics and convergence analysis","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add Globtim","category":"page"},{"location":"#Optional-Dependencies","page":"Home","title":"Optional Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For visualization: add CairoMakie or add GLMakie\nFor exact solving: Install Msolve","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Globtim, DynamicPolynomials, DataFrames\n\n# Define problem\nf = Deuflhard  # Built-in test function\nTR = test_input(f, dim=2, center=[0.0, 0.0], sample_range=1.2)\n\n# Step 1: Polynomial approximation\npol = Constructor(TR, 8)  # Degree 8 approximation\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, 2, 8, pol.coeffs)\ndf = process_crit_pts(solutions, f, TR)\n\n# Step 2: Enhanced analysis\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)","category":"page"},{"location":"#New-Features","page":"Home","title":"New Features","text":"","category":"section"},{"location":"#Anisotropic-Grid-Support","page":"Home","title":"Anisotropic Grid Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generate grids with different numbers of points per dimension\nOptimize point allocation for multiscale functions\nAchieve up to 15x better accuracy for the same computational cost\nSupport for Chebyshev, Legendre, and uniform node distributions","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Anisotropic Grids Guide for details.","category":"page"},{"location":"#Enhanced-L-Norm-Computation","page":"Home","title":"Enhanced L²-Norm Computation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quadrature-based L²-norm using orthogonal polynomials\nSupport for anisotropic grids in all norm computations\nHigh-accuracy integration for smooth functions\nEfficient tensor product quadrature","category":"page"},{"location":"#Polynomial-Sparsification-and-Exact-Arithmetic","page":"Home","title":"Polynomial Sparsification and Exact Arithmetic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convert polynomials to exact monomial basis\nIntelligently sparsify polynomials by removing small coefficients\nTrack L²-norm preservation during sparsification\nAnalyze tradeoffs between sparsity and approximation quality","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Polynomial Sparsification for details.","category":"page"},{"location":"#Testing","page":"Home","title":"Testing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Comprehensive test suite with detailed documentation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Test Documentation Overview - Complete test suite guide\nTest Running Guide - How to run tests effectively\nAnisotropic Grid Tests - Detailed test explanations","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting_started.md\", \"core_algorithm.md\", \"polynomial_approximation.md\", \"solvers.md\", \"critical_point_analysis.md\", \"anisotropic_grids_guide.md\", \"sparsification.md\", \"grid_formats.md\", \"test_documentation.md\", \"test_running_guide.md\", \"anisotropic_grid_tests.md\", \"api_reference.md\", \"examples.md\", \"visualization.md\"]\nDepth = 2","category":"page"},{"location":"sparsification/#Polynomial-Sparsification-and-Exact-Arithmetic","page":"Sparsification","title":"Polynomial Sparsification and Exact Arithmetic","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"Globtim now includes advanced features for exact polynomial arithmetic, sparsification, and truncation analysis. These features help reduce polynomial complexity while maintaining approximation quality.","category":"page"},{"location":"sparsification/#Overview","page":"Sparsification","title":"Overview","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"The sparsification module provides:","category":"page"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"Exact conversion from orthogonal bases (Chebyshev/Legendre) to monomial basis\nIntelligent sparsification that zeros small coefficients while tracking L²-norm preservation\nTruncation analysis with quality metrics\nMultiple L²-norm computation methods for verification","category":"page"},{"location":"sparsification/#Basic-Usage","page":"Sparsification","title":"Basic Usage","text":"","category":"section"},{"location":"sparsification/#Exact-Monomial-Conversion","page":"Sparsification","title":"Exact Monomial Conversion","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"Convert a Globtim polynomial to exact monomial form:","category":"page"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"using Globtim\nusing DynamicPolynomials\n\n# Create a polynomial approximation\nf = x -> sin(3*x[1])\nTR = test_input(f, dim=1, center=[0.0], sample_range=1.0)\npol = Constructor(TR, 10, basis=:chebyshev)\n\n# Convert to exact monomial basis\n@polyvar x\nmono_poly = to_exact_monomial_basis(pol, variables=[x])","category":"page"},{"location":"sparsification/#Polynomial-Sparsification","page":"Sparsification","title":"Polynomial Sparsification","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"Reduce polynomial complexity by removing small coefficients:","category":"page"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"# Sparsify with 1% relative threshold\nresult = sparsify_polynomial(pol, 0.01, mode=:relative)\n\nprintln(\"Achieved $(round((1-result.sparsity)*100))% sparsity\")\nprintln(\"L² norm preserved: $(round(result.l2_ratio*100, digits=1))%\")\nprintln(\"Removed $(length(result.zeroed_indices)) coefficients\")","category":"page"},{"location":"sparsification/#Truncation-Analysis","page":"Sparsification","title":"Truncation Analysis","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"Analyze the impact of different truncation thresholds:","category":"page"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"# Analyze truncation with multiple thresholds\ndomain = BoxDomain(1, 1.0)  # [-1,1] domain\nthresholds = [1e-2, 1e-4, 1e-6, 1e-8]\nresults = analyze_truncation_impact(mono_poly, domain, thresholds=thresholds)\n\n# Display results\nfor res in results\n    println(\"Threshold $(res.threshold): $(res.remaining_terms)/$(res.original_terms) terms, L² ratio: $(round(res.l2_ratio, digits=4))\")\nend","category":"page"},{"location":"sparsification/#Advanced-Features","page":"Sparsification","title":"Advanced Features","text":"","category":"section"},{"location":"sparsification/#L-Norm-Computation-Methods","page":"Sparsification","title":"L²-Norm Computation Methods","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"Compare different L²-norm computation approaches:","category":"page"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"# Method 1: Vandermonde-based (efficient for Globtim polynomials)\nl2_vand = compute_l2_norm_vandermonde(pol)\n\n# Method 2: Grid-based (for monomial polynomials)\ndomain = BoxDomain(1, 1.0)\nl2_grid = compute_l2_norm(mono_poly, domain)\n\n# Method 3: Modified coefficients\nsparse_coeffs = copy(pol.coeffs)\nsparse_coeffs[abs.(sparse_coeffs) .< 1e-6] .= 0\nl2_sparse = compute_l2_norm_coeffs(pol, sparse_coeffs)","category":"page"},{"location":"sparsification/#Approximation-Error-Analysis","page":"Sparsification","title":"Approximation Error Analysis","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"Track how sparsification affects approximation quality:","category":"page"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"# Analyze approximation error vs sparsity tradeoff\nresults = analyze_approximation_error_tradeoff(f, pol, TR, \n                                              thresholds=[1e-4, 1e-6, 1e-8])\n\nfor res in results\n    println(\"Threshold $(res.threshold):\")\n    println(\"  Sparsity: $(round((1-res.sparsity)*100))%\")\n    println(\"  Approximation error: $(res.approx_error)\")\n    println(\"  Error increase: $(round((res.approx_error_ratio-1)*100, digits=1))%\")\nend","category":"page"},{"location":"sparsification/#Preserving-Important-Coefficients","page":"Sparsification","title":"Preserving Important Coefficients","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"When sparsifying, you can preserve specific coefficients:","category":"page"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"# Preserve the first 5 coefficients (often the most important)\nresult = sparsify_polynomial(pol, 1e-4, mode=:relative, \n                           preserve_indices=[1, 2, 3, 4, 5])","category":"page"},{"location":"sparsification/#Complete-Workflow-Example","page":"Sparsification","title":"Complete Workflow Example","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"Here's a complete workflow for polynomial approximation with sparsification:","category":"page"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"using Globtim\nusing DynamicPolynomials\n\n# 1. Define function and create approximation\nf = x -> 1/(1 + 25*x[1]^2)  # Runge function\nTR = test_input(f, dim=1, center=[0.0], sample_range=1.0)\npol = Constructor(TR, 20, basis=:chebyshev)\n\n# 2. Analyze sparsification options\nsparsity_analysis = analyze_sparsification_tradeoff(pol, \n                                                   thresholds=[1e-2, 1e-3, 1e-4, 1e-5])\n\n# 3. Choose threshold based on analysis\nchosen_threshold = 1e-4\nsparse_pol = sparsify_polynomial(pol, chosen_threshold, mode=:relative).polynomial\n\n# 4. Convert to exact monomial form\n@polyvar x\nmono_sparse = to_exact_monomial_basis(sparse_pol, variables=[x])\n\n# 5. Verify quality\ndomain = BoxDomain(1, 1.0)\nquality = verify_truncation_quality(\n    to_exact_monomial_basis(pol, variables=[x]), \n    mono_sparse, \n    domain\n)\n\nprintln(\"Final polynomial has $(count(!iszero, sparse_pol.coeffs)) non-zero terms\")\nprintln(\"L² norm preservation: $(round(quality.l2_ratio*100, digits=1))%\")","category":"page"},{"location":"sparsification/#Performance-Considerations","page":"Sparsification","title":"Performance Considerations","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"Vandermonde approach: More efficient than polynomial construction for L² norms\nSparsification benefits: \nSignificant sparsity achievable while preserving L² accuracy\nReduced memory usage and faster polynomial operations\nExact arithmetic: Use RationalPrecision for exact coefficients, Float64Precision for speed","category":"page"},{"location":"sparsification/#API-Reference","page":"Sparsification","title":"API Reference","text":"","category":"section"},{"location":"sparsification/#Main-Functions","page":"Sparsification","title":"Main Functions","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"to_exact_monomial_basis(pol; variables) - Convert to monomial basis\nsparsify_polynomial(pol, threshold; mode, preserve_indices) - Sparsify polynomial\ntruncate_polynomial(poly, threshold; mode, domain, l2_tolerance) - Truncate with L² checking\ncompute_l2_norm_vandermonde(pol) - Efficient L² norm computation\nanalyze_sparsification_tradeoff(pol; thresholds) - Analyze sparsity options\nverify_truncation_quality(original, truncated, domain) - Verify L² preservation","category":"page"},{"location":"sparsification/#Types","page":"Sparsification","title":"Types","text":"","category":"section"},{"location":"sparsification/","page":"Sparsification","title":"Sparsification","text":"BoxDomain{T} - Represents box domain [-a,a]ⁿ\nAbstractDomain - Abstract type for integration domains","category":"page"}]
}
