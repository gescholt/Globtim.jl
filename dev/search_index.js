var documenterSearchIndex = {"docs":
[{"location":"test_running_guide/#Test-Running-Guide","page":"Test Running Guide","title":"Test Running Guide","text":"This guide explains how to run tests for the Globtim package, including different approaches, common issues, and best practices.","category":"section"},{"location":"test_running_guide/#Quick-Start","page":"Test Running Guide","title":"Quick Start","text":"","category":"section"},{"location":"test_running_guide/#Run-All-Tests","page":"Test Running Guide","title":"Run All Tests","text":"cd /path/to/globtim\njulia --project test/runtests.jl","category":"section"},{"location":"test_running_guide/#Run-Specific-Test-Suite","page":"Test Running Guide","title":"Run Specific Test Suite","text":"julia --project test/test_anisotropic_grids.jl","category":"section"},{"location":"test_running_guide/#Using-Package-Manager","page":"Test Running Guide","title":"Using Package Manager","text":"using Pkg\nPkg.activate(\".\")\nPkg.test()","category":"section"},{"location":"test_running_guide/#Test-Organization","page":"Test Running Guide","title":"Test Organization","text":"test/\n# Main test suite\n├── runtests.jl                              # Main test runner\n├── test_forwarddiff_integration.jl         # ForwardDiff integration tests\n├── test_function_value_analysis.jl         # Function value error analysis\n├── test_exact_conversion.jl                # Exact conversion tests\n├── test_sparsification.jl                  # Sparsification tests\n├── test_truncation.jl                      # Truncation tests\n├── test_l2_norm_scaling.jl                 # L2 norm scaling tests\n├── test_anisotropic_grids.jl               # Anisotropic grid tests\n├── test_quadrature_l2_norm.jl              # Quadrature L2 norm tests\n├── test_quadrature_l2_phase1_2.jl          # Phase 1/2 quadrature integration\n├── test_quadrature_vs_riemann.jl           # Quadrature vs Riemann comparison\n├── test_hessian_analysis.jl                # Phase 2 Hessian analysis\n├── test_enhanced_analysis_integration.jl   # Phase 3 enhanced analysis\n├── test_statistical_tables.jl              # Phase 3 statistical tables\n# Debug utilities\n├── debug_conversion.jl                     # Debug exact conversion\n├── debug_legendre.jl                        # Debug Legendre polynomials\n└── run_quadrature_tests.jl                  # Standalone quadrature runner","category":"section"},{"location":"test_running_guide/#Running-Tests-Detailed-Instructions","page":"Test Running Guide","title":"Running Tests - Detailed Instructions","text":"","category":"section"},{"location":"test_running_guide/#Method-1:-Command-Line-(Recommended)","page":"Test Running Guide","title":"Method 1: Command Line (Recommended)","text":"Always use the --project flag to ensure correct package environment:\n\n# From the globtim directory\njulia --project test/runtests.jl\n\n# Run specific test\njulia --project test/test_anisotropic_grids.jl\n\n# With custom Julia options\njulia --project --threads=4 test/runtests.jl","category":"section"},{"location":"test_running_guide/#Method-2:-Julia-REPL","page":"Test Running Guide","title":"Method 2: Julia REPL","text":"# Start Julia in project directory\njulia> using Pkg\njulia> Pkg.activate(\".\")\njulia> Pkg.test()\n\n# Or run specific test\njulia> include(\"test/test_anisotropic_grids.jl\")","category":"section"},{"location":"test_running_guide/#Method-3:-VS-Code-/-IDE","page":"Test Running Guide","title":"Method 3: VS Code / IDE","text":"Open the project folder\nEnsure Julia environment is set to project\nRun test file directly or use test runner","category":"section"},{"location":"test_running_guide/#Common-Issues-and-Solutions","page":"Test Running Guide","title":"Common Issues and Solutions","text":"","category":"section"},{"location":"test_running_guide/#Issue-1:-Package-Not-Found","page":"Test Running Guide","title":"Issue 1: Package Not Found","text":"ERROR: LoadError: ArgumentError: Package Globtim not found in current path\n\nSolution: Use --project flag\n\njulia --project test/your_test.jl","category":"section"},{"location":"test_running_guide/#Issue-2:-Missing-Dependencies","page":"Test Running Guide","title":"Issue 2: Missing Dependencies","text":"ERROR: LoadError: ArgumentError: Package Test not found in current path\n\nSolution: Ensure test dependencies are installed\n\nusing Pkg\nPkg.activate(\".\")\nPkg.instantiate()  # Install all dependencies","category":"section"},{"location":"test_running_guide/#Issue-3:-Module-Not-Loaded","page":"Test Running Guide","title":"Issue 3: Module Not Loaded","text":"ERROR: UndefVarError: Globtim not defined\n\nSolution: Add proper using statement\n\nusing Globtim\nusing Test","category":"section"},{"location":"test_running_guide/#Issue-4:-Path-Issues","page":"Test Running Guide","title":"Issue 4: Path Issues","text":"ERROR: could not open file test/test_file.jl\n\nSolution: Run from project root directory\n\ncd /path/to/globtim\njulia --project test/test_file.jl","category":"section"},{"location":"test_running_guide/#Test-Selection-Strategies","page":"Test Running Guide","title":"Test Selection Strategies","text":"","category":"section"},{"location":"test_running_guide/#By-Feature-Area","page":"Test Running Guide","title":"By Feature Area","text":"# Core functionality tests\njulia --project test/test_forwarddiff_integration.jl\njulia --project test/test_function_value_analysis.jl\n\n# Grid generation tests\njulia --project test/test_anisotropic_grids.jl\n\n# L2 norm computation tests\njulia --project test/test_quadrature_l2_norm.jl\njulia --project test/test_l2_norm_scaling.jl\njulia --project test/test_quadrature_vs_riemann.jl\n\n# Polynomial manipulation tests\njulia --project test/test_exact_conversion.jl\njulia --project test/test_sparsification.jl\njulia --project test/test_truncation.jl\n\n# Phase 2 analysis tests\njulia --project test/test_hessian_analysis.jl\n\n# Phase 3 analysis tests\njulia --project test/test_enhanced_analysis_integration.jl\njulia --project test/test_statistical_tables.jl\n\n# Phase integration tests\njulia --project test/test_quadrature_l2_phase1_2.jl","category":"section"},{"location":"test_running_guide/#By-Development-Task","page":"Test Running Guide","title":"By Development Task","text":"When modifying optimization integration:\n\njulia --project test/test_forwarddiff_integration.jl\n\nWhen modifying grid generation:\n\njulia --project test/test_anisotropic_grids.jl\n\nWhen modifying L2 norm computation:\n\njulia --project test/test_quadrature_l2_norm.jl\njulia --project test/test_l2_norm_scaling.jl\njulia --project test/test_quadrature_vs_riemann.jl\n\nWhen modifying polynomial methods:\n\njulia --project test/test_exact_conversion.jl\njulia --project test/test_sparsification.jl\njulia --project test/test_truncation.jl\n\nWhen modifying critical point analysis:\n\njulia --project test/test_hessian_analysis.jl\njulia --project test/test_function_value_analysis.jl\n\nWhen modifying Phase 3 features:\n\njulia --project test/test_enhanced_analysis_integration.jl\njulia --project test/test_statistical_tables.jl","category":"section"},{"location":"test_running_guide/#Quick-Validation","page":"Test Running Guide","title":"Quick Validation","text":"For rapid validation during development:\n\n# In REPL with project activated\ninclude(\"test/test_anisotropic_grids.jl\")\n# Make changes\ninclude(\"test/test_anisotropic_grids.jl\")  # Re-run","category":"section"},{"location":"test_running_guide/#Performance-Testing","page":"Test Running Guide","title":"Performance Testing","text":"","category":"section"},{"location":"test_running_guide/#Basic-Timing","page":"Test Running Guide","title":"Basic Timing","text":"# Time a specific test suite\n@time include(\"test/test_quadrature_l2_norm.jl\")","category":"section"},{"location":"test_running_guide/#Detailed-Profiling","page":"Test Running Guide","title":"Detailed Profiling","text":"using Profile\nProfile.clear()\n@profile include(\"test/test_anisotropic_grids.jl\")\nProfile.print()","category":"section"},{"location":"test_running_guide/#Memory-Usage","page":"Test Running Guide","title":"Memory Usage","text":"# Check allocations\n@time @allocated include(\"test/test_anisotropic_grids.jl\")","category":"section"},{"location":"test_running_guide/#Continuous-Integration-Setup","page":"Test Running Guide","title":"Continuous Integration Setup","text":"","category":"section"},{"location":"test_running_guide/#Local-Pre-commit-Hook","page":"Test Running Guide","title":"Local Pre-commit Hook","text":"Create .git/hooks/pre-commit:\n\n#!/bin/bash\necho \"Running tests...\"\njulia --project test/runtests.jl\nif [ $? -ne 0 ]; then\n    echo \"Tests failed. Commit aborted.\"\n    exit 1\nfi","category":"section"},{"location":"test_running_guide/#GitHub-Actions-(Example)","page":"Test Running Guide","title":"GitHub Actions (Example)","text":".github/workflows/test.yml:\n\nname: Run tests\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - uses: julia-actions/setup-julia@v1\n      with:\n        version: '1.10'\n    - run: julia --project -e 'using Pkg; Pkg.instantiate()'\n    - run: julia --project test/runtests.jl","category":"section"},{"location":"test_running_guide/#Test-Status-and-Known-Issues","page":"Test Running Guide","title":"Test Status and Known Issues","text":"","category":"section"},{"location":"test_running_guide/#Currently-Passing-Tests","page":"Test Running Guide","title":"Currently Passing Tests","text":"Main polynomial system solving\nForwardDiff integration\nFunction value error analysis\nExact polynomial conversion\nPolynomial sparsification\nAnisotropic grids\nPhase 1/2 quadrature integration\nPhase 2 Hessian analysis","category":"section"},{"location":"test_running_guide/#Tests-with-Known-Issues","page":"Test Running Guide","title":"Tests with Known Issues","text":"test_truncation.jl - L2 norm verification test failing\ntestl2norm_scaling.jl - BoundsError with residual function\ntestquadraturel2_norm.jl - Missing ChebyshevOrthoPoly dependency\ntestquadraturevs_riemann.jl - Missing BenchmarkTools dependency\ntestenhancedanalysis_integration.jl - Tests expect empty stderr\nteststatisticaltables.jl - String formatting test failure","category":"section"},{"location":"test_running_guide/#Test-Coverage-Analysis","page":"Test Running Guide","title":"Test Coverage Analysis","text":"","category":"section"},{"location":"test_running_guide/#Generate-Coverage-Report","page":"Test Running Guide","title":"Generate Coverage Report","text":"julia --project --code-coverage test/runtests.jl","category":"section"},{"location":"test_running_guide/#View-Coverage","page":"Test Running Guide","title":"View Coverage","text":"using Coverage\ncoverage = process_folder()\ncovered_lines = sum(x -> x.covered, coverage)\ntotal_lines = sum(x -> x.total, coverage)\nprintln(\"Coverage: $(100 * covered_lines / total_lines)%\")","category":"section"},{"location":"test_running_guide/#Debugging-Test-Failures","page":"Test Running Guide","title":"Debugging Test Failures","text":"","category":"section"},{"location":"test_running_guide/#Step-1:-Isolate-the-Test","page":"Test Running Guide","title":"Step 1: Isolate the Test","text":"# Run just the failing test set\n@testset \"Specific failing test\" begin\n    # test code\nend","category":"section"},{"location":"test_running_guide/#Step-2:-Add-Debugging-Output","page":"Test Running Guide","title":"Step 2: Add Debugging Output","text":"# Temporarily add prints\n@testset \"Debug test\" begin\n    result = some_function()\n    @info \"Result\" result\n    @test result == expected\nend","category":"section"},{"location":"test_running_guide/#Step-3:-Use-Debugger","page":"Test Running Guide","title":"Step 3: Use Debugger","text":"using Debugger\n@enter failing_function(args...)","category":"section"},{"location":"test_running_guide/#Step-4:-Check-Environment","page":"Test Running Guide","title":"Step 4: Check Environment","text":"# Verify package versions\nusing Pkg\nPkg.status()\n\n# Check Julia version\nversioninfo()","category":"section"},{"location":"test_running_guide/#Best-Practices","page":"Test Running Guide","title":"Best Practices","text":"","category":"section"},{"location":"test_running_guide/#1.-Run-Tests-Frequently","page":"Test Running Guide","title":"1. Run Tests Frequently","text":"Before commits\nAfter pulling changes\nWhen switching branches","category":"section"},{"location":"test_running_guide/#2.-Test-Incrementally","page":"Test Running Guide","title":"2. Test Incrementally","text":"Run relevant tests during development\nRun full suite before pushing","category":"section"},{"location":"test_running_guide/#3.-Keep-Tests-Fast","page":"Test Running Guide","title":"3. Keep Tests Fast","text":"Use smaller grids for routine testing\nSave extensive tests for CI","category":"section"},{"location":"test_running_guide/#4.-Document-Test-Failures","page":"Test Running Guide","title":"4. Document Test Failures","text":"Note error messages\nRecord steps to reproduce\nCheck if issue is environment-specific","category":"section"},{"location":"test_running_guide/#5.-Maintain-Test-Independence","page":"Test Running Guide","title":"5. Maintain Test Independence","text":"Tests should not depend on order\nClean up any generated files\nReset global state if modified","category":"section"},{"location":"test_running_guide/#Writing-New-Tests","page":"Test Running Guide","title":"Writing New Tests","text":"","category":"section"},{"location":"test_running_guide/#Test-File-Template","page":"Test Running Guide","title":"Test File Template","text":"using Test\nusing Globtim\n\n@testset \"Feature Name Tests\" begin\n    @testset \"Basic functionality\" begin\n        # Test basic usage\n    end\n    \n    @testset \"Edge cases\" begin\n        # Test boundary conditions\n    end\n    \n    @testset \"Error handling\" begin\n        # Test error conditions\n    end\nend","category":"section"},{"location":"test_running_guide/#Adding-to-Test-Suite","page":"Test Running Guide","title":"Adding to Test Suite","text":"Create test file: test/test_new_feature.jl\nAdd to runtests.jl:\ninclude(\"test_new_feature.jl\")\nDocument in test_documentation.md","category":"section"},{"location":"test_running_guide/#Environment-Variables","page":"Test Running Guide","title":"Environment Variables","text":"","category":"section"},{"location":"test_running_guide/#Parallel-Testing","page":"Test Running Guide","title":"Parallel Testing","text":"JULIA_NUM_THREADS=4 julia --project test/runtests.jl","category":"section"},{"location":"test_running_guide/#Verbose-Output","page":"Test Running Guide","title":"Verbose Output","text":"JULIA_DEBUG=all julia --project test/runtests.jl","category":"section"},{"location":"test_running_guide/#Custom-Test-Selection","page":"Test Running Guide","title":"Custom Test Selection","text":"# In runtests.jl\nif get(ENV, \"TEST_ANISOTROPIC\", \"false\") == \"true\"\n    include(\"test_anisotropic_grids.jl\")\nend","category":"section"},{"location":"test_running_guide/#Summary","page":"Test Running Guide","title":"Summary","text":"Running tests effectively requires:\n\nCorrect environment setup (--project)\nUnderstanding test organization\nKnowing when to run which tests\nDebugging skills for failures\nIntegration with development workflow\n\nRegular testing ensures code quality and catches regressions early.","category":"section"},{"location":"core_algorithm/#Core-Algorithm","page":"Core Algorithm","title":"Core Algorithm","text":"Globtim's approach to global optimization consists of three main phases:\n\n<!– Illustration commented out - not legible at current size\n\nflowchart LR\n    subgraph Phase1[\"Phase 1: Polynomial Approximation\"]\n        A[Sample function<br>on grid] --> B[Fit polynomial<br>in orthogonal basis]\n    end\n    subgraph Phase2[\"Phase 2: Critical Point Finding\"]\n        C[Convert to<br>monomial basis] --> D[Solve ∇p = 0]\n    end\n    subgraph Phase3[\"Phase 3: Refinement\"]\n        E[BFGS<br>refinement] --> F[Hessian<br>classification]\n    end\n    Phase1 --> Phase2 --> Phase3\n\n–>","category":"section"},{"location":"core_algorithm/#1.-Polynomial-Approximation","page":"Core Algorithm","title":"1. Polynomial Approximation","text":"The first step constructs a polynomial approximation of the objective function using discrete least squares. For detailed coverage of approximation methods, see Polynomial Approximation.","category":"section"},{"location":"core_algorithm/#Sampling-Strategy","page":"Core Algorithm","title":"Sampling Strategy","text":"Globtim uses tensorized Chebyshev or Legendre grids for function sampling:\n\n# Create polynomial approximation\npol = Constructor(\n    TR,           # Test input specification\n    degree,       # Polynomial degree\n    \"chebyshev\"   # Basis type (default)\n)\n\nThe sampling points are chosen to minimize approximation error and avoid Runge's phenomenon.","category":"section"},{"location":"core_algorithm/#Approximation-Quality","page":"Core Algorithm","title":"Approximation Quality","text":"The Constructor returns a polynomial with an L2-norm error estimate:\n\npol = Constructor(TR, 8)\nprintln(\"Approximation error: \", pol.nrm)\n\n# Access polynomial coefficients\ncoeffs = pol.coeffs  # Coefficient matrix\n\nThe L2-norm can be computed using either Riemann sums or high-accuracy quadrature methods. For details on polynomial post-processing and sparsification, see Polynomial Sparsification.","category":"section"},{"location":"core_algorithm/#Basis-Functions","page":"Core Algorithm","title":"Basis Functions","text":"Two basis types are supported:\n\nChebyshev polynomials (default): Better for smooth functions\nLegendre polynomials: Alternative basis with different convergence properties","category":"section"},{"location":"core_algorithm/#2.-Critical-Point-Finding","page":"Core Algorithm","title":"2. Critical Point Finding","text":"Once we have a polynomial approximation, we find all its critical points by solving:\n\n∇p(x) = 0\n\nwhere p(x) is our polynomial approximation.","category":"section"},{"location":"core_algorithm/#Polynomial-System-Setup","page":"Core Algorithm","title":"Polynomial System Setup","text":"using DynamicPolynomials\n\n# Define polynomial variables\n@polyvar x[1:n_dims]\n\n# Solve the system\nsolutions = solve_polynomial_system(\n    x,          # Variables\n    n_dims,     # Dimension\n    degree,     # Polynomial degree\n    pol.coeffs  # Coefficients\n)","category":"section"},{"location":"core_algorithm/#Solver-Options","page":"Core Algorithm","title":"Solver Options","text":"Two solvers are available:\n\nHomotopyContinuation.jl (default): State of the art numerical algebraic geometry method\nmsolve: State of the art symbolic (exact) method, relies on Gröbner basis computations\n\nFor detailed solver configuration and selection guidelines, see Polynomial System Solvers.","category":"section"},{"location":"core_algorithm/#Solution-Processing","page":"Core Algorithm","title":"Solution Processing","text":"Raw solutions are processed to extract valid critical points:\n\ndf = process_crit_pts(\n    solutions,    # Raw solutions\n    f,           # Original function\n    TR,          # Domain specification\n    solver=\"HC\"  # Solver used\n)\n\nThis function:\n\nFilters complex solutions\nChecks domain boundaries\nEvaluates function at each point\nRemoves duplicates","category":"section"},{"location":"core_algorithm/#3.-Refinement-and-Classification","page":"Core Algorithm","title":"3. Refinement and Classification","text":"The polynomial critical points are approximate. The final phase refines them using BFGS optimization.","category":"section"},{"location":"core_algorithm/#BFGS-Refinement","page":"Core Algorithm","title":"BFGS Refinement","text":"Each critical point is used as a starting point for local optimization:\n\ndf_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    max_iters_in_optim=100,     # BFGS iterations\n    bfgs_g_tol=1e-8,           # Gradient tolerance\n    bfgs_f_abstol=1e-8,        # Function tolerance\n    tol_dist=0.025             # Clustering distance\n)","category":"section"},{"location":"core_algorithm/#Convergence-Tracking","page":"Core Algorithm","title":"Convergence Tracking","text":"The refinement process tracks:\n\nNumber of iterations required\nWhether optimization converged\nDistance from initial to refined point\nFunction value improvement","category":"section"},{"location":"core_algorithm/#Algorithm-Parameters","page":"Core Algorithm","title":"Algorithm Parameters","text":"","category":"section"},{"location":"core_algorithm/#Polynomial-Degree","page":"Core Algorithm","title":"Polynomial Degree","text":"Higher degrees improve approximation but increase cost:\n\nDegree 4-6: Fast, suitable for smooth functions\nDegree 8-10: Good balance for most problems  \nDegree 12+: High accuracy, computationally intensive","category":"section"},{"location":"core_algorithm/#Domain-Scaling","page":"Core Algorithm","title":"Domain Scaling","text":"The sample_range parameter controls the search domain:\n\n# Symmetric domain\nTR = TestInput(f, dim=2, center=[0,0], sample_range=1.0)\n\n# Asymmetric domain  \nTR = TestInput(f, dim=2, center=[0,0], sample_range=[2.0, 1.0])","category":"section"},{"location":"core_algorithm/#Tolerance-Settings","page":"Core Algorithm","title":"Tolerance Settings","text":"Key tolerances affecting results:\n\ntol_dist: Distance for clustering critical points (default: 0.025)\nbfgs_g_tol: Gradient tolerance for refinement (default: 1e-8)\nhessian_tol_zero: Zero eigenvalue threshold (default: 1e-8)","category":"section"},{"location":"core_algorithm/#Performance-Considerations","page":"Core Algorithm","title":"Performance Considerations","text":"","category":"section"},{"location":"core_algorithm/#Computational-Complexity","page":"Core Algorithm","title":"Computational Complexity","text":"Polynomial construction: O(n^d) where n = sample points per dimension, d = dimension\nSystem solving: Depends on number of critical points (exponential in dimension)\nRefinement: O(k × m) where k = critical points, m = BFGS iterations","category":"section"},{"location":"core_algorithm/#Memory-Usage","page":"Core Algorithm","title":"Memory Usage","text":"Polynomial storage: O(d^n) coefficients\nSolution storage: Proportional to number of critical points\nHessian analysis: Additional O(n²) per critical point","category":"section"},{"location":"core_algorithm/#Scalability-Tips","page":"Core Algorithm","title":"Scalability Tips","text":"Start with lower polynomial degrees\nUse appropriate domain bounds\nEnable parallel processing where available\nConsider dimension-adaptive strategies for high dimensions","category":"section"},{"location":"critical_point_analysis/#Critical-Point-Analysis","page":"Critical Point Analysis","title":"Critical Point Analysis","text":"","category":"section"},{"location":"critical_point_analysis/#Overview","page":"Critical Point Analysis","title":"Overview","text":"Critical point analysis is performed after the polynomial approximation step has identified candidate critical points by solving ∇p(x) = 0. These polynomial critical points are approximate locations that need to be refined and classified on the original objective function.\n\nThe analysis proceeds in two steps:\n\nRefinement: Each polynomial critical point serves as a starting point for local optimization (BFGS) on the original function f(x), converging to a true critical point\nClassification: The Hessian matrix at each refined point is computed using automatic differentiation (ForwardDiff.jl), and eigenvalue analysis determines whether the point is a minimum, maximum, saddle, or degenerate\n\nForwardDiff.jl provides efficient forward-mode automatic differentiation for computing exact gradients and Hessians without numerical approximation errors.\n\nNote: For comprehensive campaign analysis, statistical reporting, and result aggregation across multiple experiments, see GlobtimPostProcessing. The analyze_critical_points function documented here provides basic refinement and classification for individual experiments.","category":"section"},{"location":"critical_point_analysis/#Hessian-Based-Classification","page":"Critical Point Analysis","title":"Hessian-Based Classification","text":"The analyze_critical_points function computes the Hessian at each refined critical point and classifies it based on eigenvalue analysis:\n\ndf_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    enable_hessian=true,      # Enable classification\n    hessian_tol_zero=1e-8    # Zero eigenvalue tolerance\n)","category":"section"},{"location":"critical_point_analysis/#Classification-Types","page":"Critical Point Analysis","title":"Classification Types","text":"Critical points are classified based on Hessian eigenvalues:\n\n:minimum - All eigenvalues > hessian_tol_zero (positive definite)\n:maximum - All eigenvalues < -hessian_tol_zero (negative definite)\n:saddle - Mixed positive and negative eigenvalues\n:degenerate - At least one eigenvalue ≈ 0\n:error - Hessian computation failed","category":"section"},{"location":"critical_point_analysis/#Eigenvalue-Analysis","page":"Critical Point Analysis","title":"Eigenvalue Analysis","text":"For each critical point, the following metrics are computed:\n\n# Key eigenvalue metrics\ndf_enhanced.hessian_eigenvalue_min      # Smallest eigenvalue\ndf_enhanced.hessian_eigenvalue_max      # Largest eigenvalue\ndf_enhanced.hessian_condition_number    # κ(H) = |λ_max|/|λ_min|\ndf_enhanced.hessian_determinant         # det(H)\ndf_enhanced.hessian_trace              # tr(H)\ndf_enhanced.hessian_norm               # ||H||_F (Frobenius norm)","category":"section"},{"location":"critical_point_analysis/#Special-Eigenvalues","page":"Critical Point Analysis","title":"Special Eigenvalues","text":"For minima and maxima validation:\n\n# For minima: smallest positive eigenvalue\ndf_enhanced.smallest_positive_eigenval\n\n# For maxima: largest negative eigenvalue  \ndf_enhanced.largest_negative_eigenval","category":"section"},{"location":"critical_point_analysis/#Enhanced-Statistics","page":"Critical Point Analysis","title":"Enhanced Statistics","text":"Beyond Hessian analysis, additional statistics are computed:","category":"section"},{"location":"critical_point_analysis/#Spatial-Analysis","page":"Critical Point Analysis","title":"Spatial Analysis","text":"# Spatial clustering\ndf_enhanced.region_id                   # Spatial region assignment\ndf_enhanced.nearest_neighbor_dist       # Distance to nearest critical point\n\n# Function value clustering\ndf_enhanced.function_value_cluster      # Similar function values","category":"section"},{"location":"critical_point_analysis/#Convergence-Quality","page":"Critical Point Analysis","title":"Convergence Quality","text":"# Refinement metrics\ndf_enhanced.gradient_norm              # ||∇f|| at critical point\ndf_enhanced.steps                      # BFGS iterations used\ndf_enhanced.converged                  # Convergence success\ndf_enhanced.point_improvement          # ||x_refined - x_initial||\ndf_enhanced.value_improvement          # |f(x_refined) - f(x_initial)|","category":"section"},{"location":"critical_point_analysis/#Basin-Analysis","page":"Critical Point Analysis","title":"Basin Analysis","text":"For the unique minimizers in df_min:\n\n# Basin of attraction statistics\ndf_min.basin_points                    # Number of converging points\ndf_min.average_convergence_steps       # Mean BFGS iterations\ndf_min.region_coverage_count          # Spatial regions covered\ndf_min.gradient_norm_at_min          # Gradient verification","category":"section"},{"location":"critical_point_analysis/#Statistical-Tables","page":"Critical Point Analysis","title":"Statistical Tables","text":"Generate comprehensive reports with:\n\ndf_enhanced, df_min, tables, stats = analyze_critical_points_with_tables(\n    f, df, TR,\n    enable_hessian=true,\n    show_tables=true,\n    table_types=[:minimum, :saddle, :maximum]\n)","category":"section"},{"location":"critical_point_analysis/#Table-Contents","page":"Critical Point Analysis","title":"Table Contents","text":"Each table includes:\n\nPoint coordinates and function values\nEigenvalue statistics\nCondition numbers\nConvergence metrics\nDistance measurements","category":"section"},{"location":"critical_point_analysis/#Export-Options","page":"Critical Point Analysis","title":"Export Options","text":"# Export to different formats\nwrite_tables_to_csv(tables, \"results.csv\")\nwrite_tables_to_latex(tables, \"results.tex\")\nwrite_tables_to_markdown(tables, \"results.md\")","category":"section"},{"location":"critical_point_analysis/#Advanced-Options","page":"Critical Point Analysis","title":"Advanced Options","text":"","category":"section"},{"location":"critical_point_analysis/#Custom-Tolerances","page":"Critical Point Analysis","title":"Custom Tolerances","text":"Fine-tune the analysis with specific tolerances:\n\ndf_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    tol_dist=0.01,              # Tighter clustering\n    bfgs_g_tol=1e-10,          # Higher precision\n    bfgs_f_abstol=1e-12,       # Function tolerance\n    hessian_tol_zero=1e-10     # Eigenvalue threshold\n)","category":"section"},{"location":"critical_point_analysis/#Performance-Mode","page":"Critical Point Analysis","title":"Performance Mode","text":"For large problems, disable Hessian analysis:\n\n# Basic analysis only (faster)\ndf_basic, df_min = analyze_critical_points(\n    f, df, TR,\n    enable_hessian=false  # Skip eigenvalue computation\n)","category":"section"},{"location":"critical_point_analysis/#Verbose-Output","page":"Critical Point Analysis","title":"Verbose Output","text":"Track progress with detailed output:\n\ndf_enhanced, df_min = analyze_critical_points(\n    f, df, TR,\n    verbose=true  # Show progress messages\n)","category":"section"},{"location":"critical_point_analysis/#Interpreting-Results","page":"Critical Point Analysis","title":"Interpreting Results","text":"","category":"section"},{"location":"critical_point_analysis/#Quality-Indicators","page":"Critical Point Analysis","title":"Quality Indicators","text":"Good critical points typically have:\n\ngradient_norm < 1e-6\nconverged = true\nhessian_condition_number < 1e6\nConsistent classification between raw and refined points","category":"section"},{"location":"critical_point_analysis/#Warning-Signs","page":"Critical Point Analysis","title":"Warning Signs","text":"Potential issues indicated by:\n\nLarge point_improvement values (poor initial approximation)\ndegenerate classification (numerical instability)\nHigh condition numbers (ill-conditioned Hessian)\nFailed convergence within domain","category":"section"},{"location":"critical_point_analysis/#Basin-Structure","page":"Critical Point Analysis","title":"Basin Structure","text":"The df_min DataFrame reveals the optimization landscape:\n\nLarge basin_points: Strong attractor\nHigh region_coverage_count: Wide basin\nLow average_convergence_steps: Smooth basin","category":"section"},{"location":"globtimplots/#GlobtimPlots","page":"GlobtimPlots","title":"GlobtimPlots","text":"GlobtimPlots is Globtim's visualization layer - a Makie wrapper providing custom plotting functions for polynomial approximation and critical point analysis.\n\nRepository: github.com/gescholt/globtimplots","category":"section"},{"location":"globtimplots/#Installation","page":"GlobtimPlots","title":"Installation","text":"pkg> add GlobtimPlots","category":"section"},{"location":"globtimplots/#Package-Role","page":"GlobtimPlots","title":"Package Role","text":"GlobtimPlots provides visualization for the Globtim ecosystem:\n\nMakie wrapper - Uses CairoMakie/GLMakie as the backend for all plots\nGlobtim-specific - Provides plot recipes tailored to polynomial approximation workflows\nDepends on GlobtimPostProcessing for data types and analysis results\n\nPipeline: Globtim (experiments) → GlobtimPostProcessing (analysis) → GlobtimPlots (visualization)","category":"section"},{"location":"globtimplots/#Backend-Selection","page":"GlobtimPlots","title":"Backend Selection","text":"Backend Use Case Output\nCairoMakie Publication figures, batch processing, HPC PDF, PNG, SVG\nGLMakie Interactive exploration, presentations Window, animations\n\nusing GlobtimPlots\n\n# Static backend (recommended for publications)\nCairoMakie.activate!()\n\n# Interactive backend (for exploration)\n# using GLMakie\n# GLMakie.activate!()\n\nnote: Note\nGLMakie requires a display. Use CairoMakie on headless servers/HPC.","category":"section"},{"location":"globtimplots/#Basic-Workflow","page":"GlobtimPlots","title":"Basic Workflow","text":"using Globtim, DynamicPolynomials, GlobtimPlots\nCairoMakie.activate!()\n\n# 1. Run experiment\nf = Deuflhard\nTR = TestInput(f, dim=2, center=[0.0, 0.0], sample_range=1.2)\npol = Constructor(TR, 8)\n\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, pol)\ndf = process_crit_pts(solutions, f, TR)\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)\n\n# 2. Visualize\nfig = plot_critical_points(df_min)\nsave(\"critical_points.pdf\", fig)","category":"section"},{"location":"globtimplots/#Hessian-Analysis-Plots","page":"GlobtimPlots","title":"Hessian Analysis Plots","text":"","category":"section"},{"location":"globtimplots/#Hessian-Norms","page":"GlobtimPlots","title":"Hessian Norms","text":"Visualize the Frobenius norm of Hessian matrices:\n\nfig = plot_hessian_norms(df_enhanced)\nsave(\"hessian_norms.png\", fig)\n\nThis scatter plot shows ||H||_F for each critical point, colored by type (minimum, maximum, saddle).","category":"section"},{"location":"globtimplots/#Condition-Numbers","page":"GlobtimPlots","title":"Condition Numbers","text":"Analyze numerical stability:\n\nfig = plot_condition_numbers(df_enhanced)\n\nDisplays log-scale condition numbers κ(H) = |λmax|/|λmin|. High values indicate potential numerical issues.","category":"section"},{"location":"globtimplots/#Critical-Eigenvalues","page":"GlobtimPlots","title":"Critical Eigenvalues","text":"Validate minima and maxima:\n\nfig = plot_critical_eigenvalues(df_enhanced)\n\nShows:\n\nLeft: Smallest positive eigenvalues for minima\nRight: Largest negative eigenvalues for maxima","category":"section"},{"location":"globtimplots/#Eigenvalue-Spectrum","page":"GlobtimPlots","title":"Eigenvalue Spectrum","text":"","category":"section"},{"location":"globtimplots/#All-Eigenvalues","page":"GlobtimPlots","title":"All Eigenvalues","text":"Comprehensive eigenvalue visualization:\n\n# Sort by magnitude (preserves signs)\nfig1 = plot_all_eigenvalues(f, df_enhanced, sort_by=:magnitude)\n\n# Sort by absolute value\nfig2 = plot_all_eigenvalues(f, df_enhanced, sort_by=:abs_magnitude)\n\n# Sort by eigenvalue spread\nfig3 = plot_all_eigenvalues(f, df_enhanced, sort_by=:spread)\n\nFeatures:\n\nSeparate subplots for each critical point type\nVertical alignment with dotted connections\nColor coding by point index","category":"section"},{"location":"globtimplots/#Raw-vs-Refined-Comparison","page":"GlobtimPlots","title":"Raw vs Refined Comparison","text":"Compare eigenvalues before and after BFGS refinement:\n\n# Default: ordered by point distance\nfig = plot_raw_vs_refined_eigenvalues(f, df_raw, df_enhanced)\n\n# Order by function value difference\nfig = plot_raw_vs_refined_eigenvalues(f, df_raw, df_enhanced,\n                                     sort_by=:function_value_diff)\n\n# Order by eigenvalue norm difference\nfig = plot_raw_vs_refined_eigenvalues(f, df_raw, df_enhanced,\n                                     sort_by=:eigenvalue_diff)","category":"section"},{"location":"globtimplots/#Level-Sets-and-Convergence","page":"GlobtimPlots","title":"Level Sets & Convergence","text":"","category":"section"},{"location":"globtimplots/#Level-Set-Visualization","page":"GlobtimPlots","title":"Level Set Visualization","text":"create_level_set_visualization(pol, TR, solutions)  # 3D level set surface\nplot_polyapprox_levelset(pol, TR)                   # 2D contour plot\ncreate_level_set_animation(pol, TR, \"output.mp4\")   # Rotating animation","category":"section"},{"location":"globtimplots/#Convergence-Analysis","page":"GlobtimPlots","title":"Convergence Analysis","text":"degrees = [4, 6, 8, 10, 12]\nl2_errors = [Constructor(TR, d).nrm for d in degrees]\nfig = plot_convergence_analysis(degrees, l2_errors)\nsave(\"convergence.pdf\", fig)","category":"section"},{"location":"globtimplots/#Campaign-and-RL-Functions","page":"GlobtimPlots","title":"Campaign & RL Functions","text":"","category":"section"},{"location":"globtimplots/#Campaign-Comparison","page":"GlobtimPlots","title":"Campaign Comparison","text":"using GlobtimPostProcessing\n\ncampaign = load_campaign_results(\"hpc_results/\")\nfig = create_campaign_comparison_plot(campaign)\nsave(\"campaign_comparison.pdf\", fig)","category":"section"},{"location":"globtimplots/#RL-Training-(GlobTimRL)","page":"GlobtimPlots","title":"RL Training (GlobTimRL)","text":"plot_training_progress(metrics)                     # Loss/reward curves\ncreate_training_dashboard(metrics)                  # Full dashboard\nplot_action_ratio_evolution(history)                # Policy changes over time\nplot_state_action_heatmap(policy_data)              # State-action visualization","category":"section"},{"location":"globtimplots/#Other-Plots","page":"GlobtimPlots","title":"Other Plots","text":"plot_subdivision_tree(tree)                         # Adaptive refinement tree\nplot_1d_polynomial_approximation(f, pol, domain)    # 1D function + polynomial","category":"section"},{"location":"globtimplots/#Customization","page":"GlobtimPlots","title":"Customization","text":"","category":"section"},{"location":"globtimplots/#Color-Schemes","page":"GlobtimPlots","title":"Color Schemes","text":"All plots support custom color schemes:\n\nfig = plot_hessian_norms(df_enhanced,\n    colors=Dict(\n        :minimum => :blue,\n        :maximum => :red,\n        :saddle => :green,\n        :degenerate => :orange\n    )\n)","category":"section"},{"location":"globtimplots/#Figure-Properties","page":"GlobtimPlots","title":"Figure Properties","text":"Adjust figure size and resolution:\n\nfig = plot_condition_numbers(df_enhanced,\n    size=(800, 600),\n    fontsize=14,\n    markersize=10\n)","category":"section"},{"location":"globtimplots/#Combined-Visualizations","page":"GlobtimPlots","title":"Combined Visualizations","text":"Create multi-panel figures:\n\nfig = Figure(resolution=(1200, 800))\n\n# Hessian norms\nax1 = Axis(fig[1, 1], title=\"Hessian Norms\")\nplot_hessian_norms!(ax1, df_enhanced)\n\n# Condition numbers\nax2 = Axis(fig[1, 2], title=\"Condition Numbers\")\nplot_condition_numbers!(ax2, df_enhanced)\n\n# Critical eigenvalues\nax3 = Axis(fig[2, 1:2], title=\"Critical Eigenvalues\")\nplot_critical_eigenvalues!(ax3, df_enhanced)\n\nsave(\"combined_analysis.png\", fig)","category":"section"},{"location":"globtimplots/#Interactive-Features-(GLMakie)","page":"GlobtimPlots","title":"Interactive Features (GLMakie)","text":"When using GLMakie, plots become interactive:\n\nusing GLMakie\n\nfig = plot_all_eigenvalues(f, df_enhanced)\n# - Zoom with mouse wheel\n# - Pan by dragging\n# - Reset with double-click","category":"section"},{"location":"globtimplots/#Animation","page":"GlobtimPlots","title":"Animation","text":"Create animations showing eigenvalue evolution:\n\nusing GLMakie\n\n# Animate eigenvalue changes\npoints = Observable(1:10)\nfig = Figure()\nax = Axis(fig[1, 1])\n\non(points) do range\n    # Update plot based on point range\nend\n\n# Create animation\nrecord(fig, \"eigenvalue_evolution.mp4\", 1:nrow(df_enhanced)) do i\n    points[] = 1:i\nend","category":"section"},{"location":"globtimplots/#Export-Options","page":"GlobtimPlots","title":"Export Options","text":"All plotting functions return Makie Figure objects:\n\n# Vector formats (recommended for publications)\nsave(\"figure.pdf\", fig)\nsave(\"figure.svg\", fig)\n\n# Raster formats\nsave(\"figure.png\", fig)\n\n# High-DPI output\nsave(\"figure.png\", fig; px_per_unit=2)","category":"section"},{"location":"globtimplots/#Tips","page":"GlobtimPlots","title":"Tips","text":"","category":"section"},{"location":"globtimplots/#Large-Datasets","page":"GlobtimPlots","title":"Large Datasets","text":"For many critical points:\n\n# Filter to specific types\ndf_minima = filter(row -> row.critical_point_type == :minimum, df_enhanced)\nfig = plot_hessian_norms(df_minima)","category":"section"},{"location":"globtimplots/#Publication-Quality","page":"GlobtimPlots","title":"Publication Quality","text":"# Set theme for publication\nset_theme!(\n    fontsize=16,\n    resolution=(800, 600),\n    Axis=(\n        spinewidth=1.5,\n        xgridwidth=0.5,\n        ygridwidth=0.5\n    )\n)\n\nfig = plot_condition_numbers(df_enhanced)\nsave(\"publication_figure.pdf\", fig)\n\n# Reset theme\nset_theme!()","category":"section"},{"location":"globtimplots/#Quick-Reference","page":"GlobtimPlots","title":"Quick Reference","text":"Function Purpose\nplot_critical_points Critical point scatter plot\nplot_hessian_norms Hessian norm distribution\nplot_condition_numbers Condition number plot\nplot_critical_eigenvalues Eigenvalue spectrum\nplot_all_eigenvalues Full eigenvalue visualization\ncreate_level_set_visualization 3D level set surface\nplot_convergence_analysis L2 error convergence\ncreate_campaign_comparison_plot Multi-experiment comparison\ncreate_training_dashboard RL training metrics\nplot_subdivision_tree Adaptive refinement tree","category":"section"},{"location":"solvers/#Polynomial-System-Solvers","page":"Solvers","title":"Polynomial System Solvers","text":"Globtim uses polynomial system solvers to find critical points by solving ∇p(x) = 0. This guide covers the available solvers and how to choose between them.","category":"section"},{"location":"solvers/#Available-Solvers","page":"Solvers","title":"Available Solvers","text":"","category":"section"},{"location":"solvers/#HomotopyContinuation.jl-(Default)","page":"Solvers","title":"HomotopyContinuation.jl (Default)","text":"State of the art numerical algebraic geometry method.\n\nWebsite: https://www.juliahomotopycontinuation.org/\n\nsolutions = solve_polynomial_system(\n    x, n_dims, degree, coeffs,\n    solver=\"HC\"  # Default\n)","category":"section"},{"location":"solvers/#msolve","page":"Solvers","title":"msolve","text":"State of the art symbolic (exact) method, relies on Gröbner basis computations.\n\nWebsite: https://msolve.lip6.fr/\n\nsolutions = solve_polynomial_system(\n    x, n_dims, degree, coeffs,\n    solver=\"msolve\",\n    msolve_path=\"/path/to/msolve\"\n)\n\nNote: Requires external installation (see below).","category":"section"},{"location":"solvers/#Installing-Msolve","page":"Solvers","title":"Installing Msolve","text":"Download from: https://msolve.lip6.fr/\nBuild according to platform instructions\nAdd to PATH or specify path in function call","category":"section"},{"location":"solvers/#macOS/Linux","page":"Solvers","title":"macOS/Linux","text":"git clone https://github.com/algebraic-solving/msolve.git\ncd msolve\n./autogen.sh\n./configure\nmake\nsudo make install","category":"section"},{"location":"solvers/#Verification","page":"Solvers","title":"Verification","text":"msolve --help","category":"section"},{"location":"solvers/#Solver-Selection-Guidelines","page":"Solvers","title":"Solver Selection Guidelines","text":"","category":"section"},{"location":"solvers/#Use-HomotopyContinuation-when:","page":"Solvers","title":"Use HomotopyContinuation when:","text":"Working with smooth, well-conditioned problems\nNeed fast solutions for exploration\nDealing with higher dimensions (>4)\nNumerical accuracy is sufficient","category":"section"},{"location":"solvers/#Use-Msolve-when:","page":"Solvers","title":"Use Msolve when:","text":"Need exact verification of results\nWorking with rational coefficients\nDealing with degenerate or near-singular systems\nPublishing results requiring certainty","category":"section"},{"location":"solvers/#Example-Comparison","page":"Solvers","title":"Example Comparison","text":"using Globtim, DynamicPolynomials\n\n# Setup problem\nf = Deuflhard\nTR = TestInput(f, dim=2, center=[0,0], sample_range=1.2)\npol = Constructor(TR, 8)\n\n@polyvar x[1:2]\n\n# HomotopyContinuation (numerical)\n@time solutions_hc = solve_polynomial_system(\n    x, 2, 8, pol.coeffs,\n    solver=\"HC\"\n)\n\n# msolve (symbolic/exact)\n@time solutions_ms = solve_polynomial_system(\n    x, 2, 8, pol.coeffs,\n    solver=\"msolve\"\n)\n\n# Compare results\nprintln(\"HC found $(length(solutions_hc)) solutions\")\nprintln(\"Msolve found $(length(solutions_ms)) solutions\")","category":"section"},{"location":"solvers/#Advanced-Options","page":"Solvers","title":"Advanced Options","text":"","category":"section"},{"location":"solvers/#HomotopyContinuation-Parameters","page":"Solvers","title":"HomotopyContinuation Parameters","text":"Control solver behavior:\n\nsolutions = solve_polynomial_system(\n    x, n_dims, degree, coeffs,\n    solver=\"HC\",\n    hc_options=Dict(\n        :compile => false,      # Disable compilation for small problems\n        :threading => true,     # Enable parallel tracking\n        :tracker_options => TrackerOptions(\n            automatic_differentiation=2,  # AD order\n            refinement_accuracy=1e-12    # Target accuracy\n        )\n    )\n)","category":"section"},{"location":"solvers/#Msolve-Parameters","page":"Solvers","title":"Msolve Parameters","text":"Fine-tune exact solving:\n\nsolutions = solve_polynomial_system(\n    x, n_dims, degree, coeffs,\n    solver=\"msolve\",\n    msolve_options=Dict(\n        :precision => 128,      # Bit precision for intermediate computations\n        :threads => 4,          # Number of threads\n        :output_format => \"qq\"  # Rational output format\n    )\n)","category":"section"},{"location":"solvers/#Handling-Solver-Results","page":"Solvers","title":"Handling Solver Results","text":"Both solvers return solutions in a common format:\n\n# Process solutions\ndf = process_crit_pts(solutions, f, TR, solver=solver_name)\n\n# Check solution quality\nfor sol in solutions\n    grad_norm = norm(gradient(pol.polynomial, sol))\n    println(\"Solution: $sol, |∇p|: $grad_norm\")\nend","category":"section"},{"location":"solvers/#Related-Documentation","page":"Solvers","title":"Related Documentation","text":"Core Algorithm - Overall optimization approach\nPolynomial Approximation - Polynomial construction\nAPI Reference - Function documentation","category":"section"},{"location":"anisotropic_grid_tests/#Anisotropic-Grid-Tests-Detailed-Documentation","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Anisotropic Grid Tests - Detailed Documentation","text":"This document provides detailed documentation of the anisotropic grid test suite, explaining each test's purpose, methodology, and expected outcomes.","category":"section"},{"location":"anisotropic_grid_tests/#Test-File:-test/test_anisotropic_grids.jl","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test File: test/test_anisotropic_grids.jl","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Overview","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Overview","text":"The anisotropic grid test suite validates the implementation of grids with different numbers of points per dimension, a critical feature for efficiently approximating multiscale functions.","category":"section"},{"location":"anisotropic_grid_tests/#Test-Structure","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test Structure","text":"","category":"section"},{"location":"anisotropic_grid_tests/#1.-Basic-Anisotropic-Grid-Generation","page":"Anisotropic Grid Tests - Detailed Documentation","title":"1. Basic Anisotropic Grid Generation","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-2D-Anisotropic-Grid","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: 2D Anisotropic Grid","text":"grid_2d = generate_anisotropic_grid([3, 5], basis=:chebyshev)\n@test size(grid_2d) == (4, 6)  # 3+1, 5+1\n\nPurpose: Verify correct grid dimensions\nValidates: Grid has (n+1) points when n is specified\nExpected: 4×6 grid of SVector{2,Float64} points","category":"section"},{"location":"anisotropic_grid_tests/#Test:-3D-Anisotropic-Grid","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: 3D Anisotropic Grid","text":"grid_3d = generate_anisotropic_grid([2, 4, 3], basis=:legendre)\n@test size(grid_3d) == (3, 5, 4)\n\nPurpose: Test multi-dimensional grid generation\nValidates: Correct handling of 3D specifications\nExpected: 3×5×4 grid with Legendre nodes","category":"section"},{"location":"anisotropic_grid_tests/#Test:-High-Dimensional-Grid-(5D)","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: High-Dimensional Grid (5D)","text":"grid_5d = generate_anisotropic_grid([2, 3, 2, 4, 3], basis=:uniform)\n@test size(grid_5d) == (3, 4, 3, 5, 4)\n\nPurpose: Ensure scalability to high dimensions\nValidates: Memory efficiency and correctness in 5D\nExpected: Proper tensor product structure","category":"section"},{"location":"anisotropic_grid_tests/#2.-Grid-Properties-Tests","page":"Anisotropic Grid Tests - Detailed Documentation","title":"2. Grid Properties Tests","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Chebyshev-Node-Distribution","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: Chebyshev Node Distribution","text":"grid_cheb = generate_anisotropic_grid([5, 3], basis=:chebyshev)\nx_coords = unique([p[1] for p in grid_cheb])\n@test maximum(x_coords) < 1.0\n@test minimum(x_coords) > -1.0\n\nPurpose: Verify Chebyshev nodes cluster at boundaries\nKey Point: Chebyshev nodes use cos((2i+1)π/(2n+2)) formula\nExpected: Nodes strictly within (-1, 1)","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Uniform-Node-Spacing","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: Uniform Node Spacing","text":"grid_unif = generate_anisotropic_grid(n_points, basis=:uniform)\nspacings = diff(x_coords_unif)\n@test all(s -> isapprox(s, spacings[1], rtol=1e-10), spacings)\n\nPurpose: Verify uniform grids have equal spacing\nValidates: Correct implementation of linspace-like behavior\nExpected: All spacings identical to machine precision","category":"section"},{"location":"anisotropic_grid_tests/#3.-L2-Norm-Computation-Quadrature-Method","page":"Anisotropic Grid Tests - Detailed Documentation","title":"3. L2 Norm Computation - Quadrature Method","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Separable-Polynomial-Function","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: Separable Polynomial Function","text":"f_sep = x -> x[1]^2\nl2_aniso = compute_l2_norm_quadrature(f_sep, [10, 3], :chebyshev)\n@test isapprox(l2_aniso, 2/sqrt(5), rtol=1e-12)\n\nMathematical Background: \nFunction: f(x,y) = x²\nL2 norm: √(∫∫ x⁴ dxdy) over [-1,1]²\nAnalytical value: 2/√5\nPurpose: Validate exact quadrature for polynomials\nKey Point: Tests tensor product quadrature accuracy","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Multiscale-Function-Efficiency","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: Multiscale Function Efficiency","text":"f_aniso = x -> exp(-10*x[1]^2 - x[2]^2)\nl2_iso = compute_l2_norm_quadrature(f_aniso, [7, 7], :chebyshev)  # 49 points\nl2_aniso_smart = compute_l2_norm_quadrature(f_aniso, [10, 5], :chebyshev)  # 50 points\n@test abs(l2_iso - l2_aniso_smart) / l2_iso < 0.1\n\nPurpose: Demonstrate anisotropic advantage\nFunction characteristics: Rapid variation in x, slow in y\nExpected: Similar accuracy with different point allocations","category":"section"},{"location":"anisotropic_grid_tests/#4.-L2-Norm-Computation-Riemann-Method","page":"Anisotropic Grid Tests - Detailed Documentation","title":"4. L2 Norm Computation - Riemann Method","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Riemann-Sum-on-Anisotropic-Grid","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: Riemann Sum on Anisotropic Grid","text":"grid = generate_anisotropic_grid([15, 8], basis=:chebyshev)\nl2_riemann = discrete_l2_norm_riemann(f_test, grid)\nl2_quad = compute_l2_norm_quadrature(f_test, [15, 8], :chebyshev)\n@test abs(l2_riemann - l2_quad) / l2_quad < 0.05\n\nPurpose: Validate Riemann sum handles anisotropic grids\nMethod: Constructs cell volumes from point spacing\nExpected: Agreement within 5% of quadrature method","category":"section"},{"location":"anisotropic_grid_tests/#5.-Optimal-Anisotropic-Grid-Performance","page":"Anisotropic Grid Tests - Detailed Documentation","title":"5. Optimal Anisotropic Grid Performance","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Multiscale-Function-with-Large-Scale-Separation","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: Multiscale Function with Large Scale Separation","text":"f_multiscale = x -> exp(-100*x[1]^2 - x[2]^2)\n# Isotropic: 15×15 = 225 points\n# Anisotropic: 25×9 = 225 points\n@test error_aniso < error_iso\n\nPurpose: Quantify improvement for multiscale problems\nKey Result: Typically 10-15x error reduction\nPrinciple: Allocate points based on directional variation","category":"section"},{"location":"anisotropic_grid_tests/#6.-High-Dimensional-Anisotropic-Grids","page":"Anisotropic Grid Tests - Detailed Documentation","title":"6. High-Dimensional Anisotropic Grids","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-4D-Function-with-Varying-Scales","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: 4D Function with Varying Scales","text":"f_4d = x -> exp(-sum(i*x[i]^2 for i in 1:4))\ngrid_sizes = [10, 8, 6, 4]  # Decreasing resolution\n\nPurpose: Test curse of dimensionality mitigation\nStrategy: Fewer points in smoother directions\nValidates: Tensor product structure in 4D","category":"section"},{"location":"anisotropic_grid_tests/#7.-Utility-Function-Tests","page":"Anisotropic Grid Tests - Detailed Documentation","title":"7. Utility Function Tests","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Grid-Dimension-Extraction","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: Grid Dimension Extraction","text":"dims = get_grid_dimensions(grid)\n@test dims == [4, 6, 3]  # For a [3, 5, 2] input\n\nPurpose: Extract actual grid sizes\nUse case: Generic algorithms needing grid info","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Anisotropy-Detection","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: Anisotropy Detection","text":"@test is_anisotropic(aniso_grid) == true\n@test is_anisotropic(iso_grid) == false\n\nPurpose: Distinguish grid types\nApplication: Algorithm selection based on grid type","category":"section"},{"location":"anisotropic_grid_tests/#8.-Backward-Compatibility","page":"Anisotropic Grid Tests - Detailed Documentation","title":"8. Backward Compatibility","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Test:-Legacy-Interface-Support","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test: Legacy Interface Support","text":"grid_old = generate_grid(2, 5, basis=:chebyshev)\ngrid_new = generate_anisotropic_grid([5, 5], basis=:chebyshev)\n@test grid_old == grid_new\n\nPurpose: Ensure old code continues working\nValidates: Seamless migration path","category":"section"},{"location":"anisotropic_grid_tests/#Performance-Demonstration","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Performance Demonstration","text":"The test suite includes a demonstration function showing real-world benefits:\n\nfunction demonstrate_anisotropic_benefits()\n    f = x -> exp(-50*x[1]^2 - 2*x[2]^2)\n    # Shows 15x error reduction for anisotropic vs isotropic\nend","category":"section"},{"location":"anisotropic_grid_tests/#Key-Results:","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Key Results:","text":"Isotropic 20×20 (400 points): Error ~1e-3\nAnisotropic 50×8 (400 points): Error ~6e-5\nImprovement: 15x accuracy gain","category":"section"},{"location":"anisotropic_grid_tests/#Common-Test-Patterns","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Common Test Patterns","text":"","category":"section"},{"location":"anisotropic_grid_tests/#1.-Analytical-Validation","page":"Anisotropic Grid Tests - Detailed Documentation","title":"1. Analytical Validation","text":"Use functions with known L2 norms\nTest polynomial exactness\nVerify error bounds","category":"section"},{"location":"anisotropic_grid_tests/#2.-Comparative-Testing","page":"Anisotropic Grid Tests - Detailed Documentation","title":"2. Comparative Testing","text":"Compare methods (quadrature vs Riemann)\nCompare grids (isotropic vs anisotropic)\nBenchmark performance","category":"section"},{"location":"anisotropic_grid_tests/#3.-Edge-Cases","page":"Anisotropic Grid Tests - Detailed Documentation","title":"3. Edge Cases","text":"Single point per dimension\nVery high dimensions\nExtreme anisotropy ratios","category":"section"},{"location":"anisotropic_grid_tests/#Debugging-Test-Failures","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Debugging Test Failures","text":"","category":"section"},{"location":"anisotropic_grid_tests/#Common-Issues:","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Common Issues:","text":"Boundary Expectations\nChebyshev nodes don't reach ±1 exactly\nTest for strict inequalities\nAnalytical Values\nDouble-check integral calculations\nConsider domain normalization\nDimension Ordering\nJulia uses column-major ordering\nGrid dimensions may appear transposed\nFunction Passing\nEnsure functions accept SVector arguments\nCheck closure variable capture","category":"section"},{"location":"anisotropic_grid_tests/#Test-Coverage-Metrics","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Test Coverage Metrics","text":"Current coverage:\n\n✓ Grid generation (all bases)\n✓ L2 norm computation (both methods)\n✓ Dimension handling (1D to 5D)\n✓ Performance validation\n✓ Backward compatibility\n✓ Utility functions","category":"section"},{"location":"anisotropic_grid_tests/#Future-Test-Additions","page":"Anisotropic Grid Tests - Detailed Documentation","title":"Future Test Additions","text":"Potential expansions:\n\nAdaptive anisotropic refinement\nOptimal grid size selection\nIntegration with sparsification\nGPU acceleration tests\nParallel computation validation","category":"section"},{"location":"precision_parameters/#Precision-Parameters","page":"Precision","title":"Precision Parameters","text":"Globtim serves as an interface between numeric and symbolic computation. The polynomial approximation pipeline involves multiple stages - sampling, coefficient computation, basis conversion, and critical point solving - each benefiting from different precision strategies.","category":"section"},{"location":"precision_parameters/#Overview","page":"Precision","title":"Overview","text":"A key feature of Globtim is exploring which precision types work best at each stage of the algorithm. The goal is to remain efficient and fast while maintaining accuracy where it matters most.\n\nGlobtim supports multiple precision types through the precision parameter in the Constructor function:\n\n# Basic syntax\npol = Constructor(TR, degree, precision=PrecisionType)","category":"section"},{"location":"precision_parameters/#Available-Precision-Types","page":"Precision","title":"Available Precision Types","text":"","category":"section"},{"location":"precision_parameters/#Float64Precision","page":"Precision","title":"Float64Precision","text":"Standard double-precision floating-point arithmetic\n\nThe default numeric type in Julia. Fast and memory-efficient, suitable for most stages of the pipeline where machine precision is sufficient.\n\npol = Constructor(TR, 8, precision=Float64Precision)\nprintln(\"Coefficient type: $(eltype(pol.coeffs))\")  # Float64\n\nCharacteristics:\n\nUses IEEE 754 double precision (~15-16 decimal digits)\nFastest computation and lowest memory usage\nStandard choice for most applications\nMay accumulate numerical errors in high-degree polynomials","category":"section"},{"location":"precision_parameters/#AdaptivePrecision","page":"Precision","title":"AdaptivePrecision","text":"Hybrid approach: Float64 for evaluation, BigFloat for coefficient manipulation\n\nUses numeric precision where speed matters (function sampling) and extended precision where accuracy matters (coefficient computation and basis conversion). This reflects Globtim's role as a numeric/symbolic interface.\n\npol = Constructor(TR, 8, precision=AdaptivePrecision)\nprintln(\"Raw coefficients: $(eltype(pol.coeffs))\")  # Float64\n\n# Extended precision in monomial expansion\n@polyvar x[1:2]\nmono_poly = to_exact_monomial_basis(pol, variables=x)\ncoeffs = [coefficient(t) for t in terms(mono_poly)]\nprintln(\"Monomial coefficients: $(typeof(coeffs[1]))\")  # BigFloat\n\nKey Features:\n\nFunction evaluation stays Float64 (fast sampling)\nCoefficient manipulation uses BigFloat (accurate)\nSeamless integration with sparsification\nAutomatic precision selection based on coefficient magnitude\nOptimal for high-dimensional problems","category":"section"},{"location":"precision_parameters/#RationalPrecision","page":"Precision","title":"RationalPrecision","text":"Exact rational arithmetic with arbitrary precision\n\nFully symbolic computation using Rational{BigInt}. Enables exact polynomial representations with no rounding errors, at the cost of computational overhead.\n\npol = Constructor(TR, 8, precision=RationalPrecision)\nprintln(\"Coefficient type: $(eltype(pol.coeffs))\")  # Rational{BigInt}\n\nCharacteristics:\n\nUses Rational{BigInt} for exact representations\nNo rounding errors in coefficient computation\nCan represent exact polynomial coefficients\nMemory and computation intensive\nIdeal for problems requiring exact solutions","category":"section"},{"location":"precision_parameters/#BigFloatPrecision","page":"Precision","title":"BigFloatPrecision","text":"Extended precision floating-point throughout\n\nUses BigFloat (configurable precision, default 256 bits) at all stages. Provides maximum numeric precision when needed for validation or ill-conditioned problems.\n\npol = Constructor(TR, 8, precision=BigFloatPrecision)\nprintln(\"Coefficient type: $(eltype(pol.coeffs))\")  # BigFloat\n\nCharacteristics:\n\nUses BigFloat throughout the computation\nConfigurable precision (default: 256 bits)\nHighest numerical accuracy available\nSignificant performance and memory overhead\nUse only when maximum precision is essential","category":"section"},{"location":"precision_parameters/#Performance-Comparison","page":"Precision","title":"Performance Comparison","text":"","category":"section"},{"location":"precision_parameters/#Computational-Cost","page":"Precision","title":"Computational Cost","text":"Precision Type Constructor Time Memory Usage Coefficient Access\nFloat64Precision 1.0× (baseline) 1.0× Fastest\nAdaptivePrecision 1.2× 1.5× Fast\nRationalPrecision 5-10× 3-5× Slow\nBigFloatPrecision 3-8× 2-4× Moderate","category":"section"},{"location":"precision_parameters/#Accuracy-Comparison","page":"Precision","title":"Accuracy Comparison","text":"# Test function with known exact representation\nf_exact = x -> x[1]^2 + x[2]^2\nTR = TestInput(f_exact, dim=2, center=[0.0, 0.0], sample_range=1.0)\n\n# Compare approximation errors\nprecisions = [Float64Precision, AdaptivePrecision, RationalPrecision, BigFloatPrecision]\nfor prec in precisions\n    pol = Constructor(TR, 2, precision=prec)\n    println(\"$(prec): L2-norm = $(pol.nrm)\")\nend\n\nExpected output:\n\nFloat64Precision: L2-norm = 1.2e-15\nAdaptivePrecision: L2-norm = 2.3e-16\nRationalPrecision: L2-norm = 0.0\nBigFloatPrecision: L2-norm = 1.1e-77","category":"section"},{"location":"precision_parameters/#Integration-with-Sparsification","page":"Precision","title":"Integration with Sparsification","text":"AdaptivePrecision provides the best integration with Globtim's sparsification features:","category":"section"},{"location":"precision_parameters/#Coefficient-Analysis","page":"Precision","title":"Coefficient Analysis","text":"# Create polynomial with AdaptivePrecision\npol = Constructor(TR, 10, precision=AdaptivePrecision)\n\n# Convert to monomial basis\n@polyvar x[1:2]\nmono_poly = to_exact_monomial_basis(pol, variables=x)\n\n# Analyze coefficient distribution\nanalysis = analyze_coefficient_distribution(mono_poly)\nprintln(\"Analysis results:\")\nprintln(\"  Total terms: $(analysis.n_total)\")\nprintln(\"  Max coefficient: $(analysis.max_coefficient)\")\nprintln(\"  Min coefficient: $(analysis.min_coefficient)\")\nprintln(\"  Dynamic range: $(analysis.dynamic_range)\")\nprintln(\"  Suggested thresholds: $(analysis.suggested_thresholds)\")","category":"section"},{"location":"precision_parameters/#Adaptive-Truncation","page":"Precision","title":"Adaptive Truncation","text":"# Apply smart truncation\nthreshold = analysis.suggested_thresholds[1]\ntruncated_poly, stats = truncate_polynomial_adaptive(mono_poly, threshold)\n\nprintln(\"Truncation results:\")\nprintln(\"  Original terms: $(stats.n_total)\")\nprintln(\"  Kept terms: $(stats.n_kept)\")\nprintln(\"  Removed terms: $(stats.n_removed)\")\nprintln(\"  Sparsity ratio: $(round(stats.sparsity_ratio*100, digits=1))%\")","category":"section"},{"location":"precision_parameters/#Sparsification-Workflow","page":"Precision","title":"Sparsification Workflow","text":"# Complete sparsification workflow with AdaptivePrecision\nfunction sparsify_with_adaptive_precision(f, TR, degree, threshold_factor=0.1)\n    # Step 1: Create polynomial with AdaptivePrecision\n    pol = Constructor(TR, degree, precision=AdaptivePrecision)\n    \n    # Step 2: Convert to monomial basis\n    @polyvar x[1:length(TR.center)]\n    mono_poly = to_exact_monomial_basis(pol, variables=x)\n    \n    # Step 3: Analyze coefficients\n    analysis = analyze_coefficient_distribution(mono_poly)\n    \n    # Step 4: Apply adaptive truncation\n    threshold = analysis.suggested_thresholds[1] * threshold_factor\n    truncated_poly, stats = truncate_polynomial_adaptive(mono_poly, threshold)\n    \n    return (\n        original=mono_poly,\n        truncated=truncated_poly,\n        analysis=analysis,\n        stats=stats\n    )\nend\n\n# Usage example\nresult = sparsify_with_adaptive_precision(Deuflhard, TR, 8)\nprintln(\"Achieved $(round(result.stats.sparsity_ratio*100, digits=1))% sparsity\")","category":"section"},{"location":"precision_parameters/#Use-Case-Guidelines","page":"Precision","title":"Use Case Guidelines","text":"","category":"section"},{"location":"precision_parameters/#When-to-Use-Each-Precision-Type","page":"Precision","title":"When to Use Each Precision Type","text":"","category":"section"},{"location":"precision_parameters/#Float64Precision-2","page":"Precision","title":"Float64Precision","text":"General optimization problems\nProduction workflows requiring speed\nBatch processing on HPC clusters\nPreliminary analysis and prototyping\n\n# Fast batch processing\nresults = []\nfor degree in 4:2:12\n    pol = Constructor(TR, degree, precision=Float64Precision)\n    push!(results, (degree=degree, error=pol.nrm))\nend","category":"section"},{"location":"precision_parameters/#AdaptivePrecision-2","page":"Precision","title":"AdaptivePrecision","text":"High-dimensional problems (dim ≥ 4)\nExtended precision requirements\nResearch applications needing accuracy\nProblems with coefficient truncation\n\n# High-dimensional optimization\nf_6d = x -> sum(x.^2) + 0.1*prod(sin.(π*x))\nTR_6d = TestInput(f_6d, dim=6, center=zeros(6), sample_range=1.0)\npol_6d = Constructor(TR_6d, 4, precision=AdaptivePrecision)","category":"section"},{"location":"precision_parameters/#RationalPrecision-2","page":"Precision","title":"RationalPrecision","text":"Exact polynomial representations\nSymbolic computation integration\nMathematical research requiring exactness\nSmall-scale problems where speed is not critical\n\n# Exact representation of polynomial functions\nf_poly = x -> 2*x[1]^3 - x[1]^2 + 3*x[2]^2 - 1\npol_exact = Constructor(TR, 3, precision=RationalPrecision)\n# Should give exactly zero approximation error","category":"section"},{"location":"precision_parameters/#BigFloatPrecision-2","page":"Precision","title":"BigFloatPrecision","text":"Maximum precision requirements\nIll-conditioned problems\nResearch requiring extended precision\nValidation of other precision types\n\n# Maximum precision for validation\npol_reference = Constructor(TR, 12, precision=BigFloatPrecision)","category":"section"},{"location":"precision_parameters/#High-Dimensional-Considerations","page":"Precision","title":"High-Dimensional Considerations","text":"","category":"section"},{"location":"precision_parameters/#Memory-Scaling","page":"Precision","title":"Memory Scaling","text":"Polynomial coefficient count grows as C(n+d, d) where n is dimension and d is degree:\n\nDimension Degree 4 Degree 6 Degree 8 Degree 10\n2D 15 28 45 66\n4D 70 210 495 1001\n6D 210 924 3003 8008\n8D 495 3003 12870 43758","category":"section"},{"location":"precision_parameters/#Precision-Recommendations-by-Dimension","page":"Precision","title":"Precision Recommendations by Dimension","text":"function get_recommended_precision(dim, degree)\n    coeff_count = binomial(dim + degree, degree)\n\n    if coeff_count < 100\n        return Float64Precision  # Small problems\n    elseif coeff_count < 1000\n        return AdaptivePrecision  # Medium problems\n    elseif coeff_count < 10000\n        return AdaptivePrecision  # Large problems (with truncation)\n    else\n        @warn \"Very large problem ($(coeff_count) coefficients). Consider reducing degree.\"\n        return AdaptivePrecision\n    end\nend\n\n# Usage\nrecommended = get_recommended_precision(6, 8)\npol = Constructor(TR, 8, precision=recommended)","category":"section"},{"location":"precision_parameters/#High-Dimensional-Example","page":"Precision","title":"High-Dimensional Example","text":"# 8D optimization with precision management\nfunction optimize_8d_with_precision()\n    # Define 8D test function\n    f_8d = x -> sum(x.^2) + 0.1*sum(sin.(5*π*x)) + 0.01*prod(x[1:4])\n    TR_8d = TestInput(f_8d, dim=8, center=zeros(8), sample_range=1.0)\n\n    # Use AdaptivePrecision for accuracy\n    println(\"Creating 8D polynomial with AdaptivePrecision...\")\n    pol_8d = Constructor(TR_8d, 4, precision=AdaptivePrecision, verbose=1)\n\n    # Apply sparsification to manage complexity\n    @polyvar x[1:8]\n    mono_poly = to_exact_monomial_basis(pol_8d, variables=x)\n\n    # Analyze and truncate\n    analysis = analyze_coefficient_distribution(mono_poly)\n    threshold = analysis.suggested_thresholds[2]  # More aggressive truncation\n    truncated_poly, stats = truncate_polynomial_adaptive(mono_poly, threshold)\n\n    println(\"8D Results:\")\n    println(\"  Original L2-norm: $(pol_8d.nrm)\")\n    println(\"  Coefficient count: $(analysis.n_total)\")\n    println(\"  After truncation: $(stats.n_kept) terms ($(round(stats.sparsity_ratio*100))% sparse)\")\n\n    return truncated_poly\nend","category":"section"},{"location":"precision_parameters/#HPC-Cluster-Optimization","page":"Precision","title":"HPC Cluster Optimization","text":"","category":"section"},{"location":"precision_parameters/#Resource-Requirements","page":"Precision","title":"Resource Requirements","text":"Different precision types have different computational and memory requirements on HPC systems:\n\n# HPC resource estimation\nfunction estimate_hpc_resources(dim, degree, precision_type)\n    coeff_count = binomial(dim + degree, degree)\n\n    # Base memory requirements (MB)\n    base_memory = if precision_type == Float64Precision\n        coeff_count * 8 / 1024^2  # 8 bytes per Float64\n    elseif precision_type == AdaptivePrecision\n        coeff_count * 16 / 1024^2  # ~16 bytes average\n    elseif precision_type == RationalPrecision\n        coeff_count * 64 / 1024^2  # ~64 bytes per Rational{BigInt}\n    elseif precision_type == BigFloatPrecision\n        coeff_count * 32 / 1024^2  # ~32 bytes per BigFloat\n    end\n\n    # Add overhead for computation\n    total_memory = base_memory * 5  # 5x overhead for computation\n\n    # Estimate computation time multiplier\n    time_multiplier = if precision_type == Float64Precision\n        1.0\n    elseif precision_type == AdaptivePrecision\n        1.5\n    elseif precision_type == RationalPrecision\n        8.0\n    elseif precision_type == BigFloatPrecision\n        4.0\n    end\n\n    return (\n        memory_mb = total_memory,\n        time_multiplier = time_multiplier,\n        coefficient_count = coeff_count\n    )\nend\n\n# Example usage\nresources = estimate_hpc_resources(4, 8, AdaptivePrecision)\nprintln(\"Estimated resources for 4D degree-8 with AdaptivePrecision:\")\nprintln(\"  Memory: $(round(resources.memory_mb, digits=1)) MB\")\nprintln(\"  Time multiplier: $(resources.time_multiplier)×\")","category":"section"},{"location":"precision_parameters/#HPC-Configuration-Examples","page":"Precision","title":"HPC Configuration Examples","text":"# HPC-optimized configurations for different problem sizes\n\n# Small problems (< 1000 coefficients)\nfunction hpc_small_config(TR, degree)\n    return Constructor(TR, degree,\n        precision=Float64Precision,  # Fast execution\n        basis=:chebyshev,           # Stable basis\n        verbose=0                   # Minimal output\n    )\nend\n\n# Medium problems (1000-10000 coefficients)\nfunction hpc_medium_config(TR, degree)\n    return Constructor(TR, degree,\n        precision=AdaptivePrecision,  # Good accuracy/speed balance\n        basis=:chebyshev,\n        verbose=0\n    )\nend\n\n# Large problems (> 10000 coefficients)\nfunction hpc_large_config(TR, degree)\n    pol = Constructor(TR, degree,\n        precision=AdaptivePrecision,\n        basis=:chebyshev,\n        verbose=0\n    )\n\n    # Apply aggressive sparsification for large problems\n    @polyvar x[1:length(TR.center)]\n    mono_poly = to_exact_monomial_basis(pol, variables=x)\n    analysis = analyze_coefficient_distribution(mono_poly)\n\n    # Use more aggressive threshold for large problems\n    threshold = analysis.suggested_thresholds[3]  # More aggressive\n    truncated_poly, stats = truncate_polynomial_adaptive(mono_poly, threshold)\n\n    println(\"Large problem sparsification: $(round(stats.sparsity_ratio*100))% sparse\")\n    return truncated_poly\nend","category":"section"},{"location":"precision_parameters/#Advanced-Usage-Patterns","page":"Precision","title":"Advanced Usage Patterns","text":"","category":"section"},{"location":"precision_parameters/#Precision-Conversion","page":"Precision","title":"Precision Conversion","text":"# Convert between precision types\nfunction convert_precision(pol_source, target_precision)\n    # Extract problem specification\n    TR = pol_source.TestInput  # If available\n    degree = pol_source.degree  # If available\n\n    # Recreate with target precision\n    pol_target = Constructor(TR, degree, precision=target_precision)\n\n    return pol_target\nend\n\n# Compare precisions on same problem\nfunction compare_precisions(TR, degree)\n    precisions = [Float64Precision, AdaptivePrecision, RationalPrecision]\n    results = Dict()\n\n    for prec in precisions\n        @time pol = Constructor(TR, degree, precision=prec)\n        results[prec] = (\n            l2_norm = pol.nrm,\n            coeff_type = eltype(pol.coeffs),\n            memory_estimate = sizeof(pol.coeffs)\n        )\n    end\n\n    return results\nend","category":"section"},{"location":"precision_parameters/#Precision-Aware-Workflows","page":"Precision","title":"Precision-Aware Workflows","text":"# Adaptive precision selection based on problem characteristics\nfunction smart_precision_selection(f, dim, degree, sample_range)\n    TR = TestInput(f, dim=dim, center=zeros(dim), sample_range=sample_range)\n\n    # Quick Float64 test to assess problem difficulty\n    pol_test = Constructor(TR, min(degree, 4), precision=Float64Precision, verbose=0)\n\n    # Decision logic based on approximation quality\n    if pol_test.nrm < 1e-12\n        # Very good approximation - Float64 sufficient\n        precision = Float64Precision\n        println(\"Selected Float64Precision (excellent approximation)\")\n    elseif pol_test.nrm < 1e-8\n        # Good approximation - AdaptivePrecision for safety\n        precision = AdaptivePrecision\n        println(\"Selected AdaptivePrecision (good approximation)\")\n    else\n        # Poor approximation - need higher precision\n        precision = AdaptivePrecision\n        println(\"Selected AdaptivePrecision (challenging problem)\")\n    end\n\n    # Create final polynomial with selected precision\n    pol_final = Constructor(TR, degree, precision=precision, verbose=0)\n\n    return pol_final\nend\n\n# Usage example\npol = smart_precision_selection(Deuflhard, 2, 8, 1.2)","category":"section"},{"location":"precision_parameters/#Best-Practices","page":"Precision","title":"Best Practices","text":"","category":"section"},{"location":"precision_parameters/#1.-Start-with-AdaptivePrecision","page":"Precision","title":"1. Start with AdaptivePrecision","text":"For most applications, AdaptivePrecision provides the best balance:\n\n# Recommended default approach\npol = Constructor(TR, degree, precision=AdaptivePrecision)","category":"section"},{"location":"precision_parameters/#2.-Use-Float64Precision-for-Batch-Processing","page":"Precision","title":"2. Use Float64Precision for Batch Processing","text":"When processing many problems where speed matters:\n\n# Batch processing example\nfunction batch_optimize(functions, degrees)\n    results = []\n    for (f, deg) in zip(functions, degrees)\n        TR = TestInput(f, dim=2, center=[0.0, 0.0], sample_range=1.0)\n        pol = Constructor(TR, deg, precision=Float64Precision)  # Fast\n        push!(results, pol.nrm)\n    end\n    return results\nend","category":"section"},{"location":"precision_parameters/#3.-Apply-Sparsification-with-AdaptivePrecision","page":"Precision","title":"3. Apply Sparsification with AdaptivePrecision","text":"Combine precision and sparsification for optimal results:\n\n# Best practice workflow\nfunction optimal_workflow(f, dim, degree)\n    TR = TestInput(f, dim=dim, center=zeros(dim), sample_range=1.0)\n\n    # Step 1: Create with AdaptivePrecision\n    pol = Constructor(TR, degree, precision=AdaptivePrecision)\n\n    # Step 2: Apply sparsification\n    @polyvar x[1:dim]\n    mono_poly = to_exact_monomial_basis(pol, variables=x)\n    analysis = analyze_coefficient_distribution(mono_poly)\n\n    # Step 3: Truncate if beneficial\n    if analysis.dynamic_range > 1e6  # Large dynamic range\n        threshold = analysis.suggested_thresholds[1]\n        truncated_poly, stats = truncate_polynomial_adaptive(mono_poly, threshold)\n        println(\"Applied truncation: $(stats.n_kept)/$(stats.n_total) terms kept\")\n        return truncated_poly\n    else\n        return mono_poly\n    end\nend","category":"section"},{"location":"precision_parameters/#4.-Monitor-Resource-Usage","page":"Precision","title":"4. Monitor Resource Usage","text":"Always be aware of computational costs:\n\n# Resource-aware construction\nfunction monitored_constructor(TR, degree, precision_type)\n    println(\"Creating polynomial: $(precision_type), degree $(degree)\")\n\n    # Estimate resources\n    dim = length(TR.center)\n    resources = estimate_hpc_resources(dim, degree, precision_type)\n    println(\"Estimated memory: $(round(resources.memory_mb, digits=1)) MB\")\n\n    # Time the construction\n    @time pol = Constructor(TR, degree, precision=precision_type)\n\n    println(\"Actual L2-norm: $(pol.nrm)\")\n    return pol\nend","category":"section"},{"location":"precision_parameters/#Summary","page":"Precision","title":"Summary","text":"Precision Type Numeric/Symbolic Use Case\nFloat64Precision Numeric Fast batch processing, production workflows\nAdaptivePrecision Hybrid High-dimensional problems, coefficient analysis\nRationalPrecision Symbolic Exact arithmetic, symbolic computation\nBigFloatPrecision Extended Numeric Maximum precision validation\n\nThe precision parameter system reflects Globtim's role as a numeric/symbolic interface, allowing you to choose the right precision strategy for each stage of your computation.","category":"section"},{"location":"polynomial_approximation/#Polynomial-Approximation","page":"Polynomial Approximation","title":"Polynomial Approximation","text":"This guide covers the polynomial approximation methods used in Globtim, including basis functions, L2-norm computation, and post-processing techniques.","category":"section"},{"location":"polynomial_approximation/#Overview","page":"Polynomial Approximation","title":"Overview","text":"Globtim uses orthogonal polynomial bases (Chebyshev or Legendre) to approximate objective functions over compact domains. This approach provides:\n\nStable numerical computation\nOptimal convergence for smooth functions\nEfficient critical point finding via polynomial system solving","category":"section"},{"location":"polynomial_approximation/#Basis-Functions","page":"Polynomial Approximation","title":"Basis Functions","text":"","category":"section"},{"location":"polynomial_approximation/#Chebyshev-Polynomials","page":"Polynomial Approximation","title":"Chebyshev Polynomials","text":"Default choice for most problems:\n\npol = Constructor(TR, degree, basis=:chebyshev)\n\nAdvantages:\n\nNear-optimal approximation for continuous functions\nExtrema at grid boundaries minimize Runge phenomenon\nFast convergence for smooth functions\n\nGrid points: Chebyshev extrema at cos(πk/n) for k=0,...,n","category":"section"},{"location":"polynomial_approximation/#Legendre-Polynomials","page":"Polynomial Approximation","title":"Legendre Polynomials","text":"Alternative basis with different properties:\n\npol = Constructor(TR, degree, basis=:legendre)\n\nAdvantages:\n\nOrthogonal with respect to uniform weight\nSometimes better for functions with boundary singularities\nNatural for probability-weighted problems\n\nGrid points: Zeros of Legendre polynomials","category":"section"},{"location":"polynomial_approximation/#L2-Norm-Computation","page":"Polynomial Approximation","title":"L2-Norm Computation","text":"The L2-norm measures approximation quality and is used throughout Globtim for error tracking.","category":"section"},{"location":"polynomial_approximation/#Riemann-Sum-Method","page":"Polynomial Approximation","title":"Riemann Sum Method","text":"Fast discrete approximation using grid points:\n\nnorm_riemann = discrete_l2_norm_riemann(polynomial, grid)\n\nCharacteristics:\n\nO(n^d) complexity for d dimensions\nAccuracy depends on grid density\nSuitable for quick estimates","category":"section"},{"location":"polynomial_approximation/#Quadrature-Method","page":"Polynomial Approximation","title":"Quadrature Method","text":"High-accuracy integration using Gaussian quadrature:\n\nnorm_quad = compute_l2_norm_quadrature(polynomial, grid_spec, basis=:chebyshev)\n\nCharacteristics:\n\nExact for polynomials up to degree 2n-1\nUses tensor product quadrature\nSupports anisotropic grids\nHigher accuracy than Riemann sums\n\nExample comparison:\n\n# Create polynomial approximation\npol = Constructor(TR, 10)\n\n# Compare methods\nnorm_r = discrete_l2_norm_riemann(pol.polynomial, pol.grid)\nnorm_q = compute_l2_norm_quadrature(pol.polynomial, [11, 11], basis=:chebyshev)\n\nprintln(\"Riemann norm: \", norm_r)\nprintln(\"Quadrature norm: \", norm_q)\nprintln(\"Relative difference: \", abs(norm_r - norm_q) / norm_q)","category":"section"},{"location":"polynomial_approximation/#Exact-Arithmetic-Conversion","page":"Polynomial Approximation","title":"Exact Arithmetic Conversion","text":"Convert from orthogonal basis to exact monomial representation:\n\n# Get exact monomial coefficients\nexact_coeffs = to_exact_monomial_basis(pol, grid_points)\n\n# Or directly from function\nexact_coeffs = exact_polynomial_coefficients(f, degree, domain_bounds)\n\nThis enables:\n\nSymbolic manipulation\nExact solver usage (msolve)\nSparsification analysis","category":"section"},{"location":"polynomial_approximation/#Post-Processing","page":"Polynomial Approximation","title":"Post-Processing","text":"","category":"section"},{"location":"polynomial_approximation/#Sparsification","page":"Polynomial Approximation","title":"Sparsification","text":"Remove small coefficients while tracking quality:\n\n# Basic sparsification\nsparse_poly, stats = sparsify_polynomial(polynomial, threshold=1e-10)\n\n# Analyze tradeoffs\nresults = analyze_sparsification_tradeoff(\n    polynomial,\n    thresholds=logspace(-12, -6, 20),\n    compute_error_norm=true\n)\n\nSee Polynomial Sparsification for detailed guide.","category":"section"},{"location":"polynomial_approximation/#Truncation","page":"Polynomial Approximation","title":"Truncation","text":"Alternative to sparsification that removes entire monomials:\n\n# Truncate with L2-norm monitoring\ntruncated, removed_norm = truncate_polynomial(polynomial, threshold=1e-8)\n\n# Analyze impact\nimpact = analyze_truncation_impact(polynomial, threshold)","category":"section"},{"location":"polynomial_approximation/#Anisotropic-Grids","page":"Polynomial Approximation","title":"Anisotropic Grids","text":"For functions with different scales per dimension:\n\n# Different points per dimension\ngrid = generate_anisotropic_grid([20, 10, 5], basis=:chebyshev)\npol = Constructor(TR, grid)","category":"section"},{"location":"polynomial_approximation/#Best-Practices","page":"Polynomial Approximation","title":"Best Practices","text":"Degree Selection\nStart with degree 6-8 for exploration\nIncrease to 10-12 for production runs\nMonitor approximation error via pol.nrm\nBasis Choice\nUse Chebyshev (default) for general functions\nTry Legendre for uniform-weighted problems\nBoth support exact conversion and sparsification\nL2-Norm Computation\nUse quadrature for final results\nRiemann sums for quick iteration\nCheck relative difference for validation\nMemory Management\nEnable sparsification for high-degree polynomials\nUse anisotropic grids for multiscale functions\nMonitor coefficient growth with dimension","category":"section"},{"location":"polynomial_approximation/#Related-Documentation","page":"Polynomial Approximation","title":"Related Documentation","text":"Core Algorithm - Overall optimization approach\nPolynomial Sparsification - Memory optimization techniques\nAPI Reference - Complete function documentation","category":"section"},{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"Note: As of v1.1.2, the public API has been streamlined to include only essential functions.","category":"section"},{"location":"api_reference/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api_reference/#Problem-Setup","page":"API Reference","title":"Problem Setup","text":"","category":"section"},{"location":"api_reference/#TestInput","page":"API Reference","title":"TestInput","text":"Create test input specification for optimization problems.\n\nTR = TestInput(f, dim=2, center=[0.0, 0.0], sample_range=1.2)","category":"section"},{"location":"api_reference/#Constructor","page":"API Reference","title":"Constructor","text":"Build polynomial approximation with precision control.\n\nSignature:\n\nConstructor(T::TestInput, degree; precision=AdaptivePrecision, basis=:chebyshev, verbose=0, grid=nothing)\n\nParameters: | Parameter | Type | Description | |–––––-|–––|––––––-| | T | TestInput | Problem specification | | degree | Int | Polynomial degree | | precision | PrecisionType | Float64Precision, AdaptivePrecision, RationalPrecision, BigFloatPrecision | | basis | Symbol | :chebyshev or :legendre | | verbose | Int | 0=quiet, 1=basic, 2=detailed | | grid | Matrix | Optional pre-generated grid |\n\nReturns: ApproxPoly with fields coeffs, nrm, precision\n\n→ Examples/hpc_minimal_2d_example.jl\n\n","category":"section"},{"location":"api_reference/#solve_polynomial_system","page":"API Reference","title":"solve_polynomial_system","text":"Find critical points by solving ∇p(x) = 0.\n\nsolutions = solve_polynomial_system(x, pol)  # Convenience method\nsolutions = solve_polynomial_system(x, dim, degree, coeffs)  # Explicit parameters","category":"section"},{"location":"api_reference/#process_crit_pts","page":"API Reference","title":"process_crit_pts","text":"Process and filter critical point solutions.\n\ndf = process_crit_pts(solutions, f, TR)\n\n","category":"section"},{"location":"api_reference/#Analysis-Functions","page":"API Reference","title":"Analysis Functions","text":"","category":"section"},{"location":"api_reference/#analyze_critical_points","page":"API Reference","title":"analyze_critical_points","text":"Comprehensive critical point analysis with BFGS refinement.\n\ndf_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true, verbose=true, tol_dist=0.025)","category":"section"},{"location":"api_reference/#analyze_critical_points_with_tables","page":"API Reference","title":"analyze_critical_points_with_tables","text":"Enhanced analysis with statistical tables.\n\ndf_enhanced, df_min, tables, stats = analyze_critical_points_with_tables(f, df, TR, show_tables=true)\n\n→ Examples/hierarchical_experiment_example.jl\n\n","category":"section"},{"location":"api_reference/#Polynomial-Approximation","page":"API Reference","title":"Polynomial Approximation","text":"Function Purpose\nchebyshev_extrema(n) Generate Chebyshev extrema points\nchebyshev_polys(x, n) Evaluate Chebyshev polynomials\ngrid_sample(TR, n) Create sampling grid\nsample_objective_on_grid(f, grid) Evaluate objective on grid\nlambda_vandermonde(grid, degree) Construct Vandermonde matrix\n\n","category":"section"},{"location":"api_reference/#Critical-Point-Analysis","page":"API Reference","title":"Critical Point Analysis","text":"Function Purpose\ncompute_hessians(f, points) Compute Hessian matrices\nclassify_critical_points(hessians) Classify based on eigenvalues\ncompute_hessian_norms(df) Calculate Frobenius norms\nanalyze_basins(df) Analyze basins of attraction\n\n","category":"section"},{"location":"api_reference/#BFGS-Refinement","page":"API Reference","title":"BFGS Refinement","text":"Function Purpose\nenhanced_bfgs_refinement(f, x0) BFGS with hyperparameter tracking\nrefine_with_enhanced_bfgs(f, df) Apply BFGS to DataFrame\ndetermine_convergence_reason(result) Analyze convergence\n\n","category":"section"},{"location":"api_reference/#Precision-Control","page":"API Reference","title":"Precision Control","text":"","category":"section"},{"location":"api_reference/#Precision-Types","page":"API Reference","title":"Precision Types","text":"Type Coefficient Type Best For\nFloat64Precision Float64 Fast computation\nAdaptivePrecision Float64 (raw), BigFloat (monomial) Recommended default\nRationalPrecision Rational{BigInt} Exact arithmetic\nBigFloatPrecision BigFloat Maximum precision\n\n→ Examples/sparsification_demo.jl\n\n","category":"section"},{"location":"api_reference/#Sparsification","page":"API Reference","title":"Sparsification","text":"Function Purpose\nto_exact_monomial_basis(pol, variables=x) Convert to monomial basis\nanalyze_coefficient_distribution(poly) Analyze for truncation\ntruncate_polynomial_adaptive(poly, threshold) Smart truncation\nsparsify_polynomial(pol, threshold) Zero small coefficients\nverify_truncation_quality(original, truncated, domain) Verify L²-norm preservation\n\nUsage pattern:\n\nmono_poly = to_exact_monomial_basis(pol, variables=x)\nanalysis = analyze_coefficient_distribution(mono_poly)\ntruncated, stats = truncate_polynomial_adaptive(mono_poly, analysis.suggested_thresholds[1])\n\n","category":"section"},{"location":"api_reference/#Grid-Generation","page":"API Reference","title":"Grid Generation","text":"Function Purpose\ngenerate_grid(n, dim) Isotropic grid\ngenerate_anisotropic_grid([n1, n2, ...]) Different points per dimension\ngrid_to_matrix(grid) Convert to matrix format\nis_anisotropic(grid) Check grid type\n\n→ Examples/anisotropic_grid_demo.jl\n\n","category":"section"},{"location":"api_reference/#L-Norm-Computation","page":"API Reference","title":"L²-Norm Computation","text":"Function Purpose\ncompute_l2_norm(poly, domain) L²-norm over domain\ncompute_l2_norm_quadrature(f, poly, domain) Using quadrature\ndiscrete_l2_norm_riemann(values, grid) Riemann sum approximation\nintegrate_monomial(exponents, domain) Analytic monomial integration\n\n","category":"section"},{"location":"api_reference/#Export-Functions","page":"API Reference","title":"Export Functions","text":"Function Output Format\nwrite_tables_to_csv(tables, path) CSV\nwrite_tables_to_latex(tables, path) LaTeX\nwrite_tables_to_markdown(tables, path) Markdown\n\n","category":"section"},{"location":"api_reference/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api_reference/#Core-Types","page":"API Reference","title":"Core Types","text":"Type Description\nTestInput Problem specification\nApproxPoly Polynomial approximation with coeffs, nrm, precision\nBFGSConfig BFGS configuration\nBFGSResult BFGS results\nBoxDomain{T} Domain [-a,a]ⁿ for L²-norm","category":"section"},{"location":"api_reference/#Precision-Types-2","page":"API Reference","title":"Precision Types","text":"# Available values\nFloat64Precision, AdaptivePrecision, RationalPrecision, BigFloatPrecision\n\n","category":"section"},{"location":"api_reference/#Built-in-Test-Functions","page":"API Reference","title":"Built-in Test Functions","text":"","category":"section"},{"location":"api_reference/#2D-Functions","page":"API Reference","title":"2D Functions","text":"Deuflhard, HolderTable, Ackley, camel, shubert","category":"section"},{"location":"api_reference/#3D-Functions","page":"API Reference","title":"3D Functions","text":"tref_3d","category":"section"},{"location":"api_reference/#n-Dimensional-Functions","page":"API Reference","title":"n-Dimensional Functions","text":"Rastrigin, alpine1, alpine2, Csendes\n\n","category":"section"},{"location":"api_reference/#Help-System","page":"API Reference","title":"Help System","text":"julia> ?TestInput\njulia> ?analyze_critical_points\n\n","category":"section"},{"location":"api_reference/#See-Also","page":"API Reference","title":"See Also","text":"GlobtimPostProcessing - Refinement, gradient validation, parameter recovery, campaign analysis\nGlobtimPlots - Visualization functions for experiments and campaigns","category":"section"},{"location":"exact_conversion/#Exact-Polynomial-Conversion","page":"Exact Conversion","title":"Exact Polynomial Conversion","text":"","category":"section"},{"location":"exact_conversion/#Overview","page":"Exact Conversion","title":"Overview","text":"Globtim provides functionality to convert polynomial approximations from orthogonal bases (Chebyshev or Legendre) to exact monomial form. This is useful for:\n\nSymbolic manipulation of polynomials\nIntegration with computer algebra systems\nUnderstanding polynomial structure\nExact arithmetic operations\nFinding critical points symbolically","category":"section"},{"location":"exact_conversion/#Main-Functions","page":"Exact Conversion","title":"Main Functions","text":"","category":"section"},{"location":"exact_conversion/#to_exact_monomial_basis","page":"Exact Conversion","title":"to_exact_monomial_basis","text":"Converts a polynomial from orthogonal basis to monomial basis using exact arithmetic.\n\nto_exact_monomial_basis(pol::ApproxPoly; variables=nothing)\n\nArguments:\n\npol::ApproxPoly: Polynomial approximation from Globtim\nvariables: Array of polynomial variables (created automatically if not provided)\n\nReturns:\n\nDynamicPolynomials.Polynomial: Polynomial in monomial basis with exact coefficients\n\nExample:\n\nusing Globtim\nusing DynamicPolynomials\n\n# Create a polynomial approximation\nTR = TestInput(x -> sin(π*x[1])*cos(π*x[2]), dim=2, center=[0.0, 0.0], sample_range=1.0)\npol = Constructor(TR, 8, basis=:chebyshev, precision=RationalPrecision)\n\n# Convert to monomial basis\n@polyvar x y\nmono_poly = to_exact_monomial_basis(pol, variables=[x, y])","category":"section"},{"location":"exact_conversion/#exact_polynomial_coefficients","page":"Exact Conversion","title":"exact_polynomial_coefficients","text":"Convenience function to get exact monomial coefficients directly from a function.\n\nexact_polynomial_coefficients(f::Function, dim::Int, degree::Int; kwargs...)\n\nArguments:\n\nf::Function: Function to approximate\ndim::Int: Dimension of the input\ndegree::Int: Maximum polynomial degree\nbasis::Symbol = :chebyshev: Basis to use (:chebyshev or :legendre)\ncenter::Vector = zeros(dim): Center of approximation domain\nsample_range::Real = 1.0: Radius of approximation domain\ntolerance::Real = 0.5: Tolerance for approximation\nprecision = Float64Precision: Arithmetic precision\n\nReturns:\n\nDynamicPolynomials.Polynomial: Polynomial in monomial basis\n\nExample:\n\n# Direct conversion from function to monomial polynomial\nf = x -> x[1]^2 + x[2]^2 - x[1]*x[2]\nmono_poly = exact_polynomial_coefficients(f, 2, 4, basis=:chebyshev)","category":"section"},{"location":"exact_conversion/#Using-Rational-Arithmetic","page":"Exact Conversion","title":"Using Rational Arithmetic","text":"The Constructor function supports exact rational arithmetic through the precision parameter:\n\npol = Constructor(TR, degree, \n    basis = :chebyshev,\n    precision = RationalPrecision,  # Use exact rational arithmetic\n    normalized = false,             # Use unnormalized basis functions\n    power_of_two_denom = false     # Don't restrict to power-of-2 denominators\n)","category":"section"},{"location":"exact_conversion/#Example:-Complete-Workflow","page":"Exact Conversion","title":"Example: Complete Workflow","text":"using Globtim\nusing DynamicPolynomials\n\n# Define a test function\nf = x -> exp(-x[1]^2 - x[2]^2)\n\n# Create test input\nTR = TestInput(f, dim=2, center=[0.0, 0.0], sample_range=1.0)\n\n# Construct polynomial with rational coefficients\npol = Constructor(TR, 6, basis=:legendre, precision=RationalPrecision)\n\n# Convert to monomial basis\n@polyvar x y\nmono_poly = to_exact_monomial_basis(pol, variables=[x, y])\n\n# Now you can:\n# 1. Take derivatives symbolically\ndx = differentiate(mono_poly, x)\ndy = differentiate(mono_poly, y)\n\n# 2. Evaluate at specific points\npoint_value = substitute(mono_poly, x => 0.5, y => 0.5)\n\n# 3. Extract coefficients\nterms_list = terms(mono_poly)\nfor term in terms_list[1:min(5, length(terms_list))]\n    coeff = coefficient(term)\n    mon = monomial(term)\n    println(\"$coeff * $mon\")\nend","category":"section"},{"location":"exact_conversion/#Finding-Critical-Points","page":"Exact Conversion","title":"Finding Critical Points","text":"Once you have the polynomial in either orthogonal or monomial form, you can find critical points:\n\n# Using the orthogonal polynomial directly (more efficient)\n@polyvar x_vars[1:2]\nreal_pts = solve_polynomial_system(\n    x_vars, \n    2,  # dimension\n    pol.degree, \n    pol.coeffs;\n    basis = pol.basis,\n    precision = pol.precision,\n    normalized = pol.normalized\n)\n\n# Process the critical points\ndf_crit = process_crit_pts(real_pts, f, TR)","category":"section"},{"location":"exact_conversion/#Implementation-Details","page":"Exact Conversion","title":"Implementation Details","text":"The exact conversion functionality leverages existing Globtim components:\n\nConstructor with precision=RationalPrecision computes exact rational coefficients\nconstruct_orthopoly_polynomial (internal) builds the polynomial in monomial form\nto_exact_monomial_basis provides a clean API and handles domain scaling\n\nThe conversion preserves numerical precision and allows for exact symbolic manipulation of the resulting polynomial.","category":"section"},{"location":"exact_conversion/#See-Also","page":"Exact Conversion","title":"See Also","text":"Polynomial Approximation - General polynomial approximation\nCritical Point Analysis - Finding and analyzing critical points\nExamples - More examples of using Globtim","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide walks you through the basic usage of Globtim.jl for finding all local minima of continuous functions.","category":"section"},{"location":"getting_started/#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"See: Examples/hpc_minimal_2d_example.jl\n\nThe typical Globtim workflow consists of five steps:\n\nStep Function Purpose\n1 TestInput(f, dim=2, ...) Define problem domain\n2 Constructor(TR, degree) Build polynomial approximation\n3 solve_polynomial_system(x, pol) Find critical points\n4 process_crit_pts(solutions, f, TR) Filter to valid solutions\n5 analyze_critical_points(f, df, TR) Refine and classify","category":"section"},{"location":"getting_started/#1.-Define-the-Problem","page":"Getting Started","title":"1. Define the Problem","text":"TR = TestInput(f, dim=2, center=[0.0, 0.0], sample_range=1.2)","category":"section"},{"location":"getting_started/#2.-Find-Critical-Points","page":"Getting Started","title":"2. Find Critical Points","text":"pol = Constructor(TR, 8)\n@polyvar x[1:2]\nsolutions = solve_polynomial_system(x, pol)\ndf = process_crit_pts(solutions, f, TR)","category":"section"},{"location":"getting_started/#3.-Refine-and-Classify","page":"Getting Started","title":"3. Refine and Classify","text":"df_enhanced, df_min = analyze_critical_points(f, df, TR, enable_hessian=true)\n\n","category":"section"},{"location":"getting_started/#Domain-Specification","page":"Getting Started","title":"Domain Specification","text":"Uniform scaling (square/cube domain):\n\nTR = TestInput(f, dim=2, center=[0.0, 0.0], sample_range=1.0)  # [-1,1]²\n\nNon-uniform scaling (rectangular domain):\n\nTR = TestInput(f, dim=2, center=[0.0, 0.0], sample_range=[2.0, 1.0])  # [-2,2]×[-1,1]\n\nSee: Examples/domain_sweep_demo.jl\n\n","category":"section"},{"location":"getting_started/#Polynomial-Degree-Selection","page":"Getting Started","title":"Polynomial Degree Selection","text":"Higher degrees improve approximation but increase computation:\n\npol = Constructor(TR, degree)  # degree = 4, 6, 8, 10, ...\n\nCheck approximation quality: pol.nrm returns L²-norm error.\n\n","category":"section"},{"location":"getting_started/#Precision-Parameters","page":"Getting Started","title":"Precision Parameters","text":"See: Examples/sparsification_demo.jl\n\nPrecision Performance Accuracy Best For\nFloat64Precision Fast Good General use\nAdaptivePrecision Good Excellent Recommended default\nRationalPrecision Slow Exact Symbolic computation\nBigFloatPrecision Slowest Maximum Research\n\nUsage:\n\npol = Constructor(TR, 8, precision=AdaptivePrecision)","category":"section"},{"location":"getting_started/#AdaptivePrecision-with-Sparsification","page":"Getting Started","title":"AdaptivePrecision with Sparsification","text":"pol = Constructor(TR, 10, precision=AdaptivePrecision)\n@polyvar x[1:2]\nmono_poly = to_exact_monomial_basis(pol, variables=x)\nanalysis = analyze_coefficient_distribution(mono_poly)\ntruncated_poly, stats = truncate_polynomial_adaptive(mono_poly, analysis.suggested_thresholds[1])","category":"section"},{"location":"getting_started/#High-Dimensional-Problems","page":"Getting Started","title":"High-Dimensional Problems","text":"See: Examples/high_dimensional_demo.jl\n\nFor dimension ≥ 4:\n\nUse AdaptivePrecision for good accuracy/performance balance\nUse coefficient truncation to manage polynomial complexity\nMonitor memory usage with higher degrees","category":"section"},{"location":"getting_started/#HPC-Cluster-Usage","page":"Getting Started","title":"HPC Cluster Usage","text":"pol = Constructor(TR, 8, precision=AdaptivePrecision, verbose=0)\n\nFloat64Precision: Fastest, lowest memory\nAdaptivePrecision: Good balance for production\nAvoid RationalPrecision for large-scale computations\n\n","category":"section"},{"location":"getting_started/#Built-in-Test-Functions","page":"Getting Started","title":"Built-in Test Functions","text":"Function Dimension Description\nDeuflhard 2D Challenging with multiple minima\nRastrigin nD Classic multimodal benchmark\nHolderTable 2D 4 symmetric global minima\ntref_3d 3D Highly oscillatory\nBeale, Rosenbrock, Branin 2D Standard benchmarks\n\nUsage:\n\nf = Deuflhard\nTR = TestInput(f, dim=2, center=[0.0, 0.0], sample_range=1.2)\n\n","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Examples - Runnable example files\nPrecision Parameters - Detailed precision documentation\nCore Algorithm - Mathematical foundations\nCritical Point Analysis - Advanced refinement\nSparsification - Polynomial complexity reduction\nGlobtimPostProcessing - Refine critical points to high accuracy, campaign analysis\nGlobtimPlots - Visualize experiments and results\nAPI Reference - Complete function documentation","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"This page demonstrates Globtim features with inline examples and visual results.\n\nNote: Standalone example scripts are being prepared for a future release.\n\n","category":"section"},{"location":"examples/#Test-Function-Gallery","page":"Examples","title":"Test Function Gallery","text":"Visual examples of Globtim finding critical points on standard benchmark functions.","category":"section"},{"location":"examples/#Deuflhard","page":"Examples","title":"Deuflhard","text":"(Image: Deuflhard Function)","category":"section"},{"location":"examples/#Holder-Table","page":"Examples","title":"Holder Table","text":"(Image: Holder Table Function)","category":"section"},{"location":"examples/#Beale","page":"Examples","title":"Beale","text":"(Image: Beale Function)","category":"section"},{"location":"examples/#Branin","page":"Examples","title":"Branin","text":"(Image: Branin Function)\n\n","category":"section"},{"location":"examples/#Basic-2D-Workflow","page":"Examples","title":"Basic 2D Workflow","text":"Core API sequence:\n\nStep API Call\n1. Define problem TestInput(f, dim=2, center=[0.0,0.0], sample_range=1.2)\n2. Build polynomial Constructor(TR, degree)\n3. Find critical pts solve_polynomial_system(x, pol)\n4. Process solutions process_crit_pts(solutions, f, TR)\n5. Analyze & classify analyze_critical_points(f, df, TR, enable_hessian=true)\n\n","category":"section"},{"location":"examples/#Custom-Objective-Functions","page":"Examples","title":"Custom Objective Functions","text":"Define any function accepting a vector x and returning a scalar:\n\nmy_function(x) = (x[1]^2 - 1)^2 + (x[2]^2 - 1)^2 + 0.1*sin(10*x[1]*x[2])\n\n","category":"section"},{"location":"examples/#Statistical-Analysis-with-Tables","page":"Examples","title":"Statistical Analysis with Tables","text":"API pattern:\n\ndf_enhanced, df_min, tables, stats = analyze_critical_points_with_tables(f, df, TR, show_tables=true)\n\nExport options: write_tables_to_csv(), write_tables_to_markdown(), write_tables_to_latex()\n\n","category":"section"},{"location":"examples/#High-Dimensional-Problems-(3D/4D)","page":"Examples","title":"High-Dimensional Problems (3D/4D)","text":"Tips:\n\nUse AdaptivePrecision for accuracy/performance balance\nReduce polynomial degree as dimension increases (4D → degree 4-6)\nDisable Hessian analysis for faster results: enable_hessian=false\n\n","category":"section"},{"location":"examples/#Domain-Exploration","page":"Examples","title":"Domain Exploration","text":"Test different domain sizes to find all critical points:\n\nTR = TestInput(f, dim=2, center=[0.0, 0.0], sample_range=r)      # uniform\nTR = TestInput(f, dim=2, center=[0.0, 0.0], sample_range=[2.0, 1.0])  # rectangular\n\n","category":"section"},{"location":"examples/#Visualization","page":"Examples","title":"Visualization","text":"For plotting critical points and convergence analysis, use the GlobtimPlots package:\n\nusing GlobtimPlots\nfig = plot_critical_points(df_enhanced)\nfig = plot_convergence(results)\n\nSee the GlobtimPlots documentation for available plot types.\n\nFor post-experiment analysis (refinement, parameter recovery, campaign comparison), use GlobtimPostProcessing.\n\n","category":"section"},{"location":"examples/#Polynomial-Degree-Comparison","page":"Examples","title":"Polynomial Degree Comparison","text":"Compare Chebyshev vs Legendre bases and analyze how polynomial degree affects approximation quality and critical point discovery. See the Polynomial Approximation page for theoretical background.\n\n","category":"section"},{"location":"examples/#1D-Functions-with-Scalar-Input","page":"Examples","title":"1D Functions with Scalar Input","text":"Works with functions like sin, cos that expect scalar input:\n\nf = x -> sin(3x) + 0.1*x^2\nTR = TestInput(f, dim=1, center=[0.0], sample_range=π)\n\n","category":"section"},{"location":"examples/#Basin-Analysis","page":"Examples","title":"Basin Analysis","text":"Analyze convergence basins for critical points. The df_min DataFrame includes:\n\nbasin_points - Number of points converging to this minimum\naverage_convergence_steps - Mean BFGS iterations\nregion_coverage_count - Spatial coverage metric\n\n","category":"section"},{"location":"examples/#Next-Steps","page":"Examples","title":"Next Steps","text":"Getting Started - Basic concepts and setup\nAPI Reference - Complete function documentation\nPrecision Parameters - Numerical precision options\nSparsification - Polynomial complexity reduction","category":"section"},{"location":"grid_formats/#Grid-Formats-in-Globtim","page":"Grid Formats","title":"Grid Formats in Globtim","text":"This document explains the two grid representations used in Globtim.","category":"section"},{"location":"grid_formats/#Overview","page":"Grid Formats","title":"Overview","text":"Globtim uses two different grid formats:\n\nArray{SVector} format - Natural Julia arrays of static vectors (from StaticArrays.jl)\nMatrix format - Traditional matrix representation required for linear algebra operations","category":"section"},{"location":"grid_formats/#Array{SVector}-Format","page":"Grid Formats","title":"Array{SVector} Format","text":"This is the natural output from generate_grid:\n\ngrid = generate_grid(2, 10, basis=:chebyshev)\n# Returns: 11×11 Array{SVector{2,Float64},2}\n\nCharacteristics:\n\nEach element is an SVector{N,Float64} representing a point\nN-dimensional array structure preserves grid topology\nEfficient for point-wise function evaluation\nNatural for Julia's multiple dispatch\n\nUsed for:\n\nFunction evaluation at grid points\nGrid traversal and manipulation\nDiscrete L²-norm computation\n\nExample:\n\nf = x -> sum(x.^2)\ngrid = generate_grid(2, 10)\nvalues = map(f, reshape(grid, :))","category":"section"},{"location":"grid_formats/#Matrix-Format","page":"Grid Formats","title":"Matrix Format","text":"Required for Vandermonde matrix construction. Convert using grid_to_matrix:\n\nmatrix_grid = grid_to_matrix(grid)\n# Returns: 121×2 Matrix{Float64}\n\nCharacteristics:\n\nEach row represents a point\nEach column represents a dimension\nCompatible with BLAS operations\nRequired by lambda_vandermonde\n\nUsed for:\n\nVandermonde matrix construction\nLinear algebra operations\nPolynomial basis evaluation\n\nExample:\n\ngrid = generate_grid(2, 10, basis=:chebyshev)\nmatrix_grid = grid_to_matrix(grid)\nLambda = SupportGen(2, 5)\nV = lambda_vandermonde(Lambda, matrix_grid, basis=:chebyshev)\n\nThe ApproxPoly type stores grids in matrix format:\n\npol = Constructor(TR, 10, basis=:chebyshev)\n# pol.grid is already in matrix format\nV = lambda_vandermonde(Lambda, pol.grid, basis=pol.basis)","category":"section"},{"location":"test_documentation/#Globtim-Test-Documentation","page":"Globtim Test Documentation","title":"Globtim Test Documentation","text":"This document provides a comprehensive overview of all test suites in the Globtim package, their purpose, and when to run them.","category":"section"},{"location":"test_documentation/#Test-Organization","page":"Globtim Test Documentation","title":"Test Organization","text":"Tests are organized by feature area in the test/ directory:\n\ntest/\n├── runtests.jl                              # Main test runner\n├── test_forwarddiff_integration.jl         # ForwardDiff optimization integration\n├── test_function_value_analysis.jl         # Function value error analysis\n├── test_exact_conversion.jl                # Exact arithmetic conversion\n├── test_sparsification.jl                  # Polynomial sparsification\n├── test_truncation.jl                      # Polynomial truncation\n├── test_l2_norm_scaling.jl                 # L2 norm scaling tests\n├── test_anisotropic_grids.jl               # Anisotropic grid functionality\n├── test_quadrature_l2_norm.jl              # Quadrature-based L2 norm computation\n├── test_quadrature_l2_phase1_2.jl          # Phase 1/2 quadrature integration\n├── test_quadrature_vs_riemann.jl           # Quadrature vs Riemann comparison\n├── test_hessian_analysis.jl                # Phase 2 Hessian analysis\n├── test_enhanced_analysis_integration.jl   # Phase 3 enhanced analysis\n├── test_statistical_tables.jl              # Phase 3 statistical tables\n└── Debug utilities (not in main test suite):\n    ├── debug_conversion.jl\n    ├── debug_legendre.jl\n    └── run_quadrature_tests.jl","category":"section"},{"location":"test_documentation/#Running-Tests","page":"Globtim Test Documentation","title":"Running Tests","text":"","category":"section"},{"location":"test_documentation/#Run-All-Tests","page":"Globtim Test Documentation","title":"Run All Tests","text":"julia --project test/runtests.jl","category":"section"},{"location":"test_documentation/#Run-Specific-Test-Suite","page":"Globtim Test Documentation","title":"Run Specific Test Suite","text":"julia --project test/test_anisotropic_grids.jl","category":"section"},{"location":"test_documentation/#Run-Tests-with-Package-Manager","page":"Globtim Test Documentation","title":"Run Tests with Package Manager","text":"using Pkg\nPkg.test(\"Globtim\")","category":"section"},{"location":"test_documentation/#Test-Suites","page":"Globtim Test Documentation","title":"Test Suites","text":"","category":"section"},{"location":"test_documentation/#1.-ForwardDiff-Integration-Tests-(test_forwarddiff_integration.jl)","page":"Globtim Test Documentation","title":"1. ForwardDiff Integration Tests (test_forwarddiff_integration.jl)","text":"Purpose: Tests integration with ForwardDiff.jl for gradient and Hessian computation.\n\nWhen to run:\n\nAfter modifying gradient computation methods\nWhen changing automatic differentiation usage\nAfter updates to optimization routines\n\nKey tests:\n\nGradient computation accuracy\nHessian computation correctness\nPerformance of AD operations\nIntegration with polynomial approximations","category":"section"},{"location":"test_documentation/#2.-Function-Value-Error-Analysis-(test_function_value_analysis.jl)","page":"Globtim Test Documentation","title":"2. Function Value Error Analysis (test_function_value_analysis.jl)","text":"Purpose: Tests the accuracy of function value computations and error metrics.\n\nWhen to run:\n\nAfter modifying error analysis methods\nWhen changing function evaluation procedures\nAfter updates to error metrics\n\nTest categories:\n\nError computation methods\nStatistical error analysis\nError propagation through pipeline\nConvergence analysis","category":"section"},{"location":"test_documentation/#3.-Anisotropic-Grid-Tests-(test_anisotropic_grids.jl)","page":"Globtim Test Documentation","title":"3. Anisotropic Grid Tests (test_anisotropic_grids.jl)","text":"Purpose: Tests the generation and usage of anisotropic grids with different number of points per dimension.\n\nWhen to run: \n\nAfter modifying anisotropic_grids.jl\nAfter changes to generate_grid functions\nAfter modifications to L2 norm computation methods\n\nTest categories:\n\nBasic grid generation (2D, 3D, high-dimensional)\nGrid properties (Chebyshev, Legendre, uniform nodes)\nL2 norm computation on anisotropic grids\nComparison with isotropic grids\nPerformance benefits for multiscale functions\nBackward compatibility\n\nKey tests:\n\nVerifies grid dimensions match specifications\nTests node distributions for different bases\nValidates L2 norm accuracy on anisotropic grids\nDemonstrates 15x improvement for multiscale functions","category":"section"},{"location":"test_documentation/#4.-Quadrature-L2-Norm-Tests-(test_quadrature_l2_norm.jl)","page":"Globtim Test Documentation","title":"4. Quadrature L2 Norm Tests (test_quadrature_l2_norm.jl)","text":"Purpose: Tests the quadrature-based L2 norm computation using orthogonal polynomials.\n\nWhen to run:\n\nAfter modifying quadrature_l2_norm.jl\nAfter changes to polynomial quadrature methods\nWhen updating orthogonal polynomial implementations\n\nTest categories:\n\nBasic functionality for all dimensions (1D-4D)\nDifferent polynomial bases (Chebyshev, Legendre, uniform)\nPolynomial test functions with known L2 norms\nGaussian and exponential functions\nComparison with Riemann sum methods\n\nKey validations:\n\nExact computation for polynomials up to degree 2n\nAccurate results for smooth functions\nConsistency across different bases","category":"section"},{"location":"test_documentation/#5.-Exact-Conversion-Tests-(test_exact_conversion.jl)","page":"Globtim Test Documentation","title":"5. Exact Conversion Tests (test_exact_conversion.jl)","text":"Purpose: Tests conversion of polynomial approximations to exact monomial basis.\n\nWhen to run:\n\nAfter modifying exact_conversion.jl\nWhen changing polynomial representation\nAfter updates to basis conversion methods\n\nTest coverage:\n\nConversion from orthogonal to monomial basis\nPreservation of polynomial identity\nExact arithmetic operations\nMulti-dimensional polynomial handling","category":"section"},{"location":"test_documentation/#6.-Sparsification-Tests-(test_sparsification.jl)","page":"Globtim Test Documentation","title":"6. Sparsification Tests (test_sparsification.jl)","text":"Purpose: Tests polynomial sparsification based on L2 contributions.\n\nWhen to run:\n\nAfter modifying sparsification algorithms\nWhen updating L2 norm computations\nAfter changes to polynomial manipulation\n\nKey features tested:\n\nIdentification of significant monomials\nControlled approximation error\nSparsity vs accuracy tradeoffs\nPerformance improvements","category":"section"},{"location":"test_documentation/#7.-Truncation-Tests-(test_truncation.jl)","page":"Globtim Test Documentation","title":"7. Truncation Tests (test_truncation.jl)","text":"Purpose: Tests polynomial truncation with L2 error bounds.\n\nWhen to run:\n\nAfter modifying truncation methods\nWhen updating error analysis\nAfter changes to polynomial degree reduction\n\nValidates:\n\nTruncation error bounds\nOptimal degree selection\nL2 norm preservation","category":"section"},{"location":"test_documentation/#8.-L2-Norm-Scaling-Tests-(test_l2_norm_scaling.jl)","page":"Globtim Test Documentation","title":"8. L2 Norm Scaling Tests (test_l2_norm_scaling.jl)","text":"Purpose: Tests L2 norm computation with different scaling factors.\n\nWhen to run:\n\nAfter modifying scaling utilities\nWhen updating coordinate transformations\nAfter changes to norm computation","category":"section"},{"location":"test_documentation/#9.-Phase-1/2-Quadrature-Integration-(test_quadrature_l2_phase1_2.jl)","page":"Globtim Test Documentation","title":"9. Phase 1/2 Quadrature Integration (test_quadrature_l2_phase1_2.jl)","text":"Purpose: Tests integration of quadrature methods with Phase 1 and 2 features.\n\nWhen to run:\n\nAfter modifying quadrature implementations\nWhen updating Phase 1/2 integration\nAfter changes to polynomial basis functions\n\nKey validations:\n\nPhase 1 polynomial approximation with quadrature\nPhase 2 critical point analysis with quadrature norms\nCross-phase consistency","category":"section"},{"location":"test_documentation/#10.-Quadrature-vs-Riemann-Comparison-(test_quadrature_vs_riemann.jl)","page":"Globtim Test Documentation","title":"10. Quadrature vs Riemann Comparison (test_quadrature_vs_riemann.jl)","text":"Purpose: Benchmarks and compares quadrature vs Riemann sum methods.\n\nWhen to run:\n\nWhen optimizing L2 norm computation\nAfter implementing new norm methods\nFor performance analysis\n\nTest categories:\n\nAccuracy comparison\nPerformance benchmarks\nConvergence rates\nMethod selection guidance","category":"section"},{"location":"test_documentation/#11.-Phase-2-Hessian-Analysis-(test_hessian_analysis.jl)","page":"Globtim Test Documentation","title":"11. Phase 2 Hessian Analysis (test_hessian_analysis.jl)","text":"Purpose: Tests Hessian-based critical point classification.\n\nWhen to run:\n\nAfter modifying Hessian computation\nWhen updating critical point classification\nAfter changes to eigenvalue analysis\n\nKey features tested:\n\nHessian computation accuracy\nEigenvalue extraction\nCritical point classification (min/max/saddle)\nCondition number analysis","category":"section"},{"location":"test_documentation/#12.-Phase-3-Enhanced-Analysis-Integration-(test_enhanced_analysis_integration.jl)","page":"Globtim Test Documentation","title":"12. Phase 3 Enhanced Analysis Integration (test_enhanced_analysis_integration.jl)","text":"Purpose: Tests the complete Phase 3 analysis pipeline integration.\n\nWhen to run:\n\nAfter modifying Phase 3 features\nWhen updating analysis pipelines\nAfter changes to data structures\n\nTest coverage:\n\nMulti-tolerance analysis\nEnhanced BFGS refinement\nOrthant decomposition\nResult aggregation","category":"section"},{"location":"test_documentation/#13.-Phase-3-Statistical-Tables-(test_statistical_tables.jl)","page":"Globtim Test Documentation","title":"13. Phase 3 Statistical Tables (test_statistical_tables.jl)","text":"Purpose: Tests statistical analysis and table generation features.\n\nWhen to run:\n\nAfter modifying statistical computations\nWhen updating table formatting\nAfter changes to analysis outputs\n\nValidates:\n\nStatistical metric computation\nTable rendering (console and LaTeX)\nData aggregation\nExport functionality","category":"section"},{"location":"test_documentation/#Test-Dependencies","page":"Globtim Test Documentation","title":"Test Dependencies","text":"","category":"section"},{"location":"test_documentation/#Required-Packages","page":"Globtim Test Documentation","title":"Required Packages","text":"Test\nLinearAlgebra\nStaticArrays\nPolyChaos (for quadrature tests)\nForwardDiff (for differentiation tests)\nDataFrames (for analysis tests)\nHomotopyContinuation (for critical point tests)\nBenchmarkTools (for performance comparisons)","category":"section"},{"location":"test_documentation/#File-Dependencies","page":"Globtim Test Documentation","title":"File Dependencies","text":"All test files depend on the main Globtim module\nQuadrature tests require quadrature_l2_norm.jl\nAnisotropic tests require anisotropic_grids.jl\nExact conversion tests require exact_conversion.jl\nPhase 2 tests require hessian_analysis.jl\nPhase 3 tests require enhanced_analysis.jl and data_structures.jl\nStatistical tests require statistical_tables.jl","category":"section"},{"location":"test_documentation/#Adding-New-Tests","page":"Globtim Test Documentation","title":"Adding New Tests","text":"When adding new functionality:\n\nCreate a new test file: test_<feature_name>.jl\nAdd to runtests.jl\nDocument the test suite here\nInclude:\nPurpose and scope\nWhen to run the tests\nDependencies\nKey validations","category":"section"},{"location":"test_documentation/#Continuous-Integration","page":"Globtim Test Documentation","title":"Continuous Integration","text":"Tests should be run:\n\nBefore committing changes\nAfter merging branches\nWhen preparing releases\nAs part of CI/CD pipeline","category":"section"},{"location":"test_documentation/#Performance-Benchmarks","page":"Globtim Test Documentation","title":"Performance Benchmarks","text":"Some test files include performance comparisons:\n\ntest_anisotropic_grids.jl: Demonstrates 15x improvement for multiscale functions\ntest_quadrature_l2_norm.jl: Compares quadrature vs Riemann methods","category":"section"},{"location":"test_documentation/#Debugging-Failed-Tests","page":"Globtim Test Documentation","title":"Debugging Failed Tests","text":"Run the specific test file in isolation\nCheck for missing dependencies (--project flag)\nVerify file paths are correct\nLook for version conflicts in Project.toml\nCheck if new exports are added to Globtim.jl","category":"section"},{"location":"test_documentation/#Test-Coverage-Goals","page":"Globtim Test Documentation","title":"Test Coverage Goals","text":"All exported functions should have tests\nEdge cases and error conditions\nPerformance regression tests\nIntegration tests for combined features\nDocumentation examples as tests","category":"section"},{"location":"#Globtim.jl-Documentation","page":"Home","title":"Globtim.jl Documentation","text":"(Image: Julia 1.11) (Image: License: GPL v3)\n\nGlobal optimization of continuous functions via polynomial approximation","category":"section"},{"location":"#The-Problem","page":"Home","title":"The Problem","text":"Finding all local minima of a continuous function over a bounded domain is fundamentally hard. Standard optimization algorithms (gradient descent, BFGS, etc.) find one local minimum from a given starting point — but how do you know there isn't a better one elsewhere?","category":"section"},{"location":"#The-Approach","page":"Home","title":"The Approach","text":"Globtim solves this by replacing your function with a polynomial approximation. Why polynomials?\n\nSmooth functions are well-approximated by polynomials — Chebyshev and Legendre expansions converge rapidly for smooth functions\nPolynomial critical points can be found exactly — Setting ∇p(x) = 0 gives a polynomial system, which has finitely many solutions that can be computed using homotopy continuation\nRefinement recovers true minima — Each polynomial critical point seeds a local optimization (BFGS) on the original function\n\nThe result: a systematic way to find all local minima, not just the nearest one.","category":"section"},{"location":"#Algorithm-Overview","page":"Home","title":"Algorithm Overview","text":"f(x)  -->  Polynomial p(x)  -->  Solve grad(p) = 0  -->  Refine with BFGS  -->  All minima\n           (Chebyshev/Legendre)   (HomotopyContinuation.jl)","category":"section"},{"location":"#Challenging-1D-function-—-multi-frequency-oscillations-at-varying-polynomial-degrees:","page":"Home","title":"Challenging 1D function — multi-frequency oscillations at varying polynomial degrees:","text":"(Image: 1D Comparison)","category":"section"},{"location":"#Styblinski-Tang-2D-—-classic-test-function-with-polynomial-approximation:","page":"Home","title":"Styblinski-Tang 2D — classic test function with polynomial approximation:","text":"(Image: Styblinski-Tang)\n\nFor functions that vary on different scales in different regions, Globtim uses adaptive subdivision to build piecewise polynomial approximations that maintain accuracy everywhere.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"julia> ]\npkg> add Globtim","category":"section"},{"location":"#Additional-Dependencies","page":"Home","title":"Additional Dependencies","text":"Visualization: add CairoMakie or add GLMakie\nExact solving: Install msolve (symbolic method based on Groebner basis computations)","category":"section"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"For a detailed walkthrough, see Getting Started.","category":"section"},{"location":"#Ecosystem","page":"Home","title":"Ecosystem","text":"Globtim is part of a three-package ecosystem for global optimization:\n\nPackage Description Repository\nGlobtim Core polynomial approximation and critical point finding GitHub\nGlobtimPostProcessing Refinement, validation, parameter recovery, campaign analysis GitHub\nGlobtimPlots Visualization (CairoMakie/GLMakie) for experiments and campaigns GitHub\n\nGlobtim (experiments) --> GlobtimPostProcessing (analysis) --> GlobtimPlots (visualization)\n\nInstall companion packages:\n\npkg> add GlobtimPostProcessing\npkg> add GlobtimPlots","category":"section"},{"location":"sparsification/#Polynomial-Sparsification-and-Exact-Arithmetic","page":"Sparsification","title":"Polynomial Sparsification and Exact Arithmetic","text":"Globtim now includes advanced features for exact polynomial arithmetic, sparsification, and truncation analysis. These features help reduce polynomial complexity while maintaining approximation quality.","category":"section"},{"location":"sparsification/#Overview","page":"Sparsification","title":"Overview","text":"The sparsification module provides:\n\nExact conversion from orthogonal bases (Chebyshev/Legendre) to monomial basis\nIntelligent sparsification that zeros small coefficients while tracking L²-norm preservation\nTruncation analysis with quality metrics\nMultiple L²-norm computation methods for verification","category":"section"},{"location":"sparsification/#Basic-Usage","page":"Sparsification","title":"Basic Usage","text":"","category":"section"},{"location":"sparsification/#Exact-Monomial-Conversion","page":"Sparsification","title":"Exact Monomial Conversion","text":"Convert a Globtim polynomial to exact monomial form:\n\nusing Globtim\nusing DynamicPolynomials\n\n# Create a polynomial approximation\nf = x -> sin(3*x[1])\nTR = TestInput(f, dim=1, center=[0.0], sample_range=1.0)\npol = Constructor(TR, 10, basis=:chebyshev)\n\n# Convert to exact monomial basis\n@polyvar x\nmono_poly = to_exact_monomial_basis(pol, variables=[x])","category":"section"},{"location":"sparsification/#Polynomial-Sparsification","page":"Sparsification","title":"Polynomial Sparsification","text":"Reduce polynomial complexity by removing small coefficients:\n\n# Sparsify with 1% relative threshold\nresult = sparsify_polynomial(pol, 0.01, mode=:relative)\n\nprintln(\"Achieved $(round((1-result.sparsity)*100))% sparsity\")\nprintln(\"L² norm preserved: $(round(result.l2_ratio*100, digits=1))%\")\nprintln(\"Removed $(length(result.zeroed_indices)) coefficients\")","category":"section"},{"location":"sparsification/#Truncation-Analysis","page":"Sparsification","title":"Truncation Analysis","text":"Analyze the impact of different truncation thresholds:\n\n# Analyze truncation with multiple thresholds\ndomain = BoxDomain(1, 1.0)  # [-1,1] domain\nthresholds = [1e-2, 1e-4, 1e-6, 1e-8]\nresults = analyze_truncation_impact(mono_poly, domain, thresholds=thresholds)\n\n# Display results\nfor res in results\n    println(\"Threshold $(res.threshold): $(res.remaining_terms)/$(res.original_terms) terms, L² ratio: $(round(res.l2_ratio, digits=4))\")\nend","category":"section"},{"location":"sparsification/#Advanced-Features","page":"Sparsification","title":"Advanced Features","text":"","category":"section"},{"location":"sparsification/#L-Norm-Computation-Methods","page":"Sparsification","title":"L²-Norm Computation Methods","text":"Compare different L²-norm computation approaches:\n\n# Method 1: Vandermonde-based (efficient for Globtim polynomials)\nl2_vand = compute_l2_norm_vandermonde(pol)\n\n# Method 2: Grid-based (for monomial polynomials)\ndomain = BoxDomain(1, 1.0)\nl2_grid = compute_l2_norm(mono_poly, domain)\n\n# Method 3: Modified coefficients\nsparse_coeffs = copy(pol.coeffs)\nsparse_coeffs[abs.(sparse_coeffs) .< 1e-6] .= 0\nl2_sparse = compute_l2_norm_coeffs(pol, sparse_coeffs)","category":"section"},{"location":"sparsification/#Approximation-Error-Analysis","page":"Sparsification","title":"Approximation Error Analysis","text":"Track how sparsification affects approximation quality:\n\n# Analyze approximation error vs sparsity tradeoff\nresults = analyze_approximation_error_tradeoff(f, pol, TR, \n                                              thresholds=[1e-4, 1e-6, 1e-8])\n\nfor res in results\n    println(\"Threshold $(res.threshold):\")\n    println(\"  Sparsity: $(round((1-res.sparsity)*100))%\")\n    println(\"  Approximation error: $(res.approx_error)\")\n    println(\"  Error increase: $(round((res.approx_error_ratio-1)*100, digits=1))%\")\nend","category":"section"},{"location":"sparsification/#Preserving-Important-Coefficients","page":"Sparsification","title":"Preserving Important Coefficients","text":"When sparsifying, you can preserve specific coefficients:\n\n# Preserve the first 5 coefficients (often the most important)\nresult = sparsify_polynomial(pol, 1e-4, mode=:relative, \n                           preserve_indices=[1, 2, 3, 4, 5])","category":"section"},{"location":"sparsification/#Complete-Workflow-Example","page":"Sparsification","title":"Complete Workflow Example","text":"Here's a complete workflow for polynomial approximation with sparsification:\n\nusing Globtim\nusing DynamicPolynomials\n\n# 1. Define function and create approximation\nf = x -> 1/(1 + 25*x[1]^2)  # Runge function\nTR = TestInput(f, dim=1, center=[0.0], sample_range=1.0)\npol = Constructor(TR, 20, basis=:chebyshev)\n\n# 2. Analyze sparsification options\nsparsity_analysis = analyze_sparsification_tradeoff(pol, \n                                                   thresholds=[1e-2, 1e-3, 1e-4, 1e-5])\n\n# 3. Choose threshold based on analysis\nchosen_threshold = 1e-4\nsparse_pol = sparsify_polynomial(pol, chosen_threshold, mode=:relative).polynomial\n\n# 4. Convert to exact monomial form\n@polyvar x\nmono_sparse = to_exact_monomial_basis(sparse_pol, variables=[x])\n\n# 5. Verify quality\ndomain = BoxDomain(1, 1.0)\nquality = verify_truncation_quality(\n    to_exact_monomial_basis(pol, variables=[x]), \n    mono_sparse, \n    domain\n)\n\nprintln(\"Final polynomial has $(count(!iszero, sparse_pol.coeffs)) non-zero terms\")\nprintln(\"L² norm preservation: $(round(quality.l2_ratio*100, digits=1))%\")","category":"section"},{"location":"sparsification/#Performance-Considerations","page":"Sparsification","title":"Performance Considerations","text":"Vandermonde approach: More efficient than polynomial construction for L² norms\nSparsification benefits: \nSignificant sparsity achievable while preserving L² accuracy\nReduced memory usage and faster polynomial operations\nExact arithmetic: Use RationalPrecision for exact coefficients, Float64Precision for speed","category":"section"},{"location":"sparsification/#API-Reference","page":"Sparsification","title":"API Reference","text":"","category":"section"},{"location":"sparsification/#Main-Functions","page":"Sparsification","title":"Main Functions","text":"to_exact_monomial_basis(pol; variables) - Convert to monomial basis\nsparsify_polynomial(pol, threshold; mode, preserve_indices) - Sparsify polynomial\ntruncate_polynomial(poly, threshold; mode, domain, l2_tolerance) - Truncate with L² checking\ncompute_l2_norm_vandermonde(pol) - Efficient L² norm computation\nanalyze_sparsification_tradeoff(pol; thresholds) - Analyze sparsity options\nverify_truncation_quality(original, truncated, domain) - Verify L² preservation","category":"section"},{"location":"sparsification/#Types","page":"Sparsification","title":"Types","text":"BoxDomain{T} - Represents box domain [-a,a]ⁿ\nAbstractDomain - Abstract type for integration domains","category":"section"}]
}
