# ==== For Msolve ====
"""
    process_output_file(file_path::String)

Parse the output file generated by `msolve`.

# Arguments
- `file_path::String`: Path to the output file.

# Returns
- Parsed content of the output file.
"""
function parse_rational(str::AbstractString)
    # Remove any whitespace
    str = strip(str)

    # Match the pattern numerator/2^exponent
    m = match(r"(-?\d+)/2\^(\d+)", str)
    if m === nothing
        error("Failed to parse rational number: $str")
    end

    numerator = parse(BigInt, m[1])
    exponent = parse(Int, m[2])
    denominator = BigInt(2)^exponent

    return numerator // denominator
end

function process_output_file(file_path::String; dim::Int=3)
    println("\n=== Starting file processing (dimension: $dim) ===")

    # Read file content
    content = read(file_path, String)
    println("Raw content length: ", length(content))

    # Clean up the content but preserve structure
    content = replace(content, r":\]$" => "]")  # Remove trailing colon
    content = replace(content, r"\s+" => "")    # Remove whitespace
    println("Cleaned content: ", content)

    # Find all rational number pairs
    # Pattern for matching [num/2^exp,num/2^exp]
    pair_pattern = r"\[([-\d]+/2\^[\d]+),([-\d]+/2\^[\d]+)\]"

    points = Vector{Vector{Float64}}()
    current_point = Vector{Float64}()

    for m in eachmatch(pair_pattern, content)
        # Parse first rational number
        r1 = parse_rational(m[1])
        # Parse second rational number
        r2 = parse_rational(m[2])

        # Calculate average and convert to float
        avg = Float64((r1 + r2) / 2)
        push!(current_point, avg)

        # If we have a complete point, add it to points
        if length(current_point) == dim
            push!(points, copy(current_point))
            current_point = Vector{Float64}()
        end
    end

    # Check for incomplete points
    if !isempty(current_point)
        error("Incomplete point found with $(length(current_point)) coordinates")
    end

    println("Successfully parsed $(length(points)) points of dimension $dim")
    return points
end

function msolve_parser(file_path::String, f::Function, dim::Int=3, TR::Union{test_input,Nothing}=nothing)
    println("\n=== Starting MSolve Parser (dimension: $dim) ===")

    if !isfile(file_path)
        error("File not found: $file_path")
    end

    try
        points = process_output_file(file_path, dim=dim)
        println("Processed $(length(points)) points")
        for (i, point) in enumerate(points)
            println("Point $i: ", point)
        end

        # Validate dimensions
        if !all(p -> length(p) == dim, points)
            invalid_points = filter(p -> length(p) != dim, points)
            error("Found points with incorrect dimension: $invalid_points")
        end

        # Filter points within [-1,1]^dim
        filtered_points = filter(p -> all(-1 .<= p .<= 1), points)
        println("$(length(filtered_points)) points after filtering")

        if isempty(filtered_points)
            println("No valid points found after filtering")
            return DataFrame(Dict(Symbol("x$i") => Float64[] for i in 1:dim))
        end

        # Apply translation if TR is provided
        points_to_process = if !isnothing(TR)
            # Extract coordinates before translation
            coords = [[p[i] for p in filtered_points] for i in 1:dim]
            # Apply translation to each coordinate array
            translated_coords = [TR.sample_range * coords[i] .+ TR.center[i] for i in 1:dim]
            println("Applied translation with sample_range and center")
            translated_coords
        else
            [[p[i] for p in filtered_points] for i in 1:dim]
        end

        # Compute function values
        z = map(p -> f(collect(p)), zip(points_to_process...))
        println("Computed function values")

        # Create DataFrame
        df_dict = Dict(Symbol("x$i") => points_to_process[i] for i in 1:dim)
        df_dict[:z] = z

        return DataFrame(df_dict)

    catch e
        println("Error in msolve_parser: ", e)
        println("Stack trace:")
        for (exc, bt) in Base.catch_stack()
            showerror(stdout, exc, bt)
            println()
        end
        rethrow(e)
    end
end


"""
    parse_point(X::Vector{Vector{Vector{BigInt}}})::Vector{Rational{BigInt}}

Parse a nested vector of `BigInt` values and convert them into a vector of `Rational{BigInt}`.

# Arguments
- `X::Vector{Vector{Vector{BigInt}}}`: A nested vector where each element is a vector of two vectors, each containing two `BigInt` values. The first value in each inner vector represents the numerator, and the second value represents the exponent of the denominator (which is a power of 2).

# Returns
- `Vector{Rational{BigInt}}`: A vector of `Rational{BigInt}` values, where each value is the average of the two rational numbers represented by the input vectors.

# Example
```julia
X = [
    [[1, 1], [3, 1]],  # Represents 1/2 and 3/2
    [[2, 2], [6, 2]]   # Represents 2/4 and 6/4
]
result = parse_point(X)
# result is a vector of Rational{BigInt} values: [1, 1]

"""
function parse_point(X::Vector{Vector{Vector{BigInt}}})::Vector{Rational{BigInt}}
    pts = Vector{Rational{BigInt}}()
    for x in X
        numer_low = x[1][1]
        denom_low = BigInt(2)^x[1][2]
        numer_hig = x[2][1]
        denom_hig = BigInt(2)^x[2][2]
        LW = Rational{BigInt}(numer_low, denom_low)
        HG = Rational{BigInt}(numer_hig, denom_hig)
        AVG = (LW + HG) / 2
        push!(pts, AVG)
    end
    return (pts)
end

"""
Process critical points in n-dimensional space and return a DataFrame.
Only keeps points in [-1,1]^n.
"""
function process_critical_points(real_pts, f, scale_factor, dim::Int=2; TR::Union{test_input,Nothing}=nothing)
    # Check if point is in [-1,1]^n hypercube
    condition(point) = all(-1 .< point .< 1)
    filtered_points = filter(condition, real_pts)

    # If TR is provided, translate filtered points relative to center
    points_to_process = if !isnothing(TR)
        [TR.sample_range * point .+ TR.center for point in filtered_points]
    else
        filtered_points
    end

    # Extract coordinates
    coords = [Float64[point[i] for point in points_to_process] for i in 1:dim]

    # Calculate function values
    scaled_coords = [scale_factor * coord for coord in coords]
    z = map(p -> f(collect(p)), zip(scaled_coords...))

    # Create DataFrame
    df_dict = Dict(Symbol("x$i") => scale_factor * coords[i] for i in 1:dim)
    df_dict[:z] = z

    DataFrame(df_dict)
end

function average(X::Vector{T}) where {T<:Number}
    # Convert each number to rational first
    rationals = Rational{BigInt}.(X)
    # Take the average
    avg_rational = sum(rationals) // length(X)
    # Convert back to float
    return Float64(avg_rational)
end

# Helper function to check if the result is reasonable
function safe_average(X::Vector{T}) where {T<:Number}
    result = average(X)
    if isinf(result) || isnan(result)
        println("Warning: got $(result) for input: $X")
        # Could add fallback behavior here if needed
    end
    return result
end

### Plots ###

function plot_polyapprox(pol::ApproxPoly, TR::test_input, df::DataFrame)
    # Extract coordinates and function values
    coords = pol.scale_factor * pol.grid .+ TR.center'
    z_coords = pol.z

    if size(coords)[2] == 2  # Plot if the dimensions are 2
        fig = Figure(size=(800, 600))
        ax = Axis3(fig[1, 1], title="Trefethen Function",
            xlabel="X-axis", ylabel="Y-axis", zlabel="Z-axis")

        # Create a regular grid for surface plotting
        x_unique = sort(unique(coords[:, 1]))
        y_unique = sort(unique(coords[:, 2]))

        # Initialize the Z grid with NaN
        Z = fill(NaN, (length(y_unique), length(x_unique)))

        # Fill the Z grid by matching coordinates
        for (idx, (x, y, z)) in enumerate(zip(coords[:, 1], coords[:, 2], z_coords))
            i = findlast(≈(y), y_unique)
            j = findlast(≈(x), x_unique)
            if !isnothing(i) && !isnothing(j)
                Z[j, i] = z
            end
        end

        # Create surface plot
        surface!(ax, x_unique, y_unique, Z,
            colormap=:viridis,
            transparency=true,
            alpha=0.8)

        # Plot the critical points
        scatter!(ax, df.x1, df.x2,
            df.z,
            markersize=10,
            color=:orange,
            label="Chebyshev approximant critical points")

        display(fig)
        return fig
    end
end